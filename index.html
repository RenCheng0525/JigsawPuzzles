<!DOCTYPE html>
<html>

<head>
    <title>æ›²ç·šæ‹¼åœ–éŠæˆ²</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            height: 100vh;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }

        .game-area {
            width: 100%;
            height: 100%;
            background-color: #1a1a2e;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }

        .puzzle-container {
            position: absolute;
            background-color: #1a1a2e;
            box-sizing: border-box;
            /* ä½ç½®ç”± JS å‹•æ…‹è¨­ç½® */
        }

        .puzzle-piece {
            position: absolute;
            cursor: move;
            transition: none;
            background-repeat: no-repeat;
            z-index: 1;
            touch-action: none;
        }

        .puzzle-piece.dragging {
            z-index: 1001;
            filter: brightness(1.1);
        }

        /* æ§åˆ¶é¢æ¿æŠ½å±œ - å°ˆæ¥­æ·±è‰²é¢¨æ ¼ */
        .controls-drawer {
            position: absolute;
            top: 0;
            left: 0;
            width: 200px;
            height: 100%;
            background: rgba(20, 20, 20, 0.95);
            border-right: 2px solid rgba(255, 215, 0, 0.6);
            box-shadow: 2px 0 15px rgba(0,0,0,0.5);
            z-index: 2000;
            transition: transform 0.3s ease;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
            color: white;
        }
        .controls-drawer.collapsed {
            transform: translateX(-200px);
        }
        .controls-toggle {
            position: absolute;
            top: 50%;
            left: 200px;
            transform: translateY(-50%);
            width: 28px;
            height: 50px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-left: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 14px;
            color: white;
            z-index: 2001;
            transition: left 0.3s ease;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }
        .controls-toggle:hover {
            background: rgba(40, 40, 40, 0.95);
        }
        .controls-drawer.collapsed + .controls-toggle {
            left: 0;
        }
        .controls-drawer h1 {
            margin: 0 0 12px 0;
            font-size: 1.2em;
            color: gold;
            text-align: center;
        }
        .controls-drawer .button {
            width: 100%;
            padding: 10px;
            margin: 4px 0;
            background: rgba(255, 215, 0, 0.2);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        .controls-drawer .button:hover {
            background: rgba(255, 215, 0, 0.3);
            border-color: gold;
        }
        .controls-drawer .button:active { 
            background: rgba(255, 215, 0, 0.4);
        }
        .controls-drawer select {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            background: rgba(40, 40, 40, 0.9);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
        }
        .controls-drawer select option {
            background: #222;
            color: white;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 6px 0;
            font-size: 13px;
            color: #ddd;
        }
        .checkbox-input { 
            width: 16px; 
            height: 16px;
            accent-color: gold;
        }

        /* æµ®å‹•é è¦½åœ– */
        /* æ‹¼åœ–æŠ½å±œ - æ·±è—è‰²èª¿èˆ‡æ‹¼åœ–å€å€éš” */
        .puzzle-drawer {
            position: absolute;
            background: linear-gradient(135deg, rgba(20, 30, 50, 0.95), rgba(30, 40, 60, 0.95));
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            overflow: auto;
            z-index: 100;
            padding: 10px;
            gap: 8px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        /* æ•£äº‚æ¨¡å¼ - é—œé–‰ flex æ’åˆ—ï¼Œç¦æ­¢æ»¾å‹• */
        .puzzle-drawer.scatter-mode {
            display: block;
            overflow: hidden;
        }
        .puzzle-drawer.scatter-mode .drawer-piece-wrapper {
            position: absolute !important;
        }
        .puzzle-drawer.drawer-bottom { bottom: 0; left: 0; right: 0; height: 180px; border-top: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-top { top: 0; left: 0; right: 0; height: 180px; border-bottom: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-left { top: 0; left: 0; bottom: 0; width: 180px; border-right: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-right { top: 0; right: 0; bottom: 0; width: 180px; border-left: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-none { display: none; }
        
        /* Drawer èª¿æ•´å¤§å°çš„æ‹–æ›³æ¢ï¼ˆç¨ç«‹æ–¼ drawer å¤–ï¼‰ */
        .drawer-resize-handle {
            position: absolute;
            background: rgba(25, 35, 55, 0.95);
            z-index: 150;
            transition: background 0.2s;
            display: none;
        }
        .drawer-resize-handle.visible { display: block; }
        .drawer-resize-handle:hover, .drawer-resize-handle.active {
            background: rgba(60, 100, 180, 0.9);
        }
        .drawer-resize-handle.horizontal {
            left: 0; right: 0; height: 20px; cursor: ns-resize;
        }
        .drawer-resize-handle.vertical {
            width: 20px; cursor: ew-resize;
        }
        .puzzle-drawer.drawer-none { display: none; }

        .drawer-piece-wrapper {
            position: relative;
            cursor: grab;
            flex-shrink: 0;
            margin: 9px;
            overflow: visible;
        }
        .drawer-piece-wrapper.dragging { opacity: 0.3; }
        .drawer-piece-wrapper.placed { display: none; }
        
        .drawer-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 14px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
            pointer-events: none;
        }
        
        .drawer-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: gold;
            font-size: 16px;
            font-weight: bold;
            padding: 4px 10px;
            border-radius: 6px;
            border: 2px solid gold;
            pointer-events: none;
            animation: hintFade 3s ease-out forwards;
        }
        
        @keyframes hintFade {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        .drawer-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 4px;
            z-index: 101;
        }
        .drawer-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 12px;
            cursor: pointer;
        }
        .drawer-btn:hover { background: rgba(0,0,0,0.9); }
        .drawer-btn.active { background: rgba(74,144,217,0.8); border-color: #4a90d9; }
        .drawer-btn.shuffle-btn { background: rgba(0,0,0,0.7); }
        .drawer-btn.shuffle-btn:hover { background: rgba(0,0,0,0.9); }
        
        /* é¡è‰²é¸æ“‡å™¨ */
        .color-picker-wrapper {
            position: relative;
            display: inline-block;
            margin-top: 8px;
        }
        .color-picker-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
            cursor: pointer;
            background: #1a1a2e;
            transition: all 0.2s;
        }
        .color-picker-btn:hover {
            transform: scale(1.1);
            border-color: white;
        }
        .color-picker-popup {
            display: none;
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            border-radius: 20px;
            padding: 8px;
            gap: 6px;
            flex-wrap: wrap;
            width: 90px;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .color-picker-popup.show {
            display: flex;
        }
        .color-option {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
            transition: all 0.2s;
        }
        .color-option:hover {
            transform: scale(1.15);
            border-color: white;
        }
        .color-option.active {
            border-color: white;
            box-shadow: 0 0 8px rgba(255,255,255,0.6);
        }
        
        /* å®Œæˆè¨Šæ¯ */
        .completion-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(0,0,0,0.9);
            color: white;
            font-size: 28px;
            font-weight: bold;
            padding: 30px 50px;
            border-radius: 20px;
            border: 3px solid gold;
            z-index: 9999;
            opacity: 0;
            transition: all 0.3s ease;
            text-align: center;
        }
        .completion-message.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        /* è¼‰å…¥é€²åº¦ */
        .progress-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .progress-text {
            color: gold;
            font-size: 20px;
            margin-bottom: 20px;
        }
        .progress-bar {
            width: 250px;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid gold;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, gold, orange);
            width: 0%;
            transition: width 0.1s;
        }
        
        .drawer-count {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 12px;
            z-index: 101;
        }

        .piece-outline { pointer-events: none; }
        .puzzle-piece.dragging {
            z-index: 1000 !important;
        }
        .piece-number {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 9px;
            pointer-events: none;
        }

        /* é•·æŒ‰é è¦½ */
        .preview-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            z-index: 99999;
        }
        .preview-overlay.show { display: flex; }
        .preview-overlay img { max-width: 90%; max-height: 90%; }
    </style>
</head>

<body>
    <div class="game-area" id="gameArea">
        <div id="worldContainer" style="position: absolute; left: 0; top: 0; width: 100%; height: 100%;">
            <div id="puzzleContainer" class="puzzle-container"></div>
        </div>
        
        <!-- æ§åˆ¶é¢æ¿æŠ½å±œ -->
        <div class="controls-drawer" id="controlsDrawer">
            <h1>ğŸ§© æ‹¼åœ–éŠæˆ²</h1>
            <input type="file" id="imageInput" accept="image/*" style="display:none;">
            <button class="button" onclick="selectImage()">ğŸ“· é¸æ“‡åœ–ç‰‡</button>
            <select id="pieceCount">
                <option value="25">5x5 (25ç‰‡)</option>
                <option value="36">6x6 (36ç‰‡)</option>
                <option value="49">7x7 (49ç‰‡)</option>
                <option value="64">8x8 (64ç‰‡)</option>
                <option value="81">9x9 (81ç‰‡)</option>
                <option value="100">10x10 (100ç‰‡)</option>
                <option value="121">11x11 (121ç‰‡)</option>
                <option value="144">12x12 (144ç‰‡)</option>
                <option value="169">13x13 (169ç‰‡)</option>
                <option value="196">14x14 (196ç‰‡)</option>
                <option value="225">15x15 (225ç‰‡)</option>
                <option value="256">16x16 (256ç‰‡)</option>
            </select>
            <button class="button" onclick="startGame()">â–¶ é–‹å§‹éŠæˆ²</button>
            <button class="button" onclick="autoComplete()">âœ¨ è‡ªå‹•å®Œæˆ</button>
            <div class="checkbox-container">
                <input type="checkbox" id="toggleHint" class="checkbox-input">
                <label for="toggleHint" class="checkbox-label">æç¤º</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="toggleRotation" class="checkbox-input" checked>
                <label for="toggleRotation" class="checkbox-label">æ—‹è½‰</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="toggleTray" class="checkbox-input">
                <label for="toggleTray" class="checkbox-label">æ‰˜ç›¤</label>
            </div>
            <div class="color-picker-wrapper">
                <button class="color-picker-btn" id="colorPickerBtn" style="background:#1a1a2e;" onclick="toggleColorPicker()"></button>
                <div class="color-picker-popup" id="colorPickerPopup">
                    <button class="color-option active" data-color="#1a1a2e" style="background:#1a1a2e;" onclick="setBgColor('#1a1a2e')"></button>
                    <button class="color-option" data-color="#2d4a3e" style="background:#2d4a3e;" onclick="setBgColor('#2d4a3e')"></button>
                    <button class="color-option" data-color="#4a3728" style="background:#4a3728;" onclick="setBgColor('#4a3728')"></button>
                    <button class="color-option" data-color="#3d2845" style="background:#3d2845;" onclick="setBgColor('#3d2845')"></button>
                    <button class="color-option" data-color="#2c3e50" style="background:#2c3e50;" onclick="setBgColor('#2c3e50')"></button>
                    <button class="color-option" data-color="#1e3a5f" style="background:#1e3a5f;" onclick="setBgColor('#1e3a5f')"></button>
                </div>
            </div>
            <div style="margin-top:10px; font-size:10px; color:#aaa;">ğŸ’¡ é•·æŒ‰ç©ºç™½è™•æŸ¥çœ‹åŸåœ–</div>
        </div>
        <button class="controls-toggle" id="controlsToggle" onclick="toggleControls()">â—€</button>
        
        <!-- æŠ½å±œæ§åˆ¶ -->
        <div class="drawer-count" id="drawerCount" style="display: none;">å‰©é¤˜: 0 å¡Š</div>
        <div class="drawer-controls" style="display: none;">
            <button class="drawer-btn" onclick="setDrawerPosition('top')">â¬†</button>
            <button class="drawer-btn active" onclick="setDrawerPosition('bottom')">â¬‡</button>
            <button class="drawer-btn" onclick="setDrawerPosition('left')">â¬…</button>
            <button class="drawer-btn" onclick="setDrawerPosition('right')">â¡</button>
            <button class="drawer-btn" onclick="setDrawerPosition('none')">âœ•</button>
            <button class="drawer-btn shuffle-btn" onclick="shuffleDrawer()">ğŸ”€</button>
            <button class="drawer-btn scatter-btn" id="scatterBtn" onclick="toggleScatterBtn()">ğŸ“¦</button>
        </div>
        
        <!-- æ‹¼åœ–æŠ½å±œ -->
        <div class="puzzle-drawer drawer-bottom" id="puzzleDrawer" style="display: none;"></div>
        <!-- Drawer å¤§å°èª¿æ•´æ‹–æ›³æ¢ï¼ˆç¨ç«‹æ–¼ drawer å¤–ï¼‰ -->
        <div class="drawer-resize-handle horizontal" id="drawerResizeHandle" style="display: none;"></div>
    </div>

    <div class="preview-overlay" id="previewOverlay">
        <img id="previewOverlayImg" src="">
    </div>

    <script>
        // å…¨å±€è®Šé‡
        let originalImage = null;
        let pieces = [];
        let currentPiece = null;
        let isPlaying = false;
        let edges = null;
        let showHint = false;
        let enableRotation = true;
        let scatterMode = false; // æ•£äº‚æ¨¡å¼
        let trayMode = false; // æ‰˜ç›¤æ¨¡å¼ï¼ˆtrue=ä½¿ç”¨drawer, false=æ•£è½åœ¨æ ¼ç·šå€å‘¨åœï¼‰
        let rows, cols;
        let drawerPosition = 'bottom';
        let drawerPieces = [];
        let audioContext = null;
        let controlsCollapsed = false;
        let drawerPieceZIndex = 1; // æ•£äº‚æ¨¡å¼ä¸­æ‹¼åœ–çš„ z-index è¨ˆæ•¸å™¨
        
        // å­˜æª”ç›¸é—œ
        const SAVE_KEY = 'jigsaw_puzzle_save';
        let autoSaveTimer = null;
        
        // æ‹¼åœ–å€æ‹–æ›³ç›¸é—œ
        let containerDrag = {
            active: false,
            startX: 0,
            startY: 0,
            startLeft: 0,
            startTop: 0
        };
        let containerOriginalPos = { left: 0, top: 0 };
        let containerDragLimit = { x: 0, y: 0 };
        
        // Drawer å¤§å°èª¿æ•´ç›¸é—œ
        let drawerResize = {
            active: false,
            startPos: 0,
            startSize: 0
        };
        let drawerSize = 180; // åˆå§‹å¤§å°
        let pieceWidth = 0, pieceHeight = 0; // å–®å€‹æ‹¼åœ–å¤§å°ï¼ˆå« tabï¼‰
        
        // å…©æŒ‡ç¸®æ”¾ç›¸é—œ
        let pinchZoom = {
            active: false,
            startDistance: 0,
            startScale: 1
        };
        let containerScale = 1; // ç›®å‰ç¸®æ”¾æ¯”ä¾‹
        let baseContainerWidth = 0, baseContainerHeight = 0; // åŸå§‹å®¹å™¨å¤§å°
        let worldOffset = { x: 0, y: 0 }; // ä¸–ç•Œå¹³ç§»åç§»

        // é¸æ“‡åœ–ç‰‡
        function selectImage() {
            // å¦‚æœåœ¨ Android WebView ä¸­ï¼Œä½¿ç”¨ Android ä»‹é¢
            if (typeof Android !== 'undefined' && Android.selectImage) {
                Android.selectImage();
            } else {
                // å¦å‰‡ä½¿ç”¨æ¨™æº– file input
                document.getElementById('imageInput').click();
            }
        }
        
        // Android å‘¼å«çš„å‡½æ•¸ï¼šå¾ Base64 è¼‰å…¥åœ–ç‰‡
        function loadImageFromBase64(base64) {
            loadImage('data:image/jpeg;base64,' + base64);
        }

        // æ§åˆ¶é¢æ¿æ”¶åˆ
        function toggleControls() {
            controlsCollapsed = !controlsCollapsed;
            document.getElementById('controlsDrawer').classList.toggle('collapsed', controlsCollapsed);
            document.getElementById('controlsToggle').textContent = controlsCollapsed ? 'â–¶' : 'â—€';
        }

        // éŸ³æ•ˆ
        function playSnapSound() {
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain); gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(880, audioContext.currentTime);
                osc.frequency.setValueAtTime(1175, audioContext.currentTime + 0.05);
                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                osc.start(); osc.stop(audioContext.currentTime + 0.15);
            } catch(e) {}
        }
        
        function playWinSound() {
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                [523, 659, 784, 1047].forEach((f, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain); gain.connect(audioContext.destination);
                    osc.frequency.setValueAtTime(f, audioContext.currentTime);
                    const t = audioContext.currentTime + i * 0.12;
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.3, t + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                    osc.start(t); osc.stop(t + 0.3);
                });
            } catch(e) {}
        }

        // æŠ½å±œæ§åˆ¶
        function setDrawerPosition(pos) {
            const wasScatterMode = scatterMode;
            drawerPosition = pos;
            const drawer = document.getElementById('puzzleDrawer');
            const handle = document.getElementById('drawerResizeHandle');
            const gameArea = document.getElementById('gameArea');
            
            drawer.className = 'puzzle-drawer drawer-' + pos + (wasScatterMode ? ' scatter-mode' : '');
            document.querySelectorAll('.drawer-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            // æ›´æ–° resize handle æ–¹å‘ã€ä½ç½®å’Œ drawer å¤§å°ï¼ˆç·Šè²¼ drawer é‚Šç·£ï¼‰
            if (pos === 'none') {
                handle.classList.remove('visible');
            } else if (pos === 'top' || pos === 'bottom') {
                handle.className = 'drawer-resize-handle horizontal visible';
                drawer.style.width = '';
                drawer.style.height = drawerSize + 'px';
                handle.style.top = (pos === 'bottom') ? (gameArea.offsetHeight - drawerSize - 20) + 'px' : drawerSize + 'px';
                handle.style.bottom = '';
                handle.style.left = '0';
                handle.style.right = '0';
            } else if (pos === 'left' || pos === 'right') {
                handle.className = 'drawer-resize-handle vertical visible';
                drawer.style.height = '';
                drawer.style.width = drawerSize + 'px';
                handle.style.left = (pos === 'left') ? drawerSize + 'px' : '';
                handle.style.right = (pos === 'right') ? (drawerSize + 20) + 'px' : '';
                handle.style.top = '0';
                handle.style.bottom = '0';
            }
            
            // åªæ›´æ–°ä½ç½®ï¼Œä¸æ”¹è®Šå¤§å°
            if (originalImage && isPlaying) {
                const container = document.getElementById('puzzleContainer');
                const w = parseFloat(container.style.width);
                const h = parseFloat(container.style.height);
                const newPos = calculateContainerPosition(w, h);
                container.style.left = newPos.left + 'px';
                container.style.top = newPos.top + 'px';
                // æ›´æ–°åŸå§‹ä½ç½®ï¼ˆé‡ç½®æ‹–æ›³ï¼‰
                containerOriginalPos = { left: newPos.left, top: newPos.top };
            }
            
            // æ•£äº‚æ¨¡å¼ä¸‹ï¼Œåˆ‡æ› drawer æ–¹å‘æ™‚é‡æ–°æ’åˆ—
            if (wasScatterMode && pos !== 'none') {
                repositionScatteredPieces();
            }
        }
        
        // é‡æ–°æ’åˆ—æ•£äº‚æ¨¡å¼çš„æ‹¼åœ–ï¼ˆè®“å®ƒå€‘éš¨æ©Ÿæ•£è½åœ¨å¯è¦–å€å…§ï¼‰
        function repositionScatteredPieces() {
            if (!scatterMode || drawerPieces.length === 0) return;
            
            const drawer = document.getElementById('puzzleDrawer');
            const isVerticalDrawer = (drawerPosition === 'left' || drawerPosition === 'right');
            
            // drawer çš„å¯¦éš›å¯è¦–å°ºå¯¸
            const drawerW = isVerticalDrawer ? drawerSize : drawer.offsetWidth;
            const drawerH = isVerticalDrawer ? drawer.offsetHeight : drawerSize;
            
            // å–å¾—æœªæ”¾ç½®çš„æ‹¼åœ–
            const unplacedPieces = drawerPieces.filter(dp => !dp.isPlaced);
            if (unplacedPieces.length === 0) return;
            
            // éš¨æ©Ÿæ”¾ç½®ç¯„åœï¼ˆç•™ä¸€é»é‚Šè·ï¼Œä½†æ‹¼åœ–å¯ä»¥é‡ç–Šã€å¯ä»¥éƒ¨åˆ†è¶…å‡ºï¼‰
            const maxX = Math.max(10, drawerW - 50);
            const maxY = Math.max(10, drawerH - 50);
            
            unplacedPieces.forEach(dp => {
                const item = dp.drawerItem;
                // ç›´æ¥ç”¨äº‚æ•¸æ”¾ç½®
                item.style.left = (Math.random() * maxX) + 'px';
                item.style.top = (Math.random() * maxY) + 'px';
                item.style.zIndex = drawerPieceZIndex++;
            });
        }
        
        // æ›´æ–° resize handle ä½ç½®ï¼ˆç•¶ drawer å¤§å°æ”¹è®Šæ™‚å‘¼å«ï¼Œç·Šè²¼ drawer é‚Šç·£ï¼‰
        function updateResizeHandlePosition() {
            const handle = document.getElementById('drawerResizeHandle');
            const gameArea = document.getElementById('gameArea');
            
            if (drawerPosition === 'bottom') {
                handle.style.top = (gameArea.offsetHeight - drawerSize - 20) + 'px';
            } else if (drawerPosition === 'top') {
                handle.style.top = drawerSize + 'px';
            } else if (drawerPosition === 'left') {
                handle.style.left = drawerSize + 'px';
                handle.style.right = '';
            } else if (drawerPosition === 'right') {
                handle.style.right = (drawerSize + 20) + 'px';
                handle.style.left = '';
            }
        }
        
        function updateDrawerCount() {
            document.getElementById('drawerCount').textContent = 'å‰©é¤˜: ' + drawerPieces.filter(d => !d.isPlaced).length + ' å¡Š';
        }
        
        function shuffleDrawer() {
            const drawer = document.getElementById('puzzleDrawer');
            
            // æ•£äº‚æ¨¡å¼ï¼šé‡æ–°éš¨æ©Ÿæ”¾ç½®æ‰€æœ‰æœªæ”¾ç½®çš„æ‹¼åœ–
            if (scatterMode) {
                repositionScatteredPieces();
                return;
            }
            
            // éæ•£äº‚æ¨¡å¼ï¼šé‡æ–°æ’åˆ— DOM é †åº
            const items = Array.from(drawer.children);
            for (let i = items.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                drawer.appendChild(items[j]);
            }
        }
        
        function updateDrawerLabels() {
            // åªæ›´æ–°ç‹€æ…‹ï¼Œä¸æ·»åŠ æ°¸ä¹…æ¨™ç±¤
            // å‹¾é¸å¾Œé»æ“Šæ‹¼åœ–æœƒé¡¯ç¤º 3 ç§’æç¤º
        }

        // é•·æŒ‰é è¦½
        let longPressTimer = null;
        
        function showFullPreview() {
            if (!originalImage) return;
            document.getElementById('previewOverlayImg').src = originalImage.src;
            document.getElementById('previewOverlay').classList.add('show');
            if (navigator.vibrate) navigator.vibrate(30);
        }
        
        function hideFullPreview() {
            document.getElementById('previewOverlay').classList.remove('show');
        }
        
        document.getElementById('gameArea').addEventListener('touchstart', function(e) {
            // å…©æŒ‡ä»¥ä¸Šä¸è§¸ç™¼é•·æŒ‰é è¦½
            if (e.touches.length > 1) {
                clearTimeout(longPressTimer);
                return;
            }
            if (e.target.closest('.drawer-piece-wrapper') || e.target.closest('.drawer-btn') || 
                e.target.closest('.puzzle-drawer') || e.target.closest('.controls-drawer') ||
                e.target.closest('.controls-toggle') || e.target.closest('.drawer-resize-handle')) return;
            longPressTimer = setTimeout(showFullPreview, 500);
        }, {passive: true});
        
        document.getElementById('gameArea').addEventListener('touchend', function() {
            clearTimeout(longPressTimer); hideFullPreview();
        }, {passive: true});
        
        document.getElementById('gameArea').addEventListener('touchmove', function(e) {
            // å…©æŒ‡ç¸®æ”¾æ™‚ä¹Ÿå–æ¶ˆé•·æŒ‰
            if (e.touches.length > 1) {
                clearTimeout(longPressTimer);
                hideFullPreview();
            }
            clearTimeout(longPressTimer);
        }, {passive: true});
        
        document.getElementById('previewOverlay').addEventListener('click', hideFullPreview);

        // æ‹¼åœ–å€æ‹–æ›³åŠŸèƒ½
        function initContainerDrag() {
            const gameArea = document.getElementById('gameArea');
            const container = document.getElementById('puzzleContainer');
            
            // æ»‘é¼ äº‹ä»¶ - åœ¨ game-area ç©ºç™½è™•æ‹–æ›³
            gameArea.addEventListener('mousedown', function(e) {
                if (!isPlaying) return;
                // æ’é™¤ UI å…ƒç´ 
                if (e.target.closest('.puzzle-piece') || 
                    e.target.closest('.drawer-piece-wrapper') ||
                    e.target.closest('.puzzle-drawer') ||
                    e.target.closest('.controls-drawer') ||
                    e.target.closest('.controls-toggle') ||
                    e.target.closest('.drawer-controls')) return;
                
                // åˆ¤æ–·æ˜¯å¦åœ¨è™›ç·šé‚Šæ¡†å…§
                const gameAreaRect = gameArea.getBoundingClientRect();
                const clickX = e.clientX - gameAreaRect.left;
                const clickY = e.clientY - gameAreaRect.top;
                
                const baseMargin = 10;
                const borderWidth = (gameArea.offsetWidth - baseMargin * 2) * containerScale;
                const borderHeight = (gameArea.offsetHeight - baseMargin * 2) * containerScale;
                const borderLeft = (gameArea.offsetWidth - borderWidth) / 2;
                const borderTop = (gameArea.offsetHeight - borderHeight) / 2;
                
                // åŠ ä¸Šä¸–ç•Œå¹³ç§»åç§»
                const actualBorderLeft = borderLeft + worldOffset.x;
                const actualBorderTop = borderTop + worldOffset.y;
                
                const insideBorder = clickX >= actualBorderLeft && 
                                     clickX <= actualBorderLeft + borderWidth &&
                                     clickY >= actualBorderTop && 
                                     clickY <= actualBorderTop + borderHeight;
                
                containerDrag.active = true;
                containerDrag.startX = e.clientX;
                containerDrag.startY = e.clientY;
                containerDrag.startLeft = parseFloat(container.style.left) || 0;
                containerDrag.startTop = parseFloat(container.style.top) || 0;
                containerDrag.isWorldPan = !insideBorder && !trayMode; // è™›ç·šå¤–ä¸”æ•£è½æ¨¡å¼æ‰æ˜¯ä¸–ç•Œå¹³ç§»
                containerDrag.startWorldX = worldOffset.x;
                containerDrag.startWorldY = worldOffset.y;
                e.preventDefault();
            });
            
            // è§¸æ§äº‹ä»¶ - åœ¨ game-area ç©ºç™½è™•æ‹–æ›³
            gameArea.addEventListener('touchstart', function(e) {
                if (!isPlaying) return;
                if (e.target.closest('.puzzle-piece') || 
                    e.target.closest('.drawer-piece-wrapper') ||
                    e.target.closest('.puzzle-drawer') ||
                    e.target.closest('.controls-drawer') ||
                    e.target.closest('.controls-toggle') ||
                    e.target.closest('.drawer-controls')) return;
                
                const touch = e.touches[0];
                
                // åˆ¤æ–·æ˜¯å¦åœ¨è™›ç·šé‚Šæ¡†å…§
                const gameAreaRect = gameArea.getBoundingClientRect();
                const clickX = touch.clientX - gameAreaRect.left;
                const clickY = touch.clientY - gameAreaRect.top;
                
                const baseMargin = 10;
                const borderWidth = (gameArea.offsetWidth - baseMargin * 2) * containerScale;
                const borderHeight = (gameArea.offsetHeight - baseMargin * 2) * containerScale;
                const borderLeft = (gameArea.offsetWidth - borderWidth) / 2;
                const borderTop = (gameArea.offsetHeight - borderHeight) / 2;
                
                // åŠ ä¸Šä¸–ç•Œå¹³ç§»åç§»
                const actualBorderLeft = borderLeft + worldOffset.x;
                const actualBorderTop = borderTop + worldOffset.y;
                
                const insideBorder = clickX >= actualBorderLeft && 
                                     clickX <= actualBorderLeft + borderWidth &&
                                     clickY >= actualBorderTop && 
                                     clickY <= actualBorderTop + borderHeight;
                
                containerDrag.active = true;
                containerDrag.startX = touch.clientX;
                containerDrag.startY = touch.clientY;
                containerDrag.startLeft = parseFloat(container.style.left) || 0;
                containerDrag.startTop = parseFloat(container.style.top) || 0;
                containerDrag.isWorldPan = !insideBorder && !trayMode;
                containerDrag.startWorldX = worldOffset.x;
                containerDrag.startWorldY = worldOffset.y;
            }, {passive: true});
        }
        
        document.addEventListener('mousemove', function(e) {
            if (!containerDrag.active) return;
            
            const dx = e.clientX - containerDrag.startX;
            const dy = e.clientY - containerDrag.startY;
            
            if (containerDrag.isWorldPan) {
                // ä¸–ç•Œå¹³ç§»æ¨¡å¼ï¼šç§»å‹•æ•´å€‹ä¸–ç•Œï¼ˆæ ¼ç·šå€ + æ‹¼åœ– + é‚Šæ¡†ï¼‰
                const gameArea = document.getElementById('gameArea');
                const maxOffset = Math.min(gameArea.offsetWidth, gameArea.offsetHeight) / 2;
                
                let newWorldX = containerDrag.startWorldX + dx;
                let newWorldY = containerDrag.startWorldY + dy;
                
                // é™åˆ¶å¹³ç§»ç¯„åœï¼ˆåŠå€‹è¢å¹•ï¼‰
                newWorldX = Math.max(-maxOffset, Math.min(maxOffset, newWorldX));
                newWorldY = Math.max(-maxOffset, Math.min(maxOffset, newWorldY));
                
                worldOffset.x = newWorldX;
                worldOffset.y = newWorldY;
                
                // æ›´æ–°æ‰€æœ‰å…ƒç´ ä½ç½®
                updateWorldPosition();
            } else {
                // åŸä¾†çš„æ ¼ç·šå€æ‹–æ›³é‚è¼¯
                const container = document.getElementById('puzzleContainer');
                let newLeft = containerDrag.startLeft + dx;
                let newTop = containerDrag.startTop + dy;
                
                const gameArea = document.getElementById('gameArea');
                const baseMargin = 10;
                
                // ç¸®æ”¾å¾Œçš„é‚Šæ¡†ç¯„åœ
                const borderWidth = (gameArea.offsetWidth - baseMargin * 2) * containerScale;
                const borderHeight = (gameArea.offsetHeight - baseMargin * 2) * containerScale;
                const borderLeft = (gameArea.offsetWidth - borderWidth) / 2;
                const borderTop = (gameArea.offsetHeight - borderHeight) / 2;
                
                // ç¸®æ”¾å¾Œçš„æ ¼ç·šå€å¤§å°
                const scaledContainerWidth = baseContainerWidth * containerScale;
                const scaledContainerHeight = baseContainerHeight * containerScale;
                const offsetX = (baseContainerWidth - scaledContainerWidth) / 2;
                const offsetY = (baseContainerHeight - scaledContainerHeight) / 2;
                
                // é™åˆ¶ï¼šæ ¼ç·šå€ç¸®æ”¾å¾Œçš„é‚Šç·£ä¸èƒ½è¶…å‡ºè™›ç·š
                const minLeft = borderLeft - offsetX;
                const maxLeft = borderLeft + borderWidth - scaledContainerWidth - offsetX;
                const minTop = borderTop - offsetY;
                const maxTop = borderTop + borderHeight - scaledContainerHeight - offsetY;
                
                newLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
                newTop = Math.max(minTop, Math.min(maxTop, newTop));
                
                container.style.left = newLeft + 'px';
                container.style.top = newTop + 'px';
            }
        });
        
        document.addEventListener('touchmove', function(e) {
            if (!containerDrag.active) return;
            
            const touch = e.touches[0];
            const dx = touch.clientX - containerDrag.startX;
            const dy = touch.clientY - containerDrag.startY;
            
            if (containerDrag.isWorldPan) {
                // ä¸–ç•Œå¹³ç§»æ¨¡å¼
                const gameArea = document.getElementById('gameArea');
                const maxOffset = Math.min(gameArea.offsetWidth, gameArea.offsetHeight) / 2;
                
                let newWorldX = containerDrag.startWorldX + dx;
                let newWorldY = containerDrag.startWorldY + dy;
                
                newWorldX = Math.max(-maxOffset, Math.min(maxOffset, newWorldX));
                newWorldY = Math.max(-maxOffset, Math.min(maxOffset, newWorldY));
                
                worldOffset.x = newWorldX;
                worldOffset.y = newWorldY;
                
                updateWorldPosition();
            } else {
                // åŸä¾†çš„æ ¼ç·šå€æ‹–æ›³é‚è¼¯
                const container = document.getElementById('puzzleContainer');
                let newLeft = containerDrag.startLeft + dx;
                let newTop = containerDrag.startTop + dy;
                
                const gameArea = document.getElementById('gameArea');
                const baseMargin = 10;
                
                const borderWidth = (gameArea.offsetWidth - baseMargin * 2) * containerScale;
                const borderHeight = (gameArea.offsetHeight - baseMargin * 2) * containerScale;
                const borderLeft = (gameArea.offsetWidth - borderWidth) / 2;
                const borderTop = (gameArea.offsetHeight - borderHeight) / 2;
                
                const scaledContainerWidth = baseContainerWidth * containerScale;
                const scaledContainerHeight = baseContainerHeight * containerScale;
                const offsetX = (baseContainerWidth - scaledContainerWidth) / 2;
                const offsetY = (baseContainerHeight - scaledContainerHeight) / 2;
                
                const minLeft = borderLeft - offsetX;
                const maxLeft = borderLeft + borderWidth - scaledContainerWidth - offsetX;
                const minTop = borderTop - offsetY;
                const maxTop = borderTop + borderHeight - scaledContainerHeight - offsetY;
                
                newLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
                newTop = Math.max(minTop, Math.min(maxTop, newTop));
                
                container.style.left = newLeft + 'px';
                container.style.top = newTop + 'px';
            }
        }, {passive: true});
        
        document.addEventListener('mouseup', function() {
            containerDrag.active = false;
            if (drawerResize.active) {
                drawerResize.active = false;
                document.getElementById('drawerResizeHandle').classList.remove('active');
            }
        });
        
        document.addEventListener('touchend', function() {
            containerDrag.active = false;
            if (drawerResize.active) {
                drawerResize.active = false;
                document.getElementById('drawerResizeHandle').classList.remove('active');
            }
        });
        
        // åˆå§‹åŒ–æ‹–æ›³äº‹ä»¶
        initContainerDrag();
        
        // Drawer å¤§å°èª¿æ•´åŠŸèƒ½
        function initDrawerResize() {
            const handle = document.getElementById('drawerResizeHandle');
            const drawer = document.getElementById('puzzleDrawer');
            const gameArea = document.getElementById('gameArea');
            
            handle.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation();
                drawerResize.active = true;
                handle.classList.add('active');
                
                if (drawerPosition === 'top' || drawerPosition === 'bottom') {
                    drawerResize.startPos = e.clientY;
                    drawerResize.startSize = drawer.offsetHeight;
                } else {
                    drawerResize.startPos = e.clientX;
                    drawerResize.startSize = drawer.offsetWidth;
                }
            });
            
            handle.addEventListener('touchstart', function(e) {
                e.stopPropagation();
                drawerResize.active = true;
                handle.classList.add('active');
                const touch = e.touches[0];
                
                if (drawerPosition === 'top' || drawerPosition === 'bottom') {
                    drawerResize.startPos = touch.clientY;
                    drawerResize.startSize = drawer.offsetHeight;
                } else {
                    drawerResize.startPos = touch.clientX;
                    drawerResize.startSize = drawer.offsetWidth;
                }
            }, {passive: true});
        }
        
        document.addEventListener('mousemove', function(e) {
            if (!drawerResize.active) return;
            
            const gameArea = document.getElementById('gameArea');
            const drawer = document.getElementById('puzzleDrawer');
            let newSize;
            
            if (drawerPosition === 'bottom') {
                newSize = drawerResize.startSize - (e.clientY - drawerResize.startPos);
            } else if (drawerPosition === 'top') {
                newSize = drawerResize.startSize + (e.clientY - drawerResize.startPos);
            } else if (drawerPosition === 'right') {
                newSize = drawerResize.startSize - (e.clientX - drawerResize.startPos);
            } else if (drawerPosition === 'left') {
                newSize = drawerResize.startSize + (e.clientX - drawerResize.startPos);
            }
            
            // é™åˆ¶ç¯„åœï¼šæœ€å°å®¹ç´ä¸€å€‹æ‹¼åœ–ï¼Œæœ€å¤§ 1/2 è¢å¹•
            const isVertical = (drawerPosition === 'top' || drawerPosition === 'bottom');
            const maxDimension = isVertical ? gameArea.offsetHeight : gameArea.offsetWidth;
            const minSize = isVertical ? (pieceHeight || 100) : (pieceWidth || 100);
            const maxSize = maxDimension / 2;
            
            newSize = Math.max(minSize, Math.min(maxSize, newSize));
            drawerSize = newSize;
            
            if (isVertical) {
                drawer.style.height = newSize + 'px';
            } else {
                drawer.style.width = newSize + 'px';
            }
            
            // æ›´æ–° resize handle ä½ç½®
            updateResizeHandlePosition();
            
            // æ›´æ–°æ‹¼åœ–å€ä½ç½®
            if (originalImage && isPlaying) {
                const container = document.getElementById('puzzleContainer');
                const w = parseFloat(container.style.width);
                const h = parseFloat(container.style.height);
                const newPos = calculateContainerPosition(w, h);
                container.style.left = newPos.left + 'px';
                container.style.top = newPos.top + 'px';
                containerOriginalPos = { left: newPos.left, top: newPos.top };
            }
        });
        
        document.addEventListener('touchmove', function(e) {
            if (!drawerResize.active) return;
            
            const touch = e.touches[0];
            const gameArea = document.getElementById('gameArea');
            const drawer = document.getElementById('puzzleDrawer');
            let newSize;
            
            if (drawerPosition === 'bottom') {
                newSize = drawerResize.startSize - (touch.clientY - drawerResize.startPos);
            } else if (drawerPosition === 'top') {
                newSize = drawerResize.startSize + (touch.clientY - drawerResize.startPos);
            } else if (drawerPosition === 'right') {
                newSize = drawerResize.startSize - (touch.clientX - drawerResize.startPos);
            } else if (drawerPosition === 'left') {
                newSize = drawerResize.startSize + (touch.clientX - drawerResize.startPos);
            }
            
            // é™åˆ¶ç¯„åœï¼šæœ€å°å®¹ç´ä¸€å€‹æ‹¼åœ–ï¼Œæœ€å¤§ 1/2 è¢å¹•
            const isVertical2 = (drawerPosition === 'top' || drawerPosition === 'bottom');
            const maxDimension2 = isVertical2 ? gameArea.offsetHeight : gameArea.offsetWidth;
            const minSize2 = isVertical2 ? (pieceHeight || 100) : (pieceWidth || 100);
            const maxSize2 = maxDimension2 / 2;
            
            newSize = Math.max(minSize2, Math.min(maxSize2, newSize));
            drawerSize = newSize;
            
            if (isVertical2) {
                drawer.style.height = newSize + 'px';
            } else {
                drawer.style.width = newSize + 'px';
            }
            
            // æ›´æ–° resize handle ä½ç½®
            updateResizeHandlePosition();
            
            // æ›´æ–°æ‹¼åœ–å€ä½ç½®
            if (originalImage && isPlaying) {
                const container = document.getElementById('puzzleContainer');
                const w = parseFloat(container.style.width);
                const h = parseFloat(container.style.height);
                const newPos = calculateContainerPosition(w, h);
                container.style.left = newPos.left + 'px';
                container.style.top = newPos.top + 'px';
                containerOriginalPos = { left: newPos.left, top: newPos.top };
            }
        }, {passive: true});
        
        // åˆå§‹åŒ– drawer resize
        initDrawerResize();
        
        // å…©æŒ‡ç¸®æ”¾åŠŸèƒ½
        function getDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function initPinchZoom() {
            const gameArea = document.getElementById('gameArea');
            
            gameArea.addEventListener('touchstart', function(e) {
                if (!isPlaying) return;
                if (e.touches.length === 2) {
                    // æª¢æŸ¥å…©æ ¹æ‰‹æŒ‡æ˜¯å¦éƒ½åœ¨ gameArea å…§ï¼ˆæ’é™¤ drawer å€åŸŸï¼‰
                    const gameAreaRect = gameArea.getBoundingClientRect();
                    const drawer = document.getElementById('puzzleDrawer');
                    const drawerRect = drawer && drawer.style.display !== 'none' ? drawer.getBoundingClientRect() : null;
                    
                    let bothInGameArea = true;
                    for (let i = 0; i < 2; i++) {
                        const touch = e.touches[i];
                        const x = touch.clientX;
                        const y = touch.clientY;
                        
                        // å¿…é ˆåœ¨ gameArea ç¯„åœå…§
                        if (x < gameAreaRect.left || x > gameAreaRect.right ||
                            y < gameAreaRect.top || y > gameAreaRect.bottom) {
                            bothInGameArea = false;
                            break;
                        }
                        
                        // æ‰˜ç›¤æ¨¡å¼ï¼šæ’é™¤ drawer å€åŸŸ
                        if (trayMode && drawerRect) {
                            if (x >= drawerRect.left && x <= drawerRect.right &&
                                y >= drawerRect.top && y <= drawerRect.bottom) {
                                bothInGameArea = false;
                                break;
                            }
                        }
                    }
                    
                    if (!bothInGameArea) return;
                    
                    pinchZoom.active = true;
                    pinchZoom.startDistance = getDistance(e.touches);
                    pinchZoom.startScale = containerScale;
                    e.preventDefault();
                }
            }, {passive: false});
            
            gameArea.addEventListener('touchmove', function(e) {
                if (!pinchZoom.active || e.touches.length !== 2) return;
                
                const currentDistance = getDistance(e.touches);
                const scale = (currentDistance / pinchZoom.startDistance) * pinchZoom.startScale;
                
                // é™åˆ¶ç¸®æ”¾ç¯„åœï¼š0.5 ~ 2.0
                const newScale = Math.max(0.5, Math.min(2.0, scale));
                const scaleRatio = newScale / containerScale;
                containerScale = newScale;
                
                const container = document.getElementById('puzzleContainer');
                container.style.transform = `scale(${containerScale})`;
                
                // æ•£è½æ¨¡å¼ï¼šåŒæ™‚ç¸®æ”¾æœªæ”¾ç½®çš„æ‹¼åœ–å’Œé‚Šæ¡†
                if (!trayMode) {
                    updateScatterPiecesScale(scaleRatio);
                    updateScatterBorder();
                }
                
                e.preventDefault();
            }, {passive: false});
            
            gameArea.addEventListener('touchend', function(e) {
                if (e.touches.length < 2) {
                    pinchZoom.active = false;
                }
            });
        }
        
        initPinchZoom();
        
        // æ»‘é¼ æ»¾è¼ªç¸®æ”¾ï¼ˆæ•£è½æ¨¡å¼ï¼‰
        function initWheelZoom() {
            const gameArea = document.getElementById('gameArea');
            
            gameArea.addEventListener('wheel', function(e) {
                // åªåœ¨æ•£è½æ¨¡å¼ä¸”éŠæˆ²é€²è¡Œä¸­æ‰æ”¯æ´æ»¾è¼ªç¸®æ”¾
                if (trayMode || !isPlaying) return;
                
                e.preventDefault();
                
                // æ ¹æ“šæ»¾è¼ªæ–¹å‘æ±ºå®šç¸®æ”¾
                const delta = e.deltaY > 0 ? -0.05 : 0.05; // å‘ä¸‹æ»¾ = ç¸®å°ï¼Œå‘ä¸Šæ»¾ = æ”¾å¤§
                const newScale = Math.max(0.5, Math.min(2.0, containerScale + delta));
                
                if (newScale === containerScale) return;
                
                const scaleRatio = newScale / containerScale;
                containerScale = newScale;
                
                const container = document.getElementById('puzzleContainer');
                container.style.transform = `scale(${containerScale})`;
                
                // åŒæ™‚ç¸®æ”¾æœªæ”¾ç½®çš„æ‹¼åœ–å’Œé‚Šæ¡†
                updateScatterPiecesScale(scaleRatio);
                updateScatterBorder();
            }, {passive: false});
        }
        
        initWheelZoom();

        // æ‹¼åœ–è·¯å¾‘ç”Ÿæˆ - æ¨™æº–ç‰ˆæœ¬
        function generateCurvedPath(width, height, edges) {
            const { top, right, bottom, left } = edges;
            const tabHeight = Math.min(width, height) * 0.15;
            const tabWidth = Math.min(width, height) * 0.5;

            let path = `M ${tabHeight},${tabHeight}`;
            
            // Top
            if (top === 'tab') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${(width-tabWidth)/2}`;
            else if (top === 'slot') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${(width-tabWidth)/2}`;
            else path += ` h ${width}`;
            
            // Right
            if (right === 'tab') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else if (right === 'slot') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else path += ` v ${height}`;
            
            // Bottom
            if (bottom === 'tab') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${(width-tabWidth)/2}`;
            else if (bottom === 'slot') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${(width-tabWidth)/2}`;
            else path += ` h -${width}`;
            
            // Left
            if (left === 'tab') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else if (left === 'slot') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else path += ` v -${height}`;
            
            return path + ' Z';
        }

        function generateEdges(rows, cols) {
            const p = Array(rows).fill().map(() => Array(cols).fill().map(() => ({top:null,right:null,bottom:null,left:null})));
            for (let i = 0; i < rows-1; i++) for (let j = 0; j < cols; j++) { const t = Math.random() < 0.5; p[i][j].bottom = t ? 'tab' : 'slot'; p[i+1][j].top = t ? 'slot' : 'tab'; }
            for (let i = 0; i < rows; i++) for (let j = 0; j < cols-1; j++) { const t = Math.random() < 0.5; p[i][j].right = t ? 'tab' : 'slot'; p[i][j+1].left = t ? 'slot' : 'tab'; }
            return p;
        }

        // åœ–ç‰‡è¼‰å…¥
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(ev) { loadImage(ev.target.result); };
                reader.readAsDataURL(file);
            }
            e.target.value = '';
        });

        function loadImage(src) {
            originalImage = new Image();
            originalImage.onload = function() {
                startGame();
            };
            originalImage.src = src;
        }

        // è¨ˆç®—æ‹¼åœ–å€å¤§å°ï¼ˆåªåœ¨é–‹å§‹éŠæˆ²æ™‚èª¿ç”¨ä¸€æ¬¡ï¼‰
        // ä½¿ç”¨æœ€å°å¯ç”¨ç©ºé–“ï¼Œç¢ºä¿ drawer åœ¨ä»»ä½•ä½ç½®éƒ½ä¸æœƒè¶…å‡º
        function calculateContainerSize() {
            const gameArea = document.querySelector('.game-area');
            const totalWidth = gameArea.offsetWidth;
            const totalHeight = gameArea.offsetHeight;
            
            const tabMargin = 10; // é ç•™ tab çªå‡ºç©ºé–“ï¼ˆæœ€å°åŒ–ï¼‰
            
            // åŒæ™‚é ç•™ä¸Šä¸‹å’Œå·¦å³çš„ drawer ç©ºé–“ï¼Œå–æœ€å°å¯ç”¨å€åŸŸ
            // é€™æ¨£ç„¡è«– drawer åœ¨å“ªå€‹æ–¹å‘ï¼Œæ‹¼åœ–å€éƒ½èƒ½å®Œæ•´é¡¯ç¤º
            const availableWidth = totalWidth - drawerSize - tabMargin * 2;
            const availableHeight = totalHeight - drawerSize - tabMargin * 2;
            
            // æ ¹æ“šåœ–ç‰‡æ¯”ä¾‹è¨ˆç®—æ‹¼åœ–å€å¤§å°
            const ratio = originalImage.width / originalImage.height;
            let w, h;
            if (availableWidth / availableHeight > ratio) {
                h = availableHeight;
                w = h * ratio;
            } else {
                w = availableWidth;
                h = w / ratio;
            }
            
            return { width: w, height: h };
        }
        
        // è¨ˆç®—æ‹¼åœ–å€ä½ç½®ï¼ˆåˆ‡æ›æŠ½å±œæ–¹å‘æ™‚èª¿ç”¨ï¼‰
        function calculateContainerPosition(containerWidth, containerHeight) {
            const gameArea = document.querySelector('.game-area');
            const totalWidth = gameArea.offsetWidth;
            const totalHeight = gameArea.offsetHeight;
            
            // è¨ˆç®—å¯ç”¨å€åŸŸçš„é‚Šç•Œ
            let left = 0, top = 0;
            let right = totalWidth;
            let bottom = totalHeight;
            
            // æ ¹æ“šæŠ½å±œä½ç½®èª¿æ•´é‚Šç•Œ
            if (drawerPosition === 'left') left = drawerSize;
            else if (drawerPosition === 'right') right = totalWidth - drawerSize;
            else if (drawerPosition === 'top') top = drawerSize;
            else if (drawerPosition === 'bottom') bottom = totalHeight - drawerSize;
            
            const availableWidth = right - left;
            const availableHeight = bottom - top;
            
            // è¨ˆç®—ç½®ä¸­ä½ç½®
            const centerX = left + (availableWidth - containerWidth) / 2;
            const centerY = top + (availableHeight - containerHeight) / 2;
            
            return { left: centerX, top: centerY };
        }

        // å‰µå»ºæ‹¼åœ–å¡Š - åœ–ç‰‡å…§ç¸®ï¼Œè®“é‚Šç·£æ‹¼åœ–æœ‰å»¶ä¼¸ç©ºé–“
        function createPuzzlePiece(i, j, pw, ph, size, ed) {
            const piece = document.createElement('div');
            piece.className = 'puzzle-piece';
            const tab = Math.min(pw, ph) * 0.15;
            
            // é‚Šç·£æ‹¼åœ–ä½¿ç”¨å»¶ä¼¸è·¯å¾‘
            const path = generatePiecePath(pw, ph, ed);
            
            const actualW = pw + 2*tab;
            const actualH = ph + 2*tab;
            
            // åœ–ç‰‡å…§ç¸®ï¼šè®“åœ–ç‰‡å¾ tab ä½ç½®é–‹å§‹ï¼Œå››å‘¨ç•™å‡º tab ç©ºé–“
            // èƒŒæ™¯åœ–å¤§å°ä¸è®Šï¼Œä½†ä½ç½®å¾€å…§åç§» tab
            const bgX = -(j * pw) + tab;
            const bgY = -(i * ph) + tab;
            
            piece.style.cssText = `width:${actualW}px; height:${actualH}px; background-image:url(${originalImage.src}); background-size:${size.width}px ${size.height}px; background-position:${bgX}px ${bgY}px; background-repeat:no-repeat; clip-path:path('${path}'); -webkit-clip-path:path('${path}'); position:absolute; transform:translate(-${tab}px,-${tab}px);`;
            piece.correctX = j * pw;
            piece.correctY = i * ph;
            piece.pieceNumber = i * cols + j + 1;
            piece.isPlaced = false;
            piece.edges = ed;  // å„²å­˜é‚Šç·£è³‡è¨Šä¾› drawer é‚Šæ¡†ä½¿ç”¨
            return piece;
        }
        
        // æ‹¼åœ–å¡Šè·¯å¾‘ - å¹³ç›´é‚Šå»¶ä¼¸åˆ° tab ä½ç½®
        function generatePiecePath(width, height, edges) {
            const { top, right, bottom, left } = edges;
            const tabHeight = Math.min(width, height) * 0.15;
            const tabWidth = Math.min(width, height) * 0.5;

            let path = `M ${tabHeight},${tabHeight}`;
            
            // Top
            if (top === 'tab') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${(width-tabWidth)/2}`;
            else if (top === 'slot') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${(width-tabWidth)/2}`;
            else path += ` v -${tabHeight} h ${width} v ${tabHeight}`;
            
            // Right
            if (right === 'tab') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else if (right === 'slot') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else path += ` h ${tabHeight} v ${height} h -${tabHeight}`;
            
            // Bottom
            if (bottom === 'tab') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${(width-tabWidth)/2}`;
            else if (bottom === 'slot') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${(width-tabWidth)/2}`;
            else path += ` v ${tabHeight} h -${width} v -${tabHeight}`;
            
            // Left
            if (left === 'tab') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else if (left === 'slot') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else path += ` h -${tabHeight} v -${height} h ${tabHeight}`;
            
            return path + ' Z';
        }

        // è¼ªå»“ç·š - ä½¿ç”¨èˆ‡æ‹¼åœ–å¡Šç›¸åŒçš„è·¯å¾‘
        function createPieceOutline(i, j, pw, ph, size, ed) {
            const outline = document.createElement('div');
            outline.className = 'piece-outline';
            const tab = Math.min(pw, ph) * 0.15;
            // æ ¼ç·šä½¿ç”¨ generateCurvedPathï¼ˆä¸å»¶ä¼¸å¹³ç›´é‚Šï¼‰
            const path = generateCurvedPath(pw, ph, ed);
            
            const svgW = pw + 2*tab;
            const svgH = ph + 2*tab;
            
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", svgW); 
            svg.setAttribute("height", svgH);
            const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
            p.setAttribute("d", path); 
            p.setAttribute("fill", "none"); 
            p.setAttribute("stroke", "rgba(255,255,255,0.35)"); 
            p.setAttribute("stroke-width", "1");
            p.setAttribute("stroke-linejoin", "round");
            p.setAttribute("stroke-linecap", "round");
            svg.appendChild(p); 
            outline.appendChild(svg);
            outline.style.cssText = `position:absolute; left:${j*pw}px; top:${i*ph}px; pointer-events:none; z-index:0; transform:translate(-${tab}px,-${tab}px);`;
            if (showHint) { 
                const n = document.createElement('div'); 
                n.className = 'piece-number'; 
                n.textContent = i*cols+j+1; 
                outline.appendChild(n); 
            }
            return outline;
        }

        function createDrawerItem(piece, pw, ph, tab) {
            const wrapper = document.createElement('div');
            wrapper.className = 'drawer-piece-wrapper';
            const actualW = pw + 2 * tab;
            const actualH = ph + 2 * tab;
            // wrapper ç”¨ padding ä¾†å®¹ç´ translate å¾Œçš„æ‹¼åœ–
            wrapper.style.cssText = `width:${pw}px; height:${ph}px; padding:${tab}px; position:relative; box-sizing:content-box;`;
            
            // é‡æ–°ç”Ÿæˆæ­£ç¢ºå¤§å°çš„æ‹¼åœ–æ¨£å¼ï¼ˆä¸è¦è¤‡è£½ piece.style.cssTextï¼‰
            const div = document.createElement('div');
            const pieceRow = Math.floor((piece.pieceNumber - 1) / cols);
            const pieceCol = (piece.pieceNumber - 1) % cols;
            const size = { width: pw * cols, height: ph * rows };
            const bgX = -(pieceCol * pw) + tab;
            const bgY = -(pieceRow * ph) + tab;
            const ed = piece.edges;
            const path = generatePiecePath(pw, ph, ed);
            
            div.style.cssText = `
                width: ${actualW}px;
                height: ${actualH}px;
                background-image: url(${originalImage.src});
                background-size: ${size.width}px ${size.height}px;
                background-position: ${bgX}px ${bgY}px;
                background-repeat: no-repeat;
                clip-path: path('${path}');
                -webkit-clip-path: path('${path}');
                position: relative;
                transform: translate(-${tab}px, -${tab}px);
                transform-origin: ${actualW/2}px ${actualH/2}px;
            `;
            wrapper.appendChild(div);
            
            // åŠ å…¥ SVG é‚Šæ¡†ç·šï¼ˆä½¿ç”¨ç›¸åŒçš„ pw, phï¼‰
            const borderPath = generateCurvedPath(pw, ph, ed);
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', actualW);
            svg.setAttribute('height', actualH);
            svg.style.cssText = 'position:absolute; top:0; left:0; pointer-events:none; transform-origin: center center;';
            svg.innerHTML = `<path d="${borderPath}" fill="none" stroke="#000" stroke-width="1"/>`;
            wrapper.appendChild(svg);
            
            // éš¨æ©Ÿæ—‹è½‰ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰- 0~359 ä»»æ„è§’åº¦
            const randomRotation = enableRotation ? Math.floor(Math.random() * 360) : 0;
            wrapper.currentRotation = randomRotation;
            piece.currentRotation = randomRotation;
            if (randomRotation !== 0) {
                div.style.transform = `translate(-${tab}px,-${tab}px) rotate(${randomRotation}deg)`;
                svg.style.transform = `rotate(${randomRotation}deg)`;
            }
            
            // å„²å­˜è³‡è¨Š
            wrapper.pieceNumber = piece.pieceNumber;
            wrapper.pieceRef = piece;
            wrapper.pieceDiv = div;
            wrapper.pieceSvg = svg;
            wrapper.tab = tab;
            wrapper.pw = pw;
            wrapper.ph = ph;
            wrapper.addEventListener('mousedown', startDragFromDrawer);
            wrapper.addEventListener('touchstart', startTouchFromDrawer, {passive: true});
            return wrapper;
        }
        
        // é¡¯ç¤ºæŠ½å±œæ‹¼åœ–ç·¨è™Ÿæç¤º
        function showDrawerHint(wrapper) {
            if (!showHint) return;
            if (!wrapper || wrapper.classList.contains('placed')) return;
            
            // ç§»é™¤å·²å­˜åœ¨çš„æç¤º
            const existing = wrapper.querySelector('.drawer-hint');
            if (existing) existing.remove();
            
            // å‰µå»ºæç¤º
            const hint = document.createElement('div');
            hint.className = 'drawer-hint';
            hint.textContent = wrapper.pieceNumber;
            wrapper.appendChild(hint);
            
            // 3 ç§’å¾Œç§»é™¤
            setTimeout(() => hint.remove(), 3000);
        }

        // é–‹å§‹éŠæˆ²
        function startGame(skipConfirm = false, isRestoring = false) {
            if (!originalImage) { alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡ï¼'); return; }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰é€²è¡Œä¸­çš„éŠæˆ²
            if (!skipConfirm && isPlaying && drawerPieces.some(dp => dp.isPlaced)) {
                showConfirmNewGameDialog();
                return;
            }
            
            // æ¸…é™¤èˆŠå­˜æª”ï¼ˆé–‹å§‹æ–°éŠæˆ²ï¼Œæ¢å¾©æ™‚ä¸æ¸…é™¤ï¼‰
            if (!isRestoring) {
                clearSave();
            }
            stopAutoSave();
            
            // é‡ç½®ä¸–ç•Œå¹³ç§»
            resetWorldOffset();
            
            // é¡¯ç¤ºé€²åº¦
            const progressOverlay = document.createElement('div');
            progressOverlay.className = 'progress-overlay';
            progressOverlay.innerHTML = `
                <div class="progress-text" id="progressText">æº–å‚™ä¸­...</div>
                <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
            `;
            document.body.appendChild(progressOverlay);
            
            // ä½¿ç”¨ async è®“ UI æœ‰æ©Ÿæœƒæ›´æ–°
            const updateProgress = (percent, text) => {
                return new Promise(resolve => {
                    document.getElementById('progressFill').style.width = percent + '%';
                    if (text) document.getElementById('progressText').textContent = text;
                    requestAnimationFrame(() => requestAnimationFrame(resolve));
                });
            };
            
            (async () => {
                await updateProgress(10, 'åˆå§‹åŒ–...');
                
                const container = document.getElementById('puzzleContainer');
                const drawer = document.getElementById('puzzleDrawer');
                const handle = document.getElementById('drawerResizeHandle');
                const gameArea = document.getElementById('gameArea');
                container.innerHTML = '';
                drawer.innerHTML = '';
                
                // æ¸…é™¤æ•£è½æ¨¡å¼çš„æ‹¼åœ–ï¼ˆåœ¨ gameArea ä¸­çš„æ‰€æœ‰æ•£è½æ‹¼åœ–ç›¸é—œå…ƒç´ ï¼‰
                const scatterPieces = gameArea.querySelectorAll('.scatter-piece-wrapper');
                console.log('æ¸…é™¤æ•£è½æ‹¼åœ–æ•¸é‡:', scatterPieces.length);
                scatterPieces.forEach(el => {
                    el.parentNode.removeChild(el);
                });
                
                // æ¸…é™¤æ•£è½æ¨¡å¼é‚Šç•Œç·š
                const scatterBorder = document.getElementById('scatterBorder');
                if (scatterBorder) {
                    scatterBorder.parentNode.removeChild(scatterBorder);
                }
                
                pieces = []; drawerPieces = []; isPlaying = true;
                drawerPieceZIndex = 1; // é‡ç½® z-index è¨ˆæ•¸å™¨
                
                // é‡ç½®æ•£è½æ¨¡å¼ç‹€æ…‹ï¼ˆé–‹å§‹æ–°éŠæˆ²æ™‚å›åˆ°æ‰˜ç›¤æ¨¡å¼ï¼‰
                scatterMode = false;
                const scatterBtn = document.getElementById('scatterBtn');
                if (scatterBtn) scatterBtn.classList.remove('active');
                
                // è®€å–æ¨¡å¼è¨­å®š
                trayMode = document.getElementById('toggleTray').checked;
                
                // æ‰˜ç›¤æ¨¡å¼ï¼šé¡¯ç¤º drawer å’Œç›¸é—œæ§åˆ¶
                // æ•£è½æ¨¡å¼ï¼šéš±è— drawer å’Œç›¸é—œæ§åˆ¶
                if (trayMode) {
                    // è¨­å®š drawer classï¼ˆåŒ…å«æ–¹å‘å’Œæ•£äº‚æ¨¡å¼ï¼‰
                    drawer.className = 'puzzle-drawer drawer-' + drawerPosition + (scatterMode ? ' scatter-mode' : '');
                    drawer.style.display = '';
                    
                    // æ›´æ–°æ•£äº‚æŒ‰éˆ•ç‹€æ…‹
                    const scatterBtn = document.getElementById('scatterBtn');
                    if (scatterBtn) scatterBtn.classList.toggle('active', scatterMode);
                    
                    // æ›´æ–° drawer æ–¹å‘æŒ‰éˆ•çš„ active ç‹€æ…‹
                    document.querySelectorAll('.drawer-btn[onclick^="setDrawerPosition"]').forEach(b => {
                        const pos = b.getAttribute('onclick').match(/'(\w+)'/)[1];
                        b.classList.toggle('active', pos === drawerPosition);
                    });
                    
                    // è¨­å®š drawer å¤§å°
                    if (drawerPosition === 'top' || drawerPosition === 'bottom') {
                        drawer.style.width = '';
                        drawer.style.height = drawerSize + 'px';
                    } else if (drawerPosition === 'left' || drawerPosition === 'right') {
                        drawer.style.height = '';
                        drawer.style.width = drawerSize + 'px';
                    }
                    
                    // é¡¯ç¤º drawer ç›¸é—œæ§åˆ¶
                    document.querySelector('.drawer-controls').style.display = '';
                    document.getElementById('drawerCount').style.display = '';
                    handle.classList.add('visible');
                } else {
                    // æ•£è½æ¨¡å¼ï¼šéš±è— drawer å’Œç›¸é—œæ§åˆ¶
                    drawer.style.display = 'none';
                    document.querySelector('.drawer-controls').style.display = 'none';
                    document.getElementById('drawerCount').style.display = 'none';
                    handle.classList.remove('visible');
                }

                const size = trayMode ? calculateContainerSize() : calculateContainerSizeForScatter();
                const count = parseInt(document.getElementById('pieceCount').value);
                rows = cols = Math.sqrt(count);
                
                const pw = size.width / cols;
                const ph = size.height / rows;
                const tab = Math.min(pw, ph) * 0.15;
                
                // å„²å­˜æ‹¼åœ–å¤§å°ï¼ˆå« tab å’Œ paddingï¼‰ä¾› drawer resize ä½¿ç”¨
                pieceWidth = pw + 2 * tab + 20;  // åŠ ä¸Š padding/margin
                pieceHeight = ph + 2 * tab + 20;
                
                const pos = trayMode ? calculateContainerPosition(size.width, size.height) : calculateContainerPositionForScatter(size.width, size.height);

                container.style.width = size.width + 'px';
                container.style.height = size.height + 'px';
                container.style.left = pos.left + 'px';
                container.style.top = pos.top + 'px';
                container.style.transform = trayMode ? 'scale(0.85)' : 'scale(1)';
                container.style.transformOrigin = 'center center';
                
                // å„²å­˜åŸå§‹å®¹å™¨å¤§å°ä¾›ç¸®æ”¾ä½¿ç”¨
                baseContainerWidth = size.width;
                baseContainerHeight = size.height;
                containerScale = trayMode ? 0.85 : 1;
                
                // è¨˜éŒ„åŸå§‹ä½ç½®ï¼Œè¨­å®šæ‹–æ›³ç¯„åœï¼ˆåŠå€‹æ‹¼åœ–å€å¤§å°ï¼‰
                containerOriginalPos = { left: pos.left, top: pos.top };
                containerDragLimit = { 
                    x: (cols / 2) * pw,  // å¯å·¦å³ç§»å‹•åŠå€‹æ‹¼åœ–å€
                    y: (rows / 2) * ph   // å¯ä¸Šä¸‹ç§»å‹•åŠå€‹æ‹¼åœ–å€
                };
                
                // åˆå§‹åŒ– resize handle ä½ç½®ï¼ˆç·Šè²¼ drawer é‚Šç·£ï¼‰- åªåœ¨æ‰˜ç›¤æ¨¡å¼
                if (trayMode) {
                    // é¡¯ç¤º drawer ç›¸é—œå…ƒä»¶
                    drawer.style.display = '';
                    document.querySelector('.drawer-controls').style.display = '';
                    document.getElementById('drawerCount').style.display = '';
                    handle.style.display = '';
                    
                    if (drawerPosition === 'bottom') {
                        handle.className = 'drawer-resize-handle horizontal visible';
                        handle.style.top = (gameArea.offsetHeight - drawerSize - 20) + 'px';
                        handle.style.left = '0';
                        handle.style.right = '0';
                        handle.style.bottom = '';
                    } else if (drawerPosition === 'top') {
                        handle.className = 'drawer-resize-handle horizontal visible';
                        handle.style.top = drawerSize + 'px';
                        handle.style.left = '0';
                        handle.style.right = '0';
                        handle.style.bottom = '';
                    } else if (drawerPosition === 'left') {
                        handle.className = 'drawer-resize-handle vertical visible';
                        handle.style.left = drawerSize + 'px';
                        handle.style.right = '';
                        handle.style.top = '0';
                        handle.style.bottom = '0';
                    } else if (drawerPosition === 'right') {
                        handle.className = 'drawer-resize-handle vertical visible';
                        handle.style.right = (drawerSize + 20) + 'px';
                        handle.style.left = '';
                        handle.style.top = '0';
                        handle.style.bottom = '0';
                    }
                } else {
                    // æ•£è½æ¨¡å¼ï¼šéš±è— drawer ç›¸é—œå…ƒä»¶
                    drawer.style.display = 'none';
                    document.querySelector('.drawer-controls').style.display = 'none';
                    document.getElementById('drawerCount').style.display = 'none';
                    handle.style.display = 'none';
                }

                const outlines = document.createElement('div');
                outlines.className = 'outlines-container';
                outlines.style.cssText = 'position:absolute;z-index:0;left:0;top:0;';
                container.appendChild(outlines);

                edges = generateEdges(rows, cols);
                
                await updateProgress(30, 'ç¹ªè£½æ ¼ç·š...');
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        outlines.appendChild(createPieceOutline(i, j, pw, ph, size, edges[i][j]));
                    }
                }

                await updateProgress(50, 'åˆ‡å‰²æ‹¼åœ–...');

                let temp = [];
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        temp.push(createPuzzlePiece(i, j, pw, ph, size, edges[i][j]));
                    }
                    await updateProgress(50 + Math.floor((i / rows) * 30), 'åˆ‡å‰²æ‹¼åœ–...');
                }
                
                for (let i = temp.length - 1; i > 0; i--) { 
                    const j = Math.floor(Math.random() * (i + 1)); 
                    [temp[i], temp[j]] = [temp[j], temp[i]]; 
                }
                
                await updateProgress(85, 'æ‰“äº‚é †åº...');
                
                temp.forEach(piece => {
                    if (trayMode) {
                        // æ‰˜ç›¤æ¨¡å¼ï¼šæ”¾å…¥ drawer
                        const item = createDrawerItem(piece, pw, ph, tab);
                        drawer.appendChild(item);
                        drawerPieces.push({piece, drawerItem: item, isPlaced: false});
                    } else {
                        // æ•£è½æ¨¡å¼ï¼šå‰µå»ºæ•£è½æ‹¼åœ–é …ç›®ä¸¦æ”¾åˆ° worldContainer
                        const item = createScatterItem(piece, pw, ph, tab);
                        document.getElementById('worldContainer').appendChild(item);
                        drawerPieces.push({piece, drawerItem: item, isPlaced: false});
                    }
                    pieces.push(piece);
                });
                
                // æ‰˜ç›¤æ¨¡å¼ + æ•£äº‚æ¨¡å¼ï¼šä½¿ç”¨åˆ†æ•£æ’åˆ—
                if (trayMode && scatterMode) {
                    repositionScatteredPieces();
                }
                
                // æ•£è½æ¨¡å¼ï¼šå°‡æ‹¼åœ–æ•£è½åœ¨æ ¼ç·šå€å‘¨åœï¼Œé¡¯ç¤ºé‚Šç•Œç·šï¼ˆæ¢å¾©æ™‚è·³ééš¨æ©Ÿåˆ†ä½ˆï¼‰
                if (!trayMode) {
                    showScatterBorder();
                    if (!isRestoring) {
                        scatterPiecesAroundContainer();
                    }
                }
                
                updateDrawerCount();
                
                // å•Ÿå‹•è‡ªå‹•å­˜æª”
                startAutoSave();
                
                await updateProgress(100, 'å®Œæˆï¼');
                setTimeout(() => progressOverlay.remove(), 300);
            })();
        }
        
        // è¨ˆç®—æ•£è½æ¨¡å¼çš„å®¹å™¨å¤§å°ï¼ˆæ ¼ç·šå€ä½” 66%ï¼‰
        function calculateContainerSizeForScatter() {
            const gameArea = document.querySelector('.game-area');
            const totalWidth = gameArea.offsetWidth;
            const totalHeight = gameArea.offsetHeight;
            
            // æ ¼ç·šå€ä½” 66%ï¼Œæ‰€ä»¥å¯ç”¨å€åŸŸæ˜¯ 66%
            const availableWidth = totalWidth * 0.66;
            const availableHeight = totalHeight * 0.66;
            
            // æ ¹æ“šåœ–ç‰‡æ¯”ä¾‹è¨ˆç®—æ‹¼åœ–å€å¤§å°
            const ratio = originalImage.width / originalImage.height;
            let w, h;
            if (availableWidth / availableHeight > ratio) {
                h = availableHeight;
                w = h * ratio;
            } else {
                w = availableWidth;
                h = w / ratio;
            }
            
            return { width: w, height: h };
        }
        
        // è¨ˆç®—æ•£è½æ¨¡å¼çš„å®¹å™¨ä½ç½®ï¼ˆç½®ä¸­ï¼‰
        function calculateContainerPositionForScatter(containerWidth, containerHeight) {
            const gameArea = document.querySelector('.game-area');
            const totalWidth = gameArea.offsetWidth;
            const totalHeight = gameArea.offsetHeight;
            
            return {
                left: (totalWidth - containerWidth) / 2,
                top: (totalHeight - containerHeight) / 2
            };
        }
        
        // å‰µå»ºæ•£è½æ¨¡å¼çš„æ‹¼åœ–é …ç›®ï¼ˆ1:1 æ¯”ä¾‹ï¼Œå¯ç›´æ¥æ‹–å…¥æ ¼ç·šå€ï¼‰
        function createScatterItem(piece, pw, ph, tab) {
            const wrapper = document.createElement('div');
            wrapper.className = 'scatter-piece-wrapper';
            const actualW = pw + 2*tab;
            const actualH = ph + 2*tab;
            wrapper.style.cssText = `
                position: absolute;
                width: ${actualW}px;
                height: ${actualH}px;
                cursor: grab;
                z-index: 1;
            `;
            
            // é‡æ–°ç”Ÿæˆæ­£ç¢ºå¤§å°çš„æ‹¼åœ–æ¨£å¼
            const div = document.createElement('div');
            const pieceRow = Math.floor((piece.pieceNumber - 1) / cols);
            const pieceCol = (piece.pieceNumber - 1) % cols;
            const size = { width: pw * cols, height: ph * rows };
            const bgX = -(pieceCol * pw) + tab;
            const bgY = -(pieceRow * ph) + tab;
            const ed = piece.edges;
            const path = generatePiecePath(pw, ph, ed);
            
            div.style.cssText = `
                width: ${actualW}px;
                height: ${actualH}px;
                background-image: url(${originalImage.src});
                background-size: ${size.width}px ${size.height}px;
                background-position: ${bgX}px ${bgY}px;
                background-repeat: no-repeat;
                clip-path: path('${path}');
                -webkit-clip-path: path('${path}');
                position: absolute;
                left: 0;
                top: 0;
                transform-origin: center center;
            `;
            wrapper.appendChild(div);
            
            // åŠ å…¥ SVG é‚Šæ¡†ç·š
            const borderPath = generateCurvedPath(pw, ph, ed);
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', actualW);
            svg.setAttribute('height', actualH);
            svg.style.cssText = `position:absolute; top:0; left:0; pointer-events:none; transform-origin: center center;`;
            svg.innerHTML = `<path d="${borderPath}" fill="none" stroke="#000" stroke-width="1"/>`;
            wrapper.appendChild(svg);
            
            // éš¨æ©Ÿæ—‹è½‰ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
            const randomRotation = enableRotation ? Math.floor(Math.random() * 360) : 0;
            wrapper.currentRotation = randomRotation;
            piece.currentRotation = randomRotation;
            if (randomRotation !== 0) {
                div.style.transform = `rotate(${randomRotation}deg)`;
                svg.style.transform = `rotate(${randomRotation}deg)`;
            }
            
            // å„²å­˜è³‡è¨Šä¾›æ‹–æ›³ä½¿ç”¨
            wrapper.pieceNumber = piece.pieceNumber;
            wrapper.pieceRef = piece;
            wrapper.pieceDiv = div;
            wrapper.pieceSvg = svg;
            wrapper.tab = tab;
            wrapper.pw = pw;
            wrapper.ph = ph;
            wrapper.addEventListener('mousedown', startDragFromScatter);
            wrapper.addEventListener('touchstart', startTouchFromScatter, {passive: false});
            return wrapper;
        }
        
        // å°‡æ‹¼åœ–æ•£è½åœ¨æ ¼ç·šå€å‘¨åœ
        function scatterPiecesAroundContainer() {
            const container = document.getElementById('puzzleContainer');
            const gameArea = document.getElementById('gameArea');
            
            // è¨ˆç®—æ ¼ç·šå€åœ¨ gameArea ä¸­çš„ä½ç½®
            const containerLeft = parseFloat(container.style.left);
            const containerTop = parseFloat(container.style.top);
            const containerWidth = parseFloat(container.style.width);
            const containerHeight = parseFloat(container.style.height);
            const containerRight = containerLeft + containerWidth;
            const containerBottom = containerTop + containerHeight;
            
            const gameW = gameArea.offsetWidth;
            const gameH = gameArea.offsetHeight;
            const margin = 15; // é‚Šç•Œé–“è·
            const gap = 10; // èˆ‡æ ¼ç·šå€çš„é–“è·
            
            // å®šç¾©å››å€‹æ•£è½å€åŸŸï¼ˆæ ¼ç·šå€å‘¨åœï¼‰
            const regions = [];
            
            // ä¸Šæ–¹å€åŸŸ
            if (containerTop > margin + 50) {
                regions.push({ 
                    x1: margin, x2: gameW - margin, 
                    y1: margin, y2: containerTop - gap 
                });
            }
            // ä¸‹æ–¹å€åŸŸ
            if (gameH - containerBottom > margin + 50) {
                regions.push({ 
                    x1: margin, x2: gameW - margin, 
                    y1: containerBottom + gap, y2: gameH - margin 
                });
            }
            // å·¦æ–¹å€åŸŸ
            if (containerLeft > margin + 50) {
                regions.push({ 
                    x1: margin, x2: containerLeft - gap, 
                    y1: margin, y2: gameH - margin 
                });
            }
            // å³æ–¹å€åŸŸ
            if (gameW - containerRight > margin + 50) {
                regions.push({ 
                    x1: containerRight + gap, x2: gameW - margin, 
                    y1: margin, y2: gameH - margin 
                });
            }
            
            // å¦‚æœæ²’æœ‰è¶³å¤ ç©ºé–“ï¼Œä½¿ç”¨æ•´å€‹å€åŸŸä½†é¿é–‹æ ¼ç·šå€ä¸­å¿ƒ
            if (regions.length === 0) {
                regions.push({ x1: margin, x2: gameW - margin, y1: margin, y2: gameH - margin });
            }
            
            drawerPieces.forEach(dp => {
                if (dp.isPlaced) return;
                
                const wrapper = dp.drawerItem;
                const wrapperW = parseFloat(wrapper.style.width);
                const wrapperH = parseFloat(wrapper.style.height);
                
                // å˜—è©¦æ‰¾åˆ°ä¸èˆ‡æ ¼ç·šå€é‡ç–Šçš„ä½ç½®
                let x, y, attempts = 0;
                do {
                    // éš¨æ©Ÿé¸æ“‡ä¸€å€‹å€åŸŸ
                    const region = regions[Math.floor(Math.random() * regions.length)];
                    
                    // åœ¨å€åŸŸå…§éš¨æ©Ÿä½ç½®
                    const maxX = Math.max(region.x1, region.x2 - wrapperW);
                    const maxY = Math.max(region.y1, region.y2 - wrapperH);
                    x = region.x1 + Math.random() * (maxX - region.x1);
                    y = region.y1 + Math.random() * (maxY - region.y1);
                    
                    attempts++;
                } while (
                    attempts < 10 &&
                    x + wrapperW > containerLeft - gap && x < containerRight + gap &&
                    y + wrapperH > containerTop - gap && y < containerBottom + gap
                );
                
                // ç¢ºä¿åœ¨é‚Šç•Œå…§
                x = Math.max(margin, Math.min(gameW - wrapperW - margin, x));
                y = Math.max(margin, Math.min(gameH - wrapperH - margin, y));
                
                wrapper.style.left = x + 'px';
                wrapper.style.top = y + 'px';
                wrapper.style.zIndex = drawerPieceZIndex++;
            });
        }
        
        // åˆ‡æ›æ•£äº‚æ¨¡å¼ï¼ˆæŒ‰éˆ•ç‰ˆæœ¬ï¼‰
        function toggleScatterBtn() {
            if (!isPlaying || drawerPieces.length === 0) return;
            
            scatterMode = !scatterMode;
            const drawer = document.getElementById('puzzleDrawer');
            const btn = document.getElementById('scatterBtn');
            
            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            btn.classList.toggle('active', scatterMode);
            
            if (scatterMode) {
                drawer.classList.add('scatter-mode');
                repositionScatteredPieces();
            } else {
                drawer.classList.remove('scatter-mode');
                // ç§»é™¤æ‰€æœ‰ä½ç½®æ¨£å¼ï¼Œæ¢å¾© flex æ’åˆ—
                drawerPieces.forEach(dp => {
                    if (!dp.isPlaced) {
                        dp.drawerItem.style.left = '';
                        dp.drawerItem.style.top = '';
                        dp.drawerItem.style.zIndex = '';
                    }
                });
            }
        }
        
        // ç›£è½æ‰˜ç›¤ checkbox è®ŠåŒ– - å³æ™‚åˆ‡æ›
        document.getElementById('toggleTray').addEventListener('change', function() {
            trayMode = this.checked;
            if (isPlaying && drawerPieces.length > 0) {
                switchTrayMode();
            }
        });
        
        // å³æ™‚åˆ‡æ›æ‰˜ç›¤/æ•£è½æ¨¡å¼
        function switchTrayMode() {
            const gameArea = document.getElementById('gameArea');
            const container = document.getElementById('puzzleContainer');
            const drawer = document.getElementById('puzzleDrawer');
            const handle = document.getElementById('drawerResizeHandle');
            
            // è¨ˆç®—æ‹¼åœ–å¤§å°
            const pw = baseContainerWidth / cols;
            const ph = baseContainerHeight / rows;
            const tab = Math.min(pw, ph) * 0.15;
            
            if (trayMode) {
                // åˆ‡æ›åˆ°æ‰˜ç›¤æ¨¡å¼
                // é¡¯ç¤º drawer å’Œæ§åˆ¶
                drawer.style.display = '';
                drawer.className = 'puzzle-drawer drawer-' + drawerPosition + (scatterMode ? ' scatter-mode' : '');
                document.querySelector('.drawer-controls').style.display = '';
                document.getElementById('drawerCount').style.display = '';
                handle.style.display = '';
                handle.classList.add('visible');
                
                // éš±è—é‚Šç•Œç·š
                const border = document.getElementById('scatterBorder');
                if (border) border.style.display = 'none';
                
                // ç§»å‹•æœªæ”¾ç½®çš„æ‹¼åœ–å¾ gameArea åˆ° drawer
                drawerPieces.forEach(dp => {
                    if (!dp.isPlaced) {
                        // ç§»é™¤èˆŠçš„ wrapper
                        if (dp.drawerItem.parentElement) {
                            dp.drawerItem.parentElement.removeChild(dp.drawerItem);
                        }
                        // å‰µå»ºæ–°çš„ drawer item
                        const newItem = createDrawerItem(dp.piece, pw, ph, tab);
                        newItem.currentRotation = dp.piece.currentRotation || 0;
                        if (newItem.currentRotation !== 0) {
                            const div = newItem.pieceDiv;
                            const svg = newItem.pieceSvg;
                            if (div) div.style.transform = `translate(-${tab}px,-${tab}px) rotate(${newItem.currentRotation}deg)`;
                            if (svg) {
                                svg.style.transform = `rotate(${newItem.currentRotation}deg)`;
                                svg.style.transformOrigin = 'center center';
                            }
                        }
                        drawer.appendChild(newItem);
                        dp.drawerItem = newItem;
                    }
                });
                
                // é‡æ–°è¨ˆç®—å®¹å™¨ä½ç½®å’Œå¤§å°
                const size = calculateContainerSize();
                const pos = calculateContainerPosition(size.width, size.height);
                container.style.width = size.width + 'px';
                container.style.height = size.height + 'px';
                container.style.left = pos.left + 'px';
                container.style.top = pos.top + 'px';
                baseContainerWidth = size.width;
                baseContainerHeight = size.height;
                containerOriginalPos = { left: pos.left, top: pos.top };
                
                // é‡å»ºæ ¼ç·š
                rebuildOutlines();
                
                // æ•£äº‚æ¨¡å¼ä¸‹é‡æ–°åˆ†ä½ˆ
                if (scatterMode) {
                    repositionScatteredPieces();
                }
            } else {
                // åˆ‡æ›åˆ°æ•£è½æ¨¡å¼
                // éš±è— drawer å’Œæ§åˆ¶
                drawer.style.display = 'none';
                document.querySelector('.drawer-controls').style.display = 'none';
                document.getElementById('drawerCount').style.display = 'none';
                handle.style.display = 'none';
                handle.classList.remove('visible');
                
                // é‡ç½®ä¸–ç•Œå¹³ç§»
                resetWorldOffset();
                
                // åˆªé™¤èˆŠçš„é‚Šæ¡†ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                const oldBorder = document.getElementById('scatterBorder');
                if (oldBorder) oldBorder.remove();
                
                // é‡æ–°è¨ˆç®—å®¹å™¨ä½ç½®å’Œå¤§å°ï¼ˆ66%ï¼‰
                const size = calculateContainerSizeForScatter();
                const pos = calculateContainerPositionForScatter(size.width, size.height);
                container.style.width = size.width + 'px';
                container.style.height = size.height + 'px';
                container.style.left = pos.left + 'px';
                container.style.top = pos.top + 'px';
                container.style.transform = 'scale(1)';
                baseContainerWidth = size.width;
                baseContainerHeight = size.height;
                containerScale = 1;
                containerOriginalPos = { left: pos.left, top: pos.top };
                
                // é‡å»ºæ ¼ç·šï¼ˆå› ç‚ºå¤§å°æ”¹è®Šï¼‰
                rebuildOutlines();
                
                // ç§»å‹•æœªæ”¾ç½®çš„æ‹¼åœ–å¾ drawer åˆ° worldContainer
                const newPw = size.width / cols;
                const newPh = size.height / rows;
                const newTab = Math.min(newPw, newPh) * 0.15;
                
                drawerPieces.forEach(dp => {
                    if (!dp.isPlaced) {
                        // ç§»é™¤èˆŠçš„ wrapper
                        if (dp.drawerItem.parentElement) {
                            dp.drawerItem.parentElement.removeChild(dp.drawerItem);
                        }
                        // å‰µå»ºæ–°çš„ scatter item
                        const newItem = createScatterItem(dp.piece, newPw, newPh, newTab);
                        newItem.currentRotation = dp.piece.currentRotation || 0;
                        if (newItem.currentRotation !== 0) {
                            const div = newItem.pieceDiv;
                            const svg = newItem.pieceSvg;
                            // æ•£è½æ¨¡å¼ä¸éœ€è¦ translate
                            if (div) div.style.transform = `rotate(${newItem.currentRotation}deg)`;
                            if (svg) {
                                svg.style.transform = `rotate(${newItem.currentRotation}deg)`;
                                svg.style.transformOrigin = 'center center';
                            }
                        }
                        document.getElementById('worldContainer').appendChild(newItem);
                        dp.drawerItem = newItem;
                    }
                });
                
                // æ•£è½æ‹¼åœ–åˆ°æ ¼ç·šå€å‘¨åœ
                scatterPiecesAroundContainer();
                
                // é¡¯ç¤ºé‚Šç•Œç·šï¼ˆç¢ºä¿ DOM æ›´æ–°å¾Œå†é¡¯ç¤ºï¼‰
                setTimeout(() => {
                    showScatterBorder();
                }, 0);
            }
            
            updateDrawerCount();
        }
        
        // é‡å»ºæ ¼ç·šï¼ˆåˆ‡æ›æ¨¡å¼æ™‚ä½¿ç”¨ï¼‰
        function rebuildOutlines() {
            const container = document.getElementById('puzzleContainer');
            const oldOutlines = container.querySelector('.outlines-container');
            if (oldOutlines) oldOutlines.remove();
            
            const size = { width: parseFloat(container.style.width), height: parseFloat(container.style.height) };
            const pw = size.width / cols;
            const ph = size.height / rows;
            
            const outlines = document.createElement('div');
            outlines.className = 'outlines-container';
            outlines.style.cssText = 'position:absolute;z-index:0;left:0;top:0;';
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    outlines.appendChild(createPieceOutline(i, j, pw, ph, size, edges[i][j]));
                }
            }
            
            container.insertBefore(outlines, container.firstChild);
            
            // é‡æ–°æ”¾ç½®å·²æ”¾å¥½çš„æ‹¼åœ–
            drawerPieces.forEach(dp => {
                if (dp.isPlaced) {
                    const pieceRow = Math.floor((dp.piece.pieceNumber - 1) / cols);
                    const pieceCol = (dp.piece.pieceNumber - 1) % cols;
                    dp.piece.correctX = pieceCol * pw;
                    dp.piece.correctY = pieceRow * ph;
                    dp.piece.style.left = dp.piece.correctX + 'px';
                    dp.piece.style.top = dp.piece.correctY + 'px';
                    
                    // æ›´æ–° piece æ¨£å¼å¤§å°
                    const tab = Math.min(pw, ph) * 0.15;
                    const actualW = pw + 2*tab;
                    const actualH = ph + 2*tab;
                    const bgX = -(pieceCol * pw) + tab;
                    const bgY = -(pieceRow * ph) + tab;
                    const path = generatePiecePath(pw, ph, dp.piece.edges);
                    dp.piece.style.width = actualW + 'px';
                    dp.piece.style.height = actualH + 'px';
                    dp.piece.style.backgroundSize = size.width + 'px ' + size.height + 'px';
                    dp.piece.style.backgroundPosition = bgX + 'px ' + bgY + 'px';
                    dp.piece.style.clipPath = `path('${path}')`;
                    dp.piece.style.webkitClipPath = `path('${path}')`;
                    dp.piece.style.transform = `translate(-${tab}px,-${tab}px)`;
                }
            });
        }
        
        // é¡¯ç¤ºæ•£è½æ¨¡å¼é‚Šç•Œç·šï¼ˆè·Ÿéš¨ç¸®æ”¾ï¼‰
        function showScatterBorder() {
            const worldContainer = document.getElementById('worldContainer');
            const container = document.getElementById('puzzleContainer');
            let border = document.getElementById('scatterBorder');
            
            if (!border) {
                border = document.createElement('div');
                border.id = 'scatterBorder';
                border.style.cssText = `
                    position: absolute;
                    border: 2px dashed rgba(255, 255, 255, 0.3);
                    border-radius: 8px;
                    pointer-events: none;
                    z-index: 0;
                `;
                worldContainer.appendChild(border);
            } else if (border.parentElement !== worldContainer) {
                // ç¢ºä¿é‚Šæ¡†åœ¨æ­£ç¢ºçš„å®¹å™¨ä¸­
                border.remove();
                worldContainer.appendChild(border);
            }
            
            const gameArea = document.getElementById('gameArea');
            const baseMargin = 10;
            
            // åŸºç¤é‚Šæ¡†å¤§å°ï¼ˆscale=1 æ™‚ï¼‰
            const baseBorderWidth = gameArea.offsetWidth - baseMargin * 2;
            const baseBorderHeight = gameArea.offsetHeight - baseMargin * 2;
            
            // ç¸®æ”¾å¾Œçš„é‚Šæ¡†å¤§å°
            const scaledWidth = baseBorderWidth * containerScale;
            const scaledHeight = baseBorderHeight * containerScale;
            
            // æ ¼ç·šå€ä¸­å¿ƒä½ç½®
            const containerCenterX = parseFloat(container.style.left) + parseFloat(container.style.width) / 2;
            const containerCenterY = parseFloat(container.style.top) + parseFloat(container.style.height) / 2;
            
            // åŸºç¤é‚Šæ¡†ä¸­å¿ƒï¼ˆscale=1 æ™‚ï¼Œé‚Šæ¡†ç½®ä¸­æ–¼ gameAreaï¼‰
            const baseBorderCenterX = gameArea.offsetWidth / 2;
            const baseBorderCenterY = gameArea.offsetHeight / 2;
            
            // é‚Šæ¡†ä¸­å¿ƒç›¸å°æ–¼æ ¼ç·šå€ä¸­å¿ƒçš„åç§»
            const offsetX = baseBorderCenterX - containerCenterX;
            const offsetY = baseBorderCenterY - containerCenterY;
            
            // ç¸®æ”¾å¾Œçš„åç§»
            const scaledOffsetX = offsetX * containerScale;
            const scaledOffsetY = offsetY * containerScale;
            
            // æ–°çš„é‚Šæ¡†ä¸­å¿ƒä½ç½®
            const newBorderCenterX = containerCenterX + scaledOffsetX;
            const newBorderCenterY = containerCenterY + scaledOffsetY;
            
            // é‚Šæ¡†å·¦ä¸Šè§’ä½ç½®
            const left = newBorderCenterX - scaledWidth / 2;
            const top = newBorderCenterY - scaledHeight / 2;
            
            border.style.left = left + 'px';
            border.style.top = top + 'px';
            border.style.width = scaledWidth + 'px';
            border.style.height = scaledHeight + 'px';
            border.style.display = 'block';
        }
        
        // æ›´æ–°æ•´å€‹ä¸–ç•Œçš„ä½ç½®ï¼ˆæ ¼ç·šå€ã€æ‹¼åœ–ã€é‚Šæ¡†ï¼‰
        function updateWorldPosition() {
            const worldContainer = document.getElementById('worldContainer');
            if (worldContainer) {
                worldContainer.style.transform = `translate(${worldOffset.x}px, ${worldOffset.y}px)`;
            }
        }
        
        // é‡ç½®ä¸–ç•Œä½ç½®
        function resetWorldOffset() {
            worldOffset.x = 0;
            worldOffset.y = 0;
            updateWorldPosition();
        }
        
        // æ›´æ–°æ•£è½é‚Šæ¡†ï¼ˆç¸®æ”¾æ™‚å‘¼å«ï¼‰
        function updateScatterBorder() {
            if (!trayMode) {
                showScatterBorder();
            }
        }

        // ============ æ•£è½æ¨¡å¼æ‹–æ›³è™•ç† ============
        let scatterDragInfo = null;
        let isScatterDragging = false;
        
        function startDragFromScatter(e) {
            if (!isPlaying) return;
            e.preventDefault();
            e.stopPropagation();
            
            const wrapper = this;
            const piece = wrapper.pieceRef;
            if (!piece || piece.isPlaced) return;
            
            // é‡ç½®æ‹–æ›³ç‹€æ…‹
            isScatterDragging = false;
            
            // æå‡ z-index
            wrapper.style.zIndex = drawerPieceZIndex++;
            
            const rect = wrapper.getBoundingClientRect();
            const gameArea = document.getElementById('gameArea');
            const gameAreaRect = gameArea.getBoundingClientRect();
            
            // offsetX/Y æ˜¯æ‰‹æŒ‡åœ¨ wrapper å…§çš„ç›¸å°ä½ç½®
            scatterDragInfo = {
                wrapper: wrapper,
                piece: piece,
                startX: e.clientX,
                startY: e.clientY,
                offsetX: e.clientX - rect.left,
                offsetY: e.clientY - rect.top,
                originalLeft: parseFloat(wrapper.style.left),
                originalTop: parseFloat(wrapper.style.top),
                // è¨˜éŒ„é–‹å§‹æ™‚çš„ worldOffsetï¼Œç”¨æ–¼è¨ˆç®—æ­£ç¢ºä½ç½®
                startWorldOffsetX: worldOffset.x,
                startWorldOffsetY: worldOffset.y
            };
            
            document.addEventListener('mousemove', handleScatterMouseMove);
            document.addEventListener('mouseup', handleScatterMouseUp);
        }
        
        function handleScatterMouseMove(e) {
            if (!scatterDragInfo) return;
            
            const dx = e.clientX - scatterDragInfo.startX;
            const dy = e.clientY - scatterDragInfo.startY;
            
            // ç§»å‹•è¶…éé–¾å€¼æ‰é–‹å§‹æ‹–æ›³
            if (!isScatterDragging && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                isScatterDragging = true;
                
                // é–‹å§‹æ‹–æ›³æ™‚ï¼Œå¦‚æœæœ‰æ—‹è½‰å°±å…ˆæ­¸é›¶
                const wrapper = scatterDragInfo.wrapper;
                if (wrapper.currentRotation !== 0) {
                    wrapper.currentRotation = 0;
                    scatterDragInfo.piece.currentRotation = 0;
                    const div = wrapper.pieceDiv;
                    const svg = wrapper.pieceSvg;
                    if (div) div.style.transform = '';
                    if (svg) svg.style.transform = '';
                }
            }
            
            if (!isScatterDragging) return;
            
            const wrapper = scatterDragInfo.wrapper;
            
            // ä½¿ç”¨åŸå§‹ä½ç½® + ç§»å‹•é‡è¨ˆç®—æ–°ä½ç½®
            let newX = scatterDragInfo.originalLeft + dx;
            let newY = scatterDragInfo.originalTop + dy;
            
            // è¨ˆç®—ç¸®æ”¾å¾Œçš„è™›ç·šé‚Šç•Œ
            const gameArea = document.getElementById('gameArea');
            const baseMargin = 10;
            const borderWidth = (gameArea.offsetWidth - baseMargin * 2) * containerScale;
            const borderHeight = (gameArea.offsetHeight - baseMargin * 2) * containerScale;
            const borderLeft = (gameArea.offsetWidth - borderWidth) / 2;
            const borderTop = (gameArea.offsetHeight - borderHeight) / 2;
            
            // é™åˆ¶åœ¨è™›ç·šé‚Šç•Œå…§
            const wrapperWidth = parseFloat(wrapper.style.width);
            const wrapperHeight = parseFloat(wrapper.style.height);
            newX = Math.max(borderLeft, Math.min(borderLeft + borderWidth - wrapperWidth, newX));
            newY = Math.max(borderTop, Math.min(borderTop + borderHeight - wrapperHeight, newY));
            
            wrapper.style.left = newX + 'px';
            wrapper.style.top = newY + 'px';
        }
        
        function handleScatterMouseUp(e) {
            document.removeEventListener('mousemove', handleScatterMouseMove);
            document.removeEventListener('mouseup', handleScatterMouseUp);
            
            if (!scatterDragInfo) return;
            
            const wrapper = scatterDragInfo.wrapper;
            const piece = scatterDragInfo.piece;
            
            if (!isScatterDragging) {
                // çŸ­æŒ‰ - æ•£è½æ¨¡å¼åªé¡¯ç¤ºæç¤ºï¼ˆä¸åšæ—‹è½‰ï¼Œæ—‹è½‰åœ¨æ‹–æ›³æ™‚è‡ªå‹•æ­¸é›¶ï¼‰
                if (showHint) {
                    showScatterHint(wrapper);
                }
                scatterDragInfo = null;
                isScatterDragging = false;
                return;
            }
            
            // æª¢æŸ¥æ˜¯å¦æ”¾ç½®æ­£ç¢ºï¼ˆæ‹–æ›³æ™‚å·²ç¶“æ­¸é›¶æ—‹è½‰äº†ï¼‰
            const container = document.getElementById('puzzleContainer');
            const containerRect = container.getBoundingClientRect();
            const wrapperRect = wrapper.getBoundingClientRect();
            
            // è¨ˆç®— wrapper ä¸­å¿ƒ
            const wrapperCenterX = wrapperRect.left + wrapperRect.width / 2;
            const wrapperCenterY = wrapperRect.top + wrapperRect.height / 2;
            
            // ä½¿ç”¨æ ¼ç·šå€çš„åŸºç¤å¤§å°è¨ˆç®—æ­£ç¢ºä½ç½®ï¼ˆä¸æ˜¯ç¸®æ”¾å¾Œçš„ wrapper å¤§å°ï¼‰
            const basePw = baseContainerWidth / cols;
            const basePh = baseContainerHeight / rows;
            const baseTab = Math.min(basePw, basePh) * 0.15;
            const pieceRow = Math.floor((piece.pieceNumber - 1) / cols);
            const pieceCol = (piece.pieceNumber - 1) % cols;
            const correctX = pieceCol * basePw;
            const correctY = pieceRow * basePh;
            
            // æ­£ç¢ºä½ç½®ä¸­å¿ƒåœ¨è¢å¹•ä¸Šçš„åº§æ¨™ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
            const correctCenterX = containerRect.left + (correctX + basePw / 2) * containerScale;
            const correctCenterY = containerRect.top + (correctY + basePh / 2) * containerScale;
            
            // æª¢æŸ¥æ˜¯å¦æ¥è¿‘æ­£ç¢ºä½ç½®ï¼ˆæ‹–æ›³æ™‚å·²ç¶“æ­¸é›¶æ—‹è½‰äº†ï¼‰
            const tolerance = 25 * containerScale;
            if (Math.abs(wrapperCenterX - correctCenterX) < tolerance && 
                Math.abs(wrapperCenterY - correctCenterY) < tolerance) {
                // æ”¾ç½®æ­£ç¢º - ä½¿ç”¨æ ¼ç·šå€çš„åŸºç¤å¤§å°
                const size = { width: baseContainerWidth, height: baseContainerHeight };
                const bgX = -(pieceCol * basePw) + baseTab;
                const bgY = -(pieceRow * basePh) + baseTab;
                const path = generatePiecePath(basePw, basePh, piece.edges);
                const actualW = basePw + 2 * baseTab;
                const actualH = basePh + 2 * baseTab;
                
                piece.style.cssText = `
                    width: ${actualW}px;
                    height: ${actualH}px;
                    background-image: url(${originalImage.src});
                    background-size: ${size.width}px ${size.height}px;
                    background-position: ${bgX}px ${bgY}px;
                    background-repeat: no-repeat;
                    clip-path: path('${path}');
                    -webkit-clip-path: path('${path}');
                    position: absolute;
                    transform: translate(-${baseTab}px, -${baseTab}px);
                    left: ${correctX}px;
                    top: ${correctY}px;
                `;
                piece.correctX = correctX;
                piece.correctY = correctY;
                piece.currentRotation = 0;
                piece.isPlaced = true;
                container.appendChild(piece);
                
                wrapper.classList.add('placed');
                wrapper.style.display = 'none';
                const dp = drawerPieces.find(d => d.piece === piece);
                if (dp) dp.isPlaced = true;
                
                playSnapSound();
                if (navigator.vibrate) navigator.vibrate(20);
                updateDrawerCount();
                checkWin();
            }
            
            scatterDragInfo = null;
            isScatterDragging = false;
        }
        
        // æ•£è½æ¨¡å¼è§¸æ§æ‹–æ›³
        let scatterTouchInfo = null;
        let isScatterTouchDragging = false;
        
        function startTouchFromScatter(e) {
            if (!isPlaying) return;
            e.preventDefault();
            e.stopPropagation();
            
            const wrapper = this;
            const piece = wrapper.pieceRef;
            if (!piece || piece.isPlaced) return;
            
            // é‡ç½®æ‹–æ›³ç‹€æ…‹
            isScatterTouchDragging = false;
            
            const touch = e.touches[0];
            const rect = wrapper.getBoundingClientRect();
            
            wrapper.style.zIndex = drawerPieceZIndex++;
            
            scatterTouchInfo = {
                wrapper: wrapper,
                piece: piece,
                startX: touch.clientX,
                startY: touch.clientY,
                offsetX: touch.clientX - rect.left,
                offsetY: touch.clientY - rect.top,
                originalLeft: parseFloat(wrapper.style.left),
                originalTop: parseFloat(wrapper.style.top),
                startWorldOffsetX: worldOffset.x,
                startWorldOffsetY: worldOffset.y
            };
            
            document.addEventListener('touchmove', handleScatterTouchMove, {passive: false});
            document.addEventListener('touchend', handleScatterTouchEnd);
        }
        
        function handleScatterTouchMove(e) {
            if (!scatterTouchInfo) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const dx = touch.clientX - scatterTouchInfo.startX;
            const dy = touch.clientY - scatterTouchInfo.startY;
            
            // ç§»å‹•è¶…éé–¾å€¼æ‰é–‹å§‹æ‹–æ›³
            if (!isScatterTouchDragging && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                isScatterTouchDragging = true;
                
                // é–‹å§‹æ‹–æ›³æ™‚ï¼Œå¦‚æœæœ‰æ—‹è½‰å°±å…ˆæ­¸é›¶
                const wrapper = scatterTouchInfo.wrapper;
                if (wrapper.currentRotation !== 0) {
                    wrapper.currentRotation = 0;
                    scatterTouchInfo.piece.currentRotation = 0;
                    const div = wrapper.pieceDiv;
                    const svg = wrapper.pieceSvg;
                    if (div) div.style.transform = '';
                    if (svg) svg.style.transform = '';
                }
            }
            
            if (!isScatterTouchDragging) return;
            
            const wrapper = scatterTouchInfo.wrapper;
            
            // ä½¿ç”¨åŸå§‹ä½ç½® + ç§»å‹•é‡è¨ˆç®—æ–°ä½ç½®
            let newX = scatterTouchInfo.originalLeft + dx;
            let newY = scatterTouchInfo.originalTop + dy;
            
            // è¨ˆç®—ç¸®æ”¾å¾Œçš„è™›ç·šé‚Šç•Œ
            const gameArea = document.getElementById('gameArea');
            const baseMargin = 10;
            const borderWidth = (gameArea.offsetWidth - baseMargin * 2) * containerScale;
            const borderHeight = (gameArea.offsetHeight - baseMargin * 2) * containerScale;
            const borderLeft = (gameArea.offsetWidth - borderWidth) / 2;
            const borderTop = (gameArea.offsetHeight - borderHeight) / 2;
            
            // é™åˆ¶åœ¨è™›ç·šé‚Šç•Œå…§
            const wrapperWidth = parseFloat(wrapper.style.width);
            const wrapperHeight = parseFloat(wrapper.style.height);
            newX = Math.max(borderLeft, Math.min(borderLeft + borderWidth - wrapperWidth, newX));
            newY = Math.max(borderTop, Math.min(borderTop + borderHeight - wrapperHeight, newY));
            
            wrapper.style.left = newX + 'px';
            wrapper.style.top = newY + 'px';
        }
        
        function handleScatterTouchEnd(e) {
            document.removeEventListener('touchmove', handleScatterTouchMove);
            document.removeEventListener('touchend', handleScatterTouchEnd);
            
            if (!scatterTouchInfo) return;
            
            const wrapper = scatterTouchInfo.wrapper;
            const piece = scatterTouchInfo.piece;
            
            if (!isScatterTouchDragging) {
                // çŸ­æŒ‰ - æ•£è½æ¨¡å¼åªé¡¯ç¤ºæç¤ºï¼ˆä¸åšæ—‹è½‰ï¼Œæ—‹è½‰åœ¨æ‹–æ›³æ™‚è‡ªå‹•æ­¸é›¶ï¼‰
                if (showHint) {
                    showScatterHint(wrapper);
                }
                scatterTouchInfo = null;
                isScatterTouchDragging = false;
                return;
            }
            
            // æª¢æŸ¥æ˜¯å¦æ”¾ç½®æ­£ç¢ºï¼ˆæ‹–æ›³æ™‚å·²ç¶“æ­¸é›¶æ—‹è½‰äº†ï¼‰
            const container = document.getElementById('puzzleContainer');
            const containerRect = container.getBoundingClientRect();
            const wrapperRect = wrapper.getBoundingClientRect();
            
            // è¨ˆç®— wrapper ä¸­å¿ƒ
            const wrapperCenterX = wrapperRect.left + wrapperRect.width / 2;
            const wrapperCenterY = wrapperRect.top + wrapperRect.height / 2;
            
            // ä½¿ç”¨æ ¼ç·šå€çš„åŸºç¤å¤§å°è¨ˆç®—æ­£ç¢ºä½ç½®ï¼ˆä¸æ˜¯ç¸®æ”¾å¾Œçš„ wrapper å¤§å°ï¼‰
            const basePw = baseContainerWidth / cols;
            const basePh = baseContainerHeight / rows;
            const baseTab = Math.min(basePw, basePh) * 0.15;
            const pieceRow = Math.floor((piece.pieceNumber - 1) / cols);
            const pieceCol = (piece.pieceNumber - 1) % cols;
            const correctX = pieceCol * basePw;
            const correctY = pieceRow * basePh;
            
            // æ­£ç¢ºä½ç½®ä¸­å¿ƒåœ¨è¢å¹•ä¸Šçš„åº§æ¨™ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
            const correctCenterX = containerRect.left + (correctX + basePw / 2) * containerScale;
            const correctCenterY = containerRect.top + (correctY + basePh / 2) * containerScale;
            
            const tolerance = 25 * containerScale;
            if (Math.abs(wrapperCenterX - correctCenterX) < tolerance && 
                Math.abs(wrapperCenterY - correctCenterY) < tolerance) {
                // æ”¾ç½®æ­£ç¢º - ä½¿ç”¨æ ¼ç·šå€çš„åŸºç¤å¤§å°
                const size = { width: baseContainerWidth, height: baseContainerHeight };
                const bgX = -(pieceCol * basePw) + baseTab;
                const bgY = -(pieceRow * basePh) + baseTab;
                const path = generatePiecePath(basePw, basePh, piece.edges);
                const actualW = basePw + 2 * baseTab;
                const actualH = basePh + 2 * baseTab;
                
                piece.style.cssText = `
                    width: ${actualW}px;
                    height: ${actualH}px;
                    background-image: url(${originalImage.src});
                    background-size: ${size.width}px ${size.height}px;
                    background-position: ${bgX}px ${bgY}px;
                    background-repeat: no-repeat;
                    clip-path: path('${path}');
                    -webkit-clip-path: path('${path}');
                    position: absolute;
                    transform: translate(-${baseTab}px, -${baseTab}px);
                    left: ${correctX}px;
                    top: ${correctY}px;
                `;
                piece.correctX = correctX;
                piece.correctY = correctY;
                piece.currentRotation = 0;
                piece.isPlaced = true;
                container.appendChild(piece);
                
                wrapper.classList.add('placed');
                wrapper.style.display = 'none';
                const dp = drawerPieces.find(d => d.piece === piece);
                if (dp) dp.isPlaced = true;
                
                playSnapSound();
                if (navigator.vibrate) navigator.vibrate(20);
                updateDrawerCount();
                checkWin();
            }
            
            scatterTouchInfo = null;
            isScatterTouchDragging = false;
        }
        
        // æ›´æ–°æ•£è½æ‹¼åœ–çš„ç¸®æ”¾ï¼ˆè·Ÿéš¨æ ¼ç·šå€ç¸®æ”¾ï¼‰
        function updateScatterPiecesScale(scaleRatio) {
            const container = document.getElementById('puzzleContainer');
            const containerRect = container.getBoundingClientRect();
            const gameArea = document.getElementById('gameArea');
            
            // æ ¼ç·šå€ä¸­å¿ƒ
            const containerCenterX = parseFloat(container.style.left) + parseFloat(container.style.width) / 2;
            const containerCenterY = parseFloat(container.style.top) + parseFloat(container.style.height) / 2;
            
            drawerPieces.forEach(dp => {
                if (dp.isPlaced) return;
                const wrapper = dp.drawerItem;
                if (!wrapper || wrapper.style.display === 'none') return;
                
                // è¨ˆç®— wrapper ç›¸å°æ–¼æ ¼ç·šå€ä¸­å¿ƒçš„ä½ç½®
                const wrapperLeft = parseFloat(wrapper.style.left);
                const wrapperTop = parseFloat(wrapper.style.top);
                const wrapperW = parseFloat(wrapper.style.width);
                const wrapperH = parseFloat(wrapper.style.height);
                const wrapperCenterX = wrapperLeft + wrapperW / 2;
                const wrapperCenterY = wrapperTop + wrapperH / 2;
                
                // ç›¸å°æ–¼æ ¼ç·šå€ä¸­å¿ƒçš„åç§»
                const offsetX = wrapperCenterX - containerCenterX;
                const offsetY = wrapperCenterY - containerCenterY;
                
                // ç¸®æ”¾åç§»å’Œå¤§å°
                const newOffsetX = offsetX * scaleRatio;
                const newOffsetY = offsetY * scaleRatio;
                const newW = wrapperW * scaleRatio;
                const newH = wrapperH * scaleRatio;
                
                // æ–°çš„ä¸­å¿ƒä½ç½®
                const newCenterX = containerCenterX + newOffsetX;
                const newCenterY = containerCenterY + newOffsetY;
                
                // æ›´æ–° wrapper å¤§å°å’Œä½ç½®
                wrapper.style.width = newW + 'px';
                wrapper.style.height = newH + 'px';
                wrapper.style.left = (newCenterX - newW / 2) + 'px';
                wrapper.style.top = (newCenterY - newH / 2) + 'px';
                
                // æ›´æ–°å…§éƒ¨æ‹¼åœ–å’Œé‚Šæ¡†çš„å¤§å°
                const pw = wrapper.pw * scaleRatio;
                const ph = wrapper.ph * scaleRatio;
                const tab = wrapper.tab * scaleRatio;
                wrapper.pw = pw;
                wrapper.ph = ph;
                wrapper.tab = tab;
                
                // æ›´æ–° pieceDiv
                const div = wrapper.pieceDiv;
                if (div) {
                    const pieceRow = Math.floor((dp.piece.pieceNumber - 1) / cols);
                    const pieceCol = (dp.piece.pieceNumber - 1) % cols;
                    const size = { width: pw * cols, height: ph * rows };
                    const bgX = -(pieceCol * pw) + tab;
                    const bgY = -(pieceRow * ph) + tab;
                    const path = generatePiecePath(pw, ph, dp.piece.edges);
                    const rotation = wrapper.currentRotation || 0;
                    
                    div.style.width = newW + 'px';
                    div.style.height = newH + 'px';
                    div.style.backgroundSize = `${size.width}px ${size.height}px`;
                    div.style.backgroundPosition = `${bgX}px ${bgY}px`;
                    div.style.clipPath = `path('${path}')`;
                    div.style.webkitClipPath = `path('${path}')`;
                    div.style.transformOrigin = `center center`;
                    div.style.transform = rotation !== 0 ? `rotate(${rotation}deg)` : '';
                }
                
                // æ›´æ–° SVG é‚Šæ¡†
                const svg = wrapper.pieceSvg;
                if (svg) {
                    const borderPath = generateCurvedPath(pw, ph, dp.piece.edges);
                    svg.setAttribute('width', newW);
                    svg.setAttribute('height', newH);
                    svg.innerHTML = `<path d="${borderPath}" fill="none" stroke="#000" stroke-width="1"/>`;
                    const rotation = wrapper.currentRotation || 0;
                    svg.style.transform = rotation !== 0 ? `rotate(${rotation}deg)` : '';
                }
            });
        }
        
        // æ•£è½æ¨¡å¼æç¤º
        function showScatterHint(wrapper) {
            if (!showHint) return;
            if (!wrapper || wrapper.classList.contains('placed')) return;
            
            const existing = wrapper.querySelector('.scatter-hint');
            if (existing) existing.remove();
            
            const hint = document.createElement('div');
            hint.className = 'scatter-hint';
            hint.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                font-size: 14px;
                font-weight: bold;
                padding: 4px 8px;
                border-radius: 4px;
                pointer-events: none;
                z-index: 100;
            `;
            hint.textContent = wrapper.pieceNumber;
            wrapper.appendChild(hint);
            
            setTimeout(() => hint.remove(), 3000);
        }

        // å¾æŠ½å±œæ‹–æ›³ (æ»‘é¼ ) - åŠ å…¥å»¶é²åˆ¤æ–·ï¼ŒçŸ­æŒ‰é¡¯ç¤ºæç¤ºï¼Œé•·æŒ‰æ‰æ‹–æ›³
        let mouseStartInfo = null;
        let mouseDragTimer = null;
        let isMouseDragging = false;
        const MOUSE_DRAG_DELAY = 150;

        function startDragFromDrawer(e) {
            if (!isPlaying) return;
            e.preventDefault();
            const wrapper = this, piece = wrapper.pieceRef;
            if (!piece || piece.isPlaced) return;
            
            // æ•£äº‚æ¨¡å¼ï¼šé»æ“Šæ™‚æå‡ z-index
            if (scatterMode) {
                wrapper.style.zIndex = drawerPieceZIndex++;
            }
            
            // é¡¯ç¤ºç·¨è™Ÿæç¤º
            showDrawerHint(wrapper);
            
            // è¨˜éŒ„æ»‘é¼ è³‡è¨Š
            const wrapperRect = wrapper.getBoundingClientRect();
            const tab = wrapper.tab || 0;
            
            // piece æœ‰ translate(-tab,-tab)ï¼Œæ‰€ä»¥åç§»è¦åŠ å› tabï¼ˆç”¨æ–¼ container å…§å®šä½ï¼‰
            // wrapper åç§»ä¸éœ€è¦æ¸› tabï¼ˆç”¨æ–¼ drawer å…§å®šä½ï¼‰
            mouseStartInfo = {
                wrapper: wrapper,
                piece: piece,
                clientX: e.clientX,
                clientY: e.clientY,
                offsetInWrapperX: e.clientX - wrapperRect.left - tab,
                offsetInWrapperY: e.clientY - wrapperRect.top - tab,
                wrapperOffsetX: e.clientX - wrapperRect.left,
                wrapperOffsetY: e.clientY - wrapperRect.top
            };
            isMouseDragging = false;
            
            // å»¶é²å•Ÿå‹•æ‹–æ›³
            mouseDragTimer = setTimeout(() => {
                if (mouseStartInfo) {
                    startActualMouseDrag();
                }
            }, MOUSE_DRAG_DELAY);
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        
        function handleMouseMove(e) {
            if (!mouseStartInfo) return;
            
            // æ›´æ–°ä½ç½®
            mouseStartInfo.clientX = e.clientX;
            mouseStartInfo.clientY = e.clientY;
            
            // å¦‚æœå·²ç¶“åœ¨æ‹–æ›³ï¼Œç§»å‹•æ‹¼åœ–
            if (isMouseDragging && currentPiece) {
                const rect = document.getElementById('puzzleContainer').getBoundingClientRect();
                // æ‰‹æŒ‡åœ¨ container å…§çš„ä½ç½®ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
                const posInContainer = {
                    x: (e.clientX - rect.left) / containerScale,
                    y: (e.clientY - rect.top) / containerScale
                };
                currentPiece.style.left = (posInContainer.x - currentPiece.offX) + 'px';
                currentPiece.style.top = (posInContainer.y - currentPiece.offY) + 'px';
            }
        }
        
        function startActualMouseDrag() {
            if (!mouseStartInfo) return;
            
            isMouseDragging = true;
            const { wrapper, piece, clientX, clientY, offsetInWrapperX, offsetInWrapperY } = mouseStartInfo;
            
            wrapper.classList.add('dragging');
            // éš±è— drawer ä¸­çš„é è¦½åœ–å’Œé‚Šæ¡†
            if (wrapper.pieceDiv) wrapper.pieceDiv.style.visibility = 'hidden';
            if (wrapper.pieceSvg) wrapper.pieceSvg.style.visibility = 'hidden';
            
            const container = document.getElementById('puzzleContainer');
            const rect = container.getBoundingClientRect();
            
            // ç¢ºä¿ piece ä¸åœ¨ container è£¡ï¼ˆä»¥é˜²è¬ä¸€ï¼‰
            if (piece.parentElement === container) {
                container.removeChild(piece);
            }
            
            // é‡æ–°ç”Ÿæˆæ­£ç¢ºå¤§å°çš„æ‹¼åœ–æ¨£å¼ï¼ˆä½¿ç”¨ container çš„å¤§å°ï¼‰
            const pw = baseContainerWidth / cols;
            const ph = baseContainerHeight / rows;
            const tab = Math.min(pw, ph) * 0.15;
            const actualW = pw + 2 * tab;
            const actualH = ph + 2 * tab;
            const pieceRow = Math.floor((piece.pieceNumber - 1) / cols);
            const pieceCol = (piece.pieceNumber - 1) % cols;
            const size = { width: baseContainerWidth, height: baseContainerHeight };
            const bgX = -(pieceCol * pw) + tab;
            const bgY = -(pieceRow * ph) + tab;
            const path = generatePiecePath(pw, ph, piece.edges);
            
            // æ›´æ–°æ­£ç¢ºä½ç½®ï¼ˆä½¿ç”¨æ–°çš„ pw, phï¼‰
            piece.correctX = pieceCol * pw;
            piece.correctY = pieceRow * ph;
            
            piece.style.cssText = `
                width: ${actualW}px;
                height: ${actualH}px;
                background-image: url(${originalImage.src});
                background-size: ${size.width}px ${size.height}px;
                background-position: ${bgX}px ${bgY}px;
                background-repeat: no-repeat;
                clip-path: path('${path}');
                -webkit-clip-path: path('${path}');
                position: absolute;
                transform: translate(-${tab}px, -${tab}px);
            `;
            
            // æ‰‹æŒ‡åœ¨ container å…§çš„ä½ç½®ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
            const posInContainer = {
                x: (clientX - rect.left) / containerScale,
                y: (clientY - rect.top) / containerScale
            };
            
            // è¨ˆç®—åç§»ï¼ˆä½¿ç”¨æ–°çš„ tabï¼‰
            const offsetX = offsetInWrapperX * (pw / (wrapper.pw || pw));
            const offsetY = offsetInWrapperY * (ph / (wrapper.ph || ph));
            
            piece.style.left = (posInContainer.x - offsetX) + 'px';
            piece.style.top = (posInContainer.y - offsetY) + 'px';
            piece.style.zIndex = '1000';
            piece.classList.add('dragging');
            container.appendChild(piece);
            
            // æå‡ container z-index è®“æ‹¼åœ–é¡¯ç¤ºåœ¨ drawer ä¸Šæ–¹
            container.style.zIndex = '1000';
            
            currentPiece = piece;
            currentPiece.drawerWrapper = wrapper;
            currentPiece.offX = offsetX;
            currentPiece.offY = offsetY;
        }
        
        function handleMouseUp() {
            clearTimeout(mouseDragTimer);
            mouseDragTimer = null;
            
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            
            // æ¢å¾© container z-index
            document.getElementById('puzzleContainer').style.zIndex = '';
            
            if (!isMouseDragging) {
                // åªæ˜¯çŸ­æŒ‰ï¼Œä¸éœ€è¦è™•ç†æ‹–æ›³
                mouseStartInfo = null;
                return;
            }
            
            if (!currentPiece) {
                mouseStartInfo = null;
                isMouseDragging = false;
                return;
            }
            
            const piece = currentPiece; // ä¿å­˜å¼•ç”¨
            piece.classList.remove('dragging');
            piece.style.zIndex = '';
            
            const left = parseInt(piece.style.left), top = parseInt(piece.style.top);
            
            // ä½ç½®æ­£ç¢ºå°±æ”¾ç½®ï¼Œä¸¦è‡ªå‹•è½‰æ­£
            if (Math.abs(left - piece.correctX) < 15 && Math.abs(top - piece.correctY) < 15) {
                piece.style.transition = 'transform 0.3s';
                piece.style.left = piece.correctX + 'px';
                piece.style.top = piece.correctY + 'px';
                // è‡ªå‹•è½‰æ­£ï¼ˆç§»é™¤æ—‹è½‰ï¼‰
                piece.style.transform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.currentRotation = 0;
                setTimeout(() => piece.style.transition = '', 300);
                piece.isPlaced = true;
                piece.drawerWrapper.classList.add('placed');
                const dp = drawerPieces.find(d => d.piece === piece);
                if (dp) dp.isPlaced = true;
                playSnapSound();
                if (navigator.vibrate) navigator.vibrate(20);
                updateDrawerCount();
                checkWin();
            } else {
                // æ‹–æ›³å¤±æ•— - æª¢æŸ¥æ˜¯å¦åœ¨ drawer å€å…§ï¼ˆæ•£äº‚æ¨¡å¼ä¸‹å¯é‡æ–°å®šä½ï¼‰
                const drawer = document.getElementById('puzzleDrawer');
                const drawerRect = drawer.getBoundingClientRect();
                const mouseX = mouseStartInfo.clientX;
                const mouseY = mouseStartInfo.clientY;
                
                // å¾ container ç§»é™¤ piece
                document.getElementById('puzzleContainer').removeChild(piece);
                // é‡ç½® piece çš„æ—‹è½‰ï¼ˆä¿æŒ drawer ä¸­çš„æ—‹è½‰ç‹€æ…‹ï¼‰
                const baseTransform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.style.transform = baseTransform;
                
                // æ•£äº‚æ¨¡å¼ä¸”åœ¨ drawer å€å…§ - ç§»å‹•åˆ°æ–°ä½ç½®
                if (scatterMode && 
                    mouseX >= drawerRect.left && mouseX <= drawerRect.right &&
                    mouseY >= drawerRect.top && mouseY <= drawerRect.bottom) {
                    
                    // ä½¿ç”¨ wrapper åç§»ï¼ˆä¸å« tab è£œå„Ÿï¼‰ï¼Œè®“æ”¾ä¸‹ä½ç½®èˆ‡æ‹–æ›³æ™‚ä¸€è‡´
                    const offsetX = mouseStartInfo.wrapperOffsetX || piece.drawerWrapper.offsetWidth / 2;
                    const offsetY = mouseStartInfo.wrapperOffsetY || piece.drawerWrapper.offsetHeight / 2;
                    const newX = mouseX - drawerRect.left - offsetX;
                    const newY = mouseY - drawerRect.top - offsetY;
                    piece.drawerWrapper.style.left = Math.max(0, newX) + 'px';
                    piece.drawerWrapper.style.top = Math.max(0, newY) + 'px';
                    piece.drawerWrapper.style.zIndex = drawerPieceZIndex++;
                }
                
                // é¡¯ç¤º drawer ä¸­çš„é è¦½åœ–å’Œé‚Šæ¡†
                if (piece.drawerWrapper.pieceDiv) {
                    piece.drawerWrapper.pieceDiv.style.visibility = 'visible';
                }
                if (piece.drawerWrapper.pieceSvg) {
                    piece.drawerWrapper.pieceSvg.style.visibility = 'visible';
                }
                piece.drawerWrapper.classList.remove('dragging');
            }
            
            currentPiece = null;
            mouseStartInfo = null;
            isMouseDragging = false;
        }
        
        function dragFromDrawer(e) {
            // ä¸å†ä½¿ç”¨ï¼Œæ”¹ç”¨ handleMouseMove
        }

        // å¾æŠ½å±œæ‹–æ›³ (è§¸æ§) - åŠ å…¥æ»¾å‹•åˆ¤æ–·
        let touchStartInfo = null;
        let dragDelayTimer = null;
        let isDraggingFromDrawer = false;
        const DRAG_DELAY = 150; // é•·æŒ‰150msæ‰é–‹å§‹æ‹–æ›³
        const SCROLL_THRESHOLD = 10; // ç§»å‹•è¶…é10pxè¦–ç‚ºæ»¾å‹•

        function startTouchFromDrawer(e) {
            if (!isPlaying) return;
            
            const wrapper = this;
            const piece = wrapper.pieceRef;
            if (!piece || piece.isPlaced) return;
            
            // æ•£äº‚æ¨¡å¼ï¼šé»æ“Šæ™‚æå‡ z-index
            if (scatterMode) {
                wrapper.style.zIndex = drawerPieceZIndex++;
            }
            
            // é¡¯ç¤ºç·¨è™Ÿæç¤º
            showDrawerHint(wrapper);
            
            const touch = e.touches[0];
            const wrapperRect = wrapper.getBoundingClientRect();
            const tab = wrapper.tab || 0;
            
            touchStartInfo = {
                wrapper: wrapper,
                piece: piece,
                startX: touch.clientX,
                startY: touch.clientY,
                lastX: touch.clientX,
                lastY: touch.clientY,
                // è¨˜éŒ„æ‰‹æŒ‡åœ¨ wrapper å…§çš„åç§»ï¼Œæ¸›å» tab è£œå„Ÿ piece çš„ translate
                offsetInWrapperX: touch.clientX - wrapperRect.left - tab,
                offsetInWrapperY: touch.clientY - wrapperRect.top - tab,
                // wrapper åç§»ä¸å« tabï¼ˆç”¨æ–¼ drawer å…§å®šä½ï¼‰
                wrapperOffsetX: touch.clientX - wrapperRect.left,
                wrapperOffsetY: touch.clientY - wrapperRect.top,
                scrollLeft: document.getElementById('puzzleDrawer').scrollLeft,
                scrollTop: document.getElementById('puzzleDrawer').scrollTop
            };
            isDraggingFromDrawer = false;
            
            // å»¶é²å•Ÿå‹•æ‹–æ›³ï¼Œçµ¦æ»¾å‹•æ©Ÿæœƒ
            dragDelayTimer = setTimeout(() => {
                if (touchStartInfo && !isDraggingFromDrawer) {
                    // æª¢æŸ¥æ˜¯å¦å·²ç¶“åœ¨æ»¾å‹•
                    const drawer = document.getElementById('puzzleDrawer');
                    const scrolled = Math.abs(drawer.scrollLeft - touchStartInfo.scrollLeft) > 5 || 
                                    Math.abs(drawer.scrollTop - touchStartInfo.scrollTop) > 5;
                    if (!scrolled) {
                        startActualDrag();
                    }
                }
            }, DRAG_DELAY);
            
            document.addEventListener('touchmove', handleDrawerTouchMove, {passive: false});
            document.addEventListener('touchend', handleDrawerTouchEnd);
        }
        
        function handleDrawerTouchMove(e) {
            if (!touchStartInfo) return;
            
            const touch = e.touches[0];
            const dx = touch.clientX - touchStartInfo.startX;
            const dy = touch.clientY - touchStartInfo.startY;
            
            // æ›´æ–°æœ€å¾Œè§¸æ§ä½ç½®
            touchStartInfo.lastX = touch.clientX;
            touchStartInfo.lastY = touch.clientY;
            
            if (isDraggingFromDrawer) {
                // æ­£åœ¨æ‹–æ›³æ‹¼åœ–
                e.preventDefault();
                const rect = document.getElementById('puzzleContainer').getBoundingClientRect();
                // æ‰‹æŒ‡åœ¨ container å…§çš„ä½ç½®ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
                const posInContainer = {
                    x: (touch.clientX - rect.left) / containerScale,
                    y: (touch.clientY - rect.top) / containerScale
                };
                currentPiece.style.left = (posInContainer.x - currentPiece.offX) + 'px';
                currentPiece.style.top = (posInContainer.y - currentPiece.offY) + 'px';
            } else {
                // æª¢æŸ¥æ˜¯å¦ç‚ºæ»¾å‹•æ„åœ–
                if (Math.abs(dx) > SCROLL_THRESHOLD || Math.abs(dy) > SCROLL_THRESHOLD) {
                    // å–æ¶ˆæ‹–æ›³ï¼Œå…è¨±æ»¾å‹•
                    clearTimeout(dragDelayTimer);
                    dragDelayTimer = null;
                }
            }
        }
        
        function startActualDrag() {
            if (!touchStartInfo) return;
            
            isDraggingFromDrawer = true;
            const { wrapper, piece, lastX, lastY, offsetInWrapperX, offsetInWrapperY } = touchStartInfo;
            
            wrapper.classList.add('dragging');
            // éš±è— drawer ä¸­çš„é è¦½åœ–å’Œé‚Šæ¡†
            if (wrapper.pieceDiv) wrapper.pieceDiv.style.visibility = 'hidden';
            if (wrapper.pieceSvg) wrapper.pieceSvg.style.visibility = 'hidden';
            
            const container = document.getElementById('puzzleContainer');
            const rect = container.getBoundingClientRect();
            
            // ç¢ºä¿ piece ä¸åœ¨ container è£¡ï¼ˆä»¥é˜²è¬ä¸€ï¼‰
            if (piece.parentElement === container) {
                container.removeChild(piece);
            }
            
            // é‡æ–°ç”Ÿæˆæ­£ç¢ºå¤§å°çš„æ‹¼åœ–æ¨£å¼ï¼ˆä½¿ç”¨ container çš„å¤§å°ï¼‰
            const pw = baseContainerWidth / cols;
            const ph = baseContainerHeight / rows;
            const tab = Math.min(pw, ph) * 0.15;
            const actualW = pw + 2 * tab;
            const actualH = ph + 2 * tab;
            const pieceRow = Math.floor((piece.pieceNumber - 1) / cols);
            const pieceCol = (piece.pieceNumber - 1) % cols;
            const size = { width: baseContainerWidth, height: baseContainerHeight };
            const bgX = -(pieceCol * pw) + tab;
            const bgY = -(pieceRow * ph) + tab;
            const path = generatePiecePath(pw, ph, piece.edges);
            
            // æ›´æ–°æ­£ç¢ºä½ç½®ï¼ˆä½¿ç”¨æ–°çš„ pw, phï¼‰
            piece.correctX = pieceCol * pw;
            piece.correctY = pieceRow * ph;
            
            piece.style.cssText = `
                width: ${actualW}px;
                height: ${actualH}px;
                background-image: url(${originalImage.src});
                background-size: ${size.width}px ${size.height}px;
                background-position: ${bgX}px ${bgY}px;
                background-repeat: no-repeat;
                clip-path: path('${path}');
                -webkit-clip-path: path('${path}');
                position: absolute;
                transform: translate(-${tab}px, -${tab}px);
            `;
            
            // æ‰‹æŒ‡åœ¨ container å…§çš„ä½ç½®ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
            const posInContainer = {
                x: (lastX - rect.left) / containerScale,
                y: (lastY - rect.top) / containerScale
            };
            
            // è¨ˆç®—åç§»ï¼ˆä½¿ç”¨æ–°çš„ tabï¼ŒæŒ‰æ¯”ä¾‹ç¸®æ”¾ï¼‰
            const offsetX = offsetInWrapperX * (pw / (wrapper.pw || pw));
            const offsetY = offsetInWrapperY * (ph / (wrapper.ph || ph));
            
            piece.style.left = (posInContainer.x - offsetX) + 'px';
            piece.style.top = (posInContainer.y - offsetY) + 'px';
            piece.style.zIndex = '1000';
            piece.classList.add('dragging');
            container.appendChild(piece);
            
            // æå‡ container z-index è®“æ‹¼åœ–é¡¯ç¤ºåœ¨ drawer ä¸Šæ–¹
            container.style.zIndex = '1000';
            
            currentPiece = piece;
            currentPiece.drawerWrapper = wrapper;
            // ä¿å­˜åç§»é‡ä¾›ç§»å‹•æ™‚ä½¿ç”¨
            currentPiece.offX = offsetX;
            currentPiece.offY = offsetY;
            
            if (navigator.vibrate) navigator.vibrate(10);
        }
        
        function handleDrawerTouchEnd() {
            clearTimeout(dragDelayTimer);
            dragDelayTimer = null;
            
            document.removeEventListener('touchmove', handleDrawerTouchMove);
            document.removeEventListener('touchend', handleDrawerTouchEnd);
            
            // æ¢å¾© container z-index
            document.getElementById('puzzleContainer').style.zIndex = '';
            
            if (!isDraggingFromDrawer) {
                touchStartInfo = null;
                return;
            }
            
            if (!currentPiece) {
                touchStartInfo = null;
                isDraggingFromDrawer = false;
                return;
            }
            
            const piece = currentPiece; // ä¿å­˜å¼•ç”¨
            piece.classList.remove('dragging');
            piece.style.zIndex = '';
            
            const left = parseInt(piece.style.left), top = parseInt(piece.style.top);
            
            // ä½ç½®æ­£ç¢ºå°±æ”¾ç½®ï¼Œä¸¦è‡ªå‹•è½‰æ­£
            if (Math.abs(left - piece.correctX) < 15 && Math.abs(top - piece.correctY) < 15) {
                piece.style.transition = 'transform 0.3s';
                piece.style.left = piece.correctX + 'px';
                piece.style.top = piece.correctY + 'px';
                // è‡ªå‹•è½‰æ­£ï¼ˆç§»é™¤æ—‹è½‰ï¼‰
                piece.style.transform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.currentRotation = 0;
                setTimeout(() => piece.style.transition = '', 300);
                piece.isPlaced = true;
                piece.drawerWrapper.classList.add('placed');
                const dp = drawerPieces.find(d => d.piece === piece);
                if (dp) dp.isPlaced = true;
                playSnapSound();
                if (navigator.vibrate) navigator.vibrate(20);
                updateDrawerCount();
                checkWin();
            } else {
                // æ‹–æ›³å¤±æ•— - æª¢æŸ¥æ˜¯å¦åœ¨ drawer å€å…§ï¼ˆæ•£äº‚æ¨¡å¼ä¸‹å¯é‡æ–°å®šä½ï¼‰
                const drawer = document.getElementById('puzzleDrawer');
                const drawerRect = drawer.getBoundingClientRect();
                const touchX = touchStartInfo.lastX;
                const touchY = touchStartInfo.lastY;
                
                // å¾ container ç§»é™¤ piece
                document.getElementById('puzzleContainer').removeChild(piece);
                // é‡ç½® piece çš„æ—‹è½‰ï¼ˆä¿æŒ drawer ä¸­çš„æ—‹è½‰ç‹€æ…‹ï¼‰
                const baseTransform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.style.transform = baseTransform;
                
                // æ•£äº‚æ¨¡å¼ä¸”åœ¨ drawer å€å…§ - ç§»å‹•åˆ°æ–°ä½ç½®
                if (scatterMode && 
                    touchX >= drawerRect.left && touchX <= drawerRect.right &&
                    touchY >= drawerRect.top && touchY <= drawerRect.bottom) {
                    
                    // ä½¿ç”¨ wrapper åç§»ï¼ˆä¸å« tab è£œå„Ÿï¼‰ï¼Œè®“æ”¾ä¸‹ä½ç½®èˆ‡æ‹–æ›³æ™‚ä¸€è‡´
                    const offsetX = touchStartInfo.wrapperOffsetX || piece.drawerWrapper.offsetWidth / 2;
                    const offsetY = touchStartInfo.wrapperOffsetY || piece.drawerWrapper.offsetHeight / 2;
                    const newX = touchX - drawerRect.left - offsetX;
                    const newY = touchY - drawerRect.top - offsetY;
                    piece.drawerWrapper.style.left = Math.max(0, newX) + 'px';
                    piece.drawerWrapper.style.top = Math.max(0, newY) + 'px';
                    piece.drawerWrapper.style.zIndex = drawerPieceZIndex++;
                }
                
                // é¡¯ç¤º drawer ä¸­çš„é è¦½åœ–å’Œé‚Šæ¡†
                if (piece.drawerWrapper.pieceDiv) {
                    piece.drawerWrapper.pieceDiv.style.visibility = 'visible';
                }
                if (piece.drawerWrapper.pieceSvg) {
                    piece.drawerWrapper.pieceSvg.style.visibility = 'visible';
                }
                piece.drawerWrapper.classList.remove('dragging');
            }
            
            currentPiece = null;
            touchStartInfo = null;
            isDraggingFromDrawer = false;
        }

        function checkWin() {
            if (drawerPieces.every(d => d.isPlaced)) {
                isPlaying = false;
                stopAutoSave();
                clearSave();
                playWinSound();
                if (navigator.vibrate) navigator.vibrate([100,50,100]);
                // å±•é–‹æ§åˆ¶é¢æ¿
                showControlsDrawer();
                setTimeout(() => showCompletionMessage(), 300);
            } else {
                // æ¯æ”¾ç½®ä¸€ç‰‡å°±å­˜æª”
                saveGame();
            }
        }
        
        // é¡¯ç¤ºç¾åŒ–çš„å®Œæˆè¨Šæ¯
        function showCompletionMessage() {
            const msg = document.createElement('div');
            msg.className = 'completion-message';
            msg.innerHTML = 'ğŸ‰ æ­å–œå®Œæˆæ‹¼åœ–ï¼';
            document.body.appendChild(msg);
            setTimeout(() => msg.classList.add('show'), 10);
            setTimeout(() => {
                msg.classList.remove('show');
                setTimeout(() => msg.remove(), 500);
            }, 3000);
        }
        
        // å±•é–‹æ§åˆ¶é¢æ¿
        function showControlsDrawer() {
            controlsCollapsed = false;
            document.getElementById('controlsDrawer').classList.remove('collapsed');
            document.getElementById('controlsToggle').textContent = 'â—€';
        }

        function autoComplete() {
            if (!isPlaying) return;
            const container = document.getElementById('puzzleContainer');
            const size = { width: parseFloat(container.style.width), height: parseFloat(container.style.height) };
            const pw = size.width / cols;
            const ph = size.height / rows;
            const tab = Math.min(pw, ph) * 0.15;
            
            drawerPieces.forEach((dp, i) => {
                if (!dp.isPlaced) {
                    setTimeout(() => {
                        const pieceRow = Math.floor((dp.piece.pieceNumber - 1) / cols);
                        const pieceCol = (dp.piece.pieceNumber - 1) % cols;
                        const correctX = pieceCol * pw;
                        const correctY = pieceRow * ph;
                        
                        // æ•£è½æ¨¡å¼ï¼šéœ€è¦é‡æ–°ç”Ÿæˆ piece æ¨£å¼
                        if (!trayMode) {
                            const bgX = -(pieceCol * pw) + tab;
                            const bgY = -(pieceRow * ph) + tab;
                            const path = generatePiecePath(pw, ph, dp.piece.edges);
                            const actualW = pw + 2 * tab;
                            const actualH = ph + 2 * tab;
                            
                            dp.piece.style.cssText = `
                                width: ${actualW}px;
                                height: ${actualH}px;
                                background-image: url(${originalImage.src});
                                background-size: ${size.width}px ${size.height}px;
                                background-position: ${bgX}px ${bgY}px;
                                background-repeat: no-repeat;
                                clip-path: path('${path}');
                                -webkit-clip-path: path('${path}');
                                position: absolute;
                                transform: translate(-${tab}px, -${tab}px);
                                left: ${correctX}px;
                                top: ${correctY}px;
                                transition: all 0.4s;
                            `;
                            dp.drawerItem.style.display = 'none';
                        } else {
                            // æ‰˜ç›¤æ¨¡å¼ï¼šéœ€è¦ç”¨åŸºç¤å®¹å™¨å¤§å°é‡æ–°ç”Ÿæˆ piece æ¨£å¼
                            const basePw = baseContainerWidth / cols;
                            const basePh = baseContainerHeight / rows;
                            const baseTab = Math.min(basePw, basePh) * 0.15;
                            const baseSize = { width: baseContainerWidth, height: baseContainerHeight };
                            const baseBgX = -(pieceCol * basePw) + baseTab;
                            const baseBgY = -(pieceRow * basePh) + baseTab;
                            const basePath = generatePiecePath(basePw, basePh, dp.piece.edges);
                            const baseActualW = basePw + 2 * baseTab;
                            const baseActualH = basePh + 2 * baseTab;
                            const baseCorrectX = pieceCol * basePw;
                            const baseCorrectY = pieceRow * basePh;
                            
                            dp.piece.style.cssText = `
                                width: ${baseActualW}px;
                                height: ${baseActualH}px;
                                background-image: url(${originalImage.src});
                                background-size: ${baseSize.width}px ${baseSize.height}px;
                                background-position: ${baseBgX}px ${baseBgY}px;
                                background-repeat: no-repeat;
                                clip-path: path('${basePath}');
                                -webkit-clip-path: path('${basePath}');
                                position: absolute;
                                transform: translate(-${baseTab}px, -${baseTab}px);
                                left: ${baseCorrectX}px;
                                top: ${baseCorrectY}px;
                                transition: all 0.4s;
                            `;
                            dp.piece.correctX = baseCorrectX;
                            dp.piece.correctY = baseCorrectY;
                            dp.drawerItem.classList.add('placed');
                            dp.drawerItem.style.display = 'none';
                        }
                        
                        dp.piece.currentRotation = 0;
                        dp.piece.isPlaced = true; 
                        dp.isPlaced = true;
                        if (dp.piece.parentElement !== container) container.appendChild(dp.piece);
                        updateDrawerCount();
                    }, i * 80);
                }
            });
            setTimeout(() => { 
                isPlaying = false;
                stopAutoSave();
                clearSave();
                playWinSound(); 
                showControlsDrawer();
                showCompletionMessage();
            }, drawerPieces.length * 80 + 500);
        }
        
        // èƒŒæ™¯é¡è‰²
        let bgColor = '#1a1a2e';
        
        function toggleColorPicker() {
            const popup = document.getElementById('colorPickerPopup');
            popup.classList.toggle('show');
        }
        
        function setBgColor(color) {
            bgColor = color;
            document.getElementById('gameArea').style.background = color;
            document.getElementById('colorPickerBtn').style.background = color;
            
            // æ›´æ–°é¸é …ç‹€æ…‹
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.color === color);
            });
            
            // é—œé–‰å½ˆçª—
            document.getElementById('colorPickerPopup').classList.remove('show');
        }
        
        // é»æ“Šå…¶ä»–åœ°æ–¹é—œé–‰é¡è‰²é¸æ“‡å™¨
        document.addEventListener('click', function(e) {
            const wrapper = document.querySelector('.color-picker-wrapper');
            if (wrapper && !wrapper.contains(e.target)) {
                document.getElementById('colorPickerPopup').classList.remove('show');
            }
        });

        // æç¤ºé–‹é—œ
        document.getElementById('toggleHint').addEventListener('change', function() {
            showHint = this.checked;
            // æ›´æ–°æ‹¼åœ–å€ç·¨è™Ÿ
            document.querySelectorAll('.piece-outline').forEach((o, idx) => {
                const n = o.querySelector('.piece-number');
                if (n) o.removeChild(n);
                if (showHint) {
                    const num = document.createElement('div');
                    num.className = 'piece-number';
                    num.textContent = Math.floor(idx/cols)*cols + (idx%cols) + 1;
                    o.appendChild(num);
                }
            });
        });
        
        // æ—‹è½‰é–‹é—œ
        document.getElementById('toggleRotation').addEventListener('change', function() {
            enableRotation = this.checked;
            // æ›´æ–°æœªæ”¾ç½®æ‹¼åœ–çš„æ—‹è½‰
            drawerPieces.forEach(dp => {
                if (!dp.isPlaced) {
                    const randomRotation = enableRotation ? Math.floor(Math.random() * 360) : 0;
                    dp.drawerItem.currentRotation = randomRotation;
                    dp.piece.currentRotation = randomRotation;
                    const div = dp.drawerItem.pieceDiv;
                    const svg = dp.drawerItem.pieceSvg;
                    const tab = dp.drawerItem.tab;
                    
                    if (trayMode) {
                        // æ‰˜ç›¤æ¨¡å¼ï¼šéœ€è¦ translate
                        if (div) {
                            div.style.transform = randomRotation !== 0 
                                ? `translate(-${tab}px,-${tab}px) rotate(${randomRotation}deg)` 
                                : `translate(-${tab}px,-${tab}px)`;
                        }
                    } else {
                        // æ•£è½æ¨¡å¼ï¼šä¸éœ€è¦ translate
                        if (div) {
                            div.style.transform = randomRotation !== 0 
                                ? `rotate(${randomRotation}deg)` : '';
                        }
                    }
                    if (svg) {
                        svg.style.transform = randomRotation !== 0 
                            ? `rotate(${randomRotation}deg)` : '';
                        svg.style.transformOrigin = 'center center';
                    }
                }
            });
        });
        
        // ç‰‡æ•¸æ”¹è®Šæ™‚é‡æ–°é–‹å§‹éŠæˆ²
        document.getElementById('pieceCount').addEventListener('change', function() {
            if (originalImage) {
                startGame();
            }
        });
        
        // ========== å­˜æª”åŠŸèƒ½ ==========
        
        // å„²å­˜éŠæˆ²ç‹€æ…‹
        function saveGame() {
            if (!isPlaying || !originalImage) return;
            
            try {
                const container = document.getElementById('puzzleContainer');
                
                const saveData = {
                    version: 4,
                    timestamp: Date.now(),
                    // åœ–ç‰‡è³‡æ–™
                    imageData: originalImage.src,
                    // éŠæˆ²è¨­å®š
                    pieceCount: parseInt(document.getElementById('pieceCount').value),
                    rows: rows,
                    cols: cols,
                    enableRotation: enableRotation,
                    scatterMode: scatterMode,
                    trayMode: trayMode,
                    showHint: showHint,
                    bgColor: bgColor,
                    // UI ç‹€æ…‹
                    drawerPosition: drawerPosition,
                    drawerSize: drawerSize,
                    controlsCollapsed: controlsCollapsed,
                    // æ ¼ç·šå€ç‹€æ…‹
                    containerScale: containerScale,
                    containerLeft: container.style.left,
                    containerTop: container.style.top,
                    // ä¸–ç•Œå¹³ç§»
                    worldOffsetX: worldOffset.x,
                    worldOffsetY: worldOffset.y,
                    // æ•£äº‚æ¨¡å¼ z-index è¨ˆæ•¸å™¨
                    drawerPieceZIndex: drawerPieceZIndex,
                    // æ‹¼åœ–ç‹€æ…‹
                    pieces: drawerPieces.map(dp => ({
                        index: dp.piece.pieceNumber - 1,
                        isPlaced: dp.isPlaced,
                        rotation: dp.piece.currentRotation || 0,
                        // ä½ç½®ï¼ˆæ‰˜ç›¤æˆ–æ•£è½æ¨¡å¼ï¼‰
                        itemLeft: dp.drawerItem.style.left,
                        itemTop: dp.drawerItem.style.top,
                        itemZIndex: dp.drawerItem.style.zIndex
                    }))
                };
                
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                console.log('éŠæˆ²å·²å„²å­˜');
            } catch (e) {
                console.error('å„²å­˜å¤±æ•—:', e);
            }
        }
        
        // è¼‰å…¥éŠæˆ²ç‹€æ…‹
        function loadGame() {
            try {
                const saved = localStorage.getItem(SAVE_KEY);
                if (!saved) return null;
                return JSON.parse(saved);
            } catch (e) {
                console.error('è¼‰å…¥å¤±æ•—:', e);
                return null;
            }
        }
        
        // æ¸…é™¤å­˜æª”
        function clearSave() {
            localStorage.removeItem(SAVE_KEY);
            console.log('å­˜æª”å·²æ¸…é™¤');
        }
        
        // å•Ÿå‹•è‡ªå‹•å­˜æª”
        function startAutoSave() {
            stopAutoSave();
            autoSaveTimer = setInterval(() => {
                // åªåœ¨æ²’æœ‰æ‹–æ›³æ™‚å­˜æª”
                if (!containerDrag.active && 
                    !isScatterDragging && !isScatterTouchDragging &&
                    !isMouseDragging && !isDraggingFromDrawer) {
                    saveGame();
                }
            }, 5000); // æ¯ 5 ç§’å­˜æª”
        }
        
        // åœæ­¢è‡ªå‹•å­˜æª”
        function stopAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        }
        
        // å¾å­˜æª”æ¢å¾©éŠæˆ²
        function restoreGame(saveData) {
            return new Promise((resolve, reject) => {
                try {
                    // è¨­å®šé¸é …
                    document.getElementById('pieceCount').value = saveData.pieceCount;
                    document.getElementById('toggleRotation').checked = saveData.enableRotation;
                    document.getElementById('toggleHint').checked = saveData.showHint;
                    // æ‰˜ç›¤æ¨¡å¼ï¼ˆå‘å¾Œå…¼å®¹èˆŠå­˜æª”ï¼‰
                    const savedTrayMode = saveData.trayMode !== undefined ? saveData.trayMode : true;
                    document.getElementById('toggleTray').checked = savedTrayMode;
                    trayMode = savedTrayMode;
                    
                    enableRotation = saveData.enableRotation;
                    scatterMode = saveData.scatterMode || false;
                    showHint = saveData.showHint;
                    drawerSize = saveData.drawerSize || 180;
                    
                    // æ¢å¾©èƒŒæ™¯é¡è‰²
                    if (saveData.bgColor) {
                        setBgColor(saveData.bgColor);
                    }
                    
                    // æ¢å¾©æ•£äº‚æŒ‰éˆ•ç‹€æ…‹
                    const scatterBtn = document.getElementById('scatterBtn');
                    if (scatterBtn) scatterBtn.classList.toggle('active', scatterMode);
                    
                    // æ¢å¾© drawer æ–¹å‘
                    if (saveData.drawerPosition) {
                        drawerPosition = saveData.drawerPosition;
                    }
                    
                    // æ¢å¾©æ§åˆ¶é¢æ¿ç‹€æ…‹
                    if (saveData.controlsCollapsed !== undefined) {
                        controlsCollapsed = saveData.controlsCollapsed;
                    }
                    
                    // æ¢å¾© z-index è¨ˆæ•¸å™¨
                    if (saveData.drawerPieceZIndex) {
                        drawerPieceZIndex = saveData.drawerPieceZIndex;
                    }
                    
                    // è¼‰å…¥åœ–ç‰‡
                    originalImage = new Image();
                    originalImage.onload = function() {
                        // é–‹å§‹éŠæˆ²ï¼ˆæœƒå»ºç«‹æ‹¼åœ–ï¼‰
                        startGameWithRestore(saveData);
                        resolve();
                    };
                    originalImage.onerror = function() {
                        reject(new Error('åœ–ç‰‡è¼‰å…¥å¤±æ•—'));
                    };
                    originalImage.src = saveData.imageData;
                } catch (e) {
                    reject(e);
                }
            });
        }
        
        // å¸¶æ¢å¾©çš„é–‹å§‹éŠæˆ²
        function startGameWithRestore(saveData) {
            // è‡¨æ™‚ä¿®æ”¹ï¼Œè®“ startGame å®Œæˆå¾Œæ¢å¾©ç‹€æ…‹
            const checkAndRestore = setInterval(() => {
                if (isPlaying && drawerPieces.length > 0) {
                    clearInterval(checkAndRestore);
                    
                    const container = document.getElementById('puzzleContainer');
                    const drawer = document.getElementById('puzzleDrawer');
                    
                    // æ¢å¾©æ ¼ç·šå€ç¸®æ”¾
                    if (saveData.containerScale !== undefined) {
                        containerScale = saveData.containerScale;
                        container.style.transform = `scale(${containerScale})`;
                    }
                    
                    // æ¢å¾©æ ¼ç·šå€ä½ç½®
                    if (saveData.containerLeft && saveData.containerTop) {
                        container.style.left = saveData.containerLeft;
                        container.style.top = saveData.containerTop;
                        // æ›´æ–°åŸå§‹ä½ç½®è¨˜éŒ„ï¼ˆç”¨æ–¼æ‹–æ›³è¨ˆç®—ï¼‰
                        containerOriginalPos = {
                            left: parseFloat(saveData.containerLeft),
                            top: parseFloat(saveData.containerTop)
                        };
                    }
                    
                    // æ¢å¾©ä¸–ç•Œå¹³ç§»
                    if (saveData.worldOffsetX !== undefined && saveData.worldOffsetY !== undefined) {
                        worldOffset.x = saveData.worldOffsetX;
                        worldOffset.y = saveData.worldOffsetY;
                        updateWorldPosition();
                    }
                    
                    // æ¢å¾©æ§åˆ¶é¢æ¿æ”¶åˆç‹€æ…‹
                    if (saveData.controlsCollapsed) {
                        controlsCollapsed = true;
                        document.getElementById('controlsDrawer').classList.add('collapsed');
                        document.getElementById('controlsToggle').textContent = 'â–¶';
                    }
                    
                    // æ¢å¾©æ¯å€‹æ‹¼åœ–çš„ç‹€æ…‹
                    saveData.pieces.forEach(savedPiece => {
                        const dp = drawerPieces.find(d => d.piece.pieceNumber - 1 === savedPiece.index);
                        if (!dp) return;
                        
                        // æ¢å¾©æ—‹è½‰ï¼ˆç„¡è«–æ˜¯å¦å·²æ”¾ç½®ï¼‰
                        if (savedPiece.rotation !== 0 && !savedPiece.isPlaced) {
                            dp.piece.currentRotation = savedPiece.rotation;
                            dp.drawerItem.currentRotation = savedPiece.rotation;
                            const div = dp.drawerItem.pieceDiv;
                            const svg = dp.drawerItem.pieceSvg;
                            const tab = dp.drawerItem.tab;
                            if (div) {
                                // æ‰˜ç›¤æ¨¡å¼éœ€è¦ translateï¼Œæ•£è½æ¨¡å¼ä¸éœ€è¦
                                if (trayMode) {
                                    div.style.transform = `translate(-${tab}px,-${tab}px) rotate(${savedPiece.rotation}deg)`;
                                } else {
                                    div.style.transform = `rotate(${savedPiece.rotation}deg)`;
                                }
                            }
                            if (svg) {
                                svg.style.transform = `rotate(${savedPiece.rotation}deg)`;
                                svg.style.transformOrigin = 'center center';
                            }
                        }
                        
                        // æ¢å¾©ä½ç½®
                        if (savedPiece.isPlaced) {
                            // å·²æ”¾ç½®çš„æ‹¼åœ–
                            dp.piece.style.left = dp.piece.correctX + 'px';
                            dp.piece.style.top = dp.piece.correctY + 'px';
                            dp.piece.style.transform = dp.piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                            dp.piece.currentRotation = 0;
                            dp.piece.isPlaced = true;
                            dp.isPlaced = true;
                            container.appendChild(dp.piece);
                            dp.drawerItem.classList.add('placed');
                            if (!trayMode) {
                                dp.drawerItem.style.display = 'none';
                            }
                        } else {
                            // æœªæ”¾ç½®çš„æ‹¼åœ– - æ¢å¾©ä½ç½®ï¼ˆæ”¯æ´æ–°èˆŠæ¬„ä½åï¼‰
                            const itemLeft = savedPiece.itemLeft || savedPiece.drawerLeft;
                            const itemTop = savedPiece.itemTop || savedPiece.drawerTop;
                            const itemZIndex = savedPiece.itemZIndex || savedPiece.drawerZIndex;
                            
                            if (itemLeft) {
                                dp.drawerItem.style.left = itemLeft;
                                dp.drawerItem.style.top = itemTop;
                                if (itemZIndex) {
                                    dp.drawerItem.style.zIndex = itemZIndex;
                                }
                            }
                        }
                    });
                    
                    updateDrawerCount();
                    
                    // æ•£è½æ¨¡å¼ï¼šæ›´æ–°è™›ç·šé‚Šæ¡†å’Œæ‹¼åœ–å¤§å°
                    if (!trayMode && saveData.containerScale !== undefined && saveData.containerScale !== 1) {
                        // æ›´æ–°è™›ç·šé‚Šæ¡†
                        showScatterBorder();
                        
                        // ä½¿ç”¨ updateScatterPiecesScale çš„æ–¹å¼ç¸®æ”¾æ‹¼åœ–
                        const scaleRatio = saveData.containerScale; // å¾ 1 ç¸®æ”¾åˆ°ç›®æ¨™å€¼
                        
                        drawerPieces.forEach(dp => {
                            if (dp.isPlaced) return;
                            const wrapper = dp.drawerItem;
                            if (!wrapper) return;
                            
                            const wrapperW = parseFloat(wrapper.style.width);
                            const wrapperH = parseFloat(wrapper.style.height);
                            
                            // ç¸®æ”¾å¤§å°
                            const newW = wrapperW * scaleRatio;
                            const newH = wrapperH * scaleRatio;
                            
                            wrapper.style.width = newW + 'px';
                            wrapper.style.height = newH + 'px';
                            
                            // æ›´æ–°å…§éƒ¨å°ºå¯¸
                            const basePw = baseContainerWidth / cols;
                            const basePh = baseContainerHeight / rows;
                            const baseTab = Math.min(basePw, basePh) * 0.15;
                            
                            const pw = basePw * scaleRatio;
                            const ph = basePh * scaleRatio;
                            const tab = baseTab * scaleRatio;
                            wrapper.pw = pw;
                            wrapper.ph = ph;
                            wrapper.tab = tab;
                            
                            // æ›´æ–° pieceDiv
                            const div = wrapper.pieceDiv;
                            if (div) {
                                const pieceRow = Math.floor((dp.piece.pieceNumber - 1) / cols);
                                const pieceCol = (dp.piece.pieceNumber - 1) % cols;
                                const size = { width: pw * cols, height: ph * rows };
                                const bgX = -(pieceCol * pw) + tab;
                                const bgY = -(pieceRow * ph) + tab;
                                const path = generatePiecePath(pw, ph, dp.piece.edges);
                                const rotation = wrapper.currentRotation || 0;
                                
                                div.style.width = newW + 'px';
                                div.style.height = newH + 'px';
                                div.style.backgroundSize = `${size.width}px ${size.height}px`;
                                div.style.backgroundPosition = `${bgX}px ${bgY}px`;
                                div.style.clipPath = `path('${path}')`;
                                div.style.webkitClipPath = `path('${path}')`;
                                div.style.transformOrigin = 'center center';
                                div.style.transform = rotation !== 0 ? `rotate(${rotation}deg)` : '';
                            }
                            
                            // æ›´æ–° SVG é‚Šæ¡†ï¼ˆèˆ‡ updateScatterPiecesScale ä¸€è‡´ï¼‰
                            const svg = wrapper.pieceSvg;
                            if (svg) {
                                const borderPath = generateCurvedPath(pw, ph, dp.piece.edges);
                                svg.setAttribute('width', newW);
                                svg.setAttribute('height', newH);
                                svg.innerHTML = `<path d="${borderPath}" fill="none" stroke="#000" stroke-width="1"/>`;
                                const rotation = wrapper.currentRotation || 0;
                                svg.style.transform = rotation !== 0 ? `rotate(${rotation}deg)` : '';
                            }
                        });
                    }
                    
                    startAutoSave();
                    console.log('éŠæˆ²å·²æ¢å¾©');
                }
            }, 100);
            
            startGame(true, true);  // skipConfirm = true, isRestoring = true
        }
        
        // é¡¯ç¤ºç¢ºèªæ–°éŠæˆ²å°è©±æ¡†
        function showConfirmNewGameDialog() {
            const placedCount = drawerPieces.filter(dp => dp.isPlaced).length;
            const totalCount = drawerPieces.length;
            
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.8); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #2a2a2a; border-radius: 12px; padding: 24px;
                max-width: 320px; text-align: center; color: white;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                <h3 style="margin: 0 0 12px; font-size: 18px;">ç¢ºå®šè¦é–‹å§‹æ–°éŠæˆ²ï¼Ÿ</h3>
                <p style="margin: 0 0 20px; color: #aaa; font-size: 14px;">
                    ç•¶å‰é€²åº¦ (${placedCount}/${totalCount} ç‰‡) å°‡æœƒéºå¤±
                </p>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="confirmYes" style="
                        padding: 12px 24px; border: none; border-radius: 8px;
                        background: #d9534f; color: white; font-size: 16px;
                        cursor: pointer;
                    ">é–‹å§‹æ–°éŠæˆ²</button>
                    <button id="confirmNo" style="
                        padding: 12px 24px; border: none; border-radius: 8px;
                        background: #555; color: white; font-size: 16px;
                        cursor: pointer;
                    ">å–æ¶ˆ</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            document.getElementById('confirmYes').onclick = () => {
                overlay.remove();
                startGame(true);  // skipConfirm = true
            };
            
            document.getElementById('confirmNo').onclick = () => {
                overlay.remove();
            };
        }
        
        // é¡¯ç¤ºæ¢å¾©å°è©±æ¡†
        function showRestoreDialog(saveData) {
            const date = new Date(saveData.timestamp);
            const timeStr = date.toLocaleString('zh-TW');
            const placedCount = saveData.pieces.filter(p => p.isPlaced).length;
            const totalCount = saveData.pieces.length;
            
            // å»ºç«‹å°è©±æ¡†
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.8); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #2a2a2a; border-radius: 12px; padding: 24px;
                max-width: 320px; text-align: center; color: white;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 16px;">ğŸ§©</div>
                <h3 style="margin: 0 0 12px; font-size: 18px;">ç™¼ç¾æœªå®Œæˆçš„æ‹¼åœ–</h3>
                <p style="margin: 0 0 8px; color: #aaa; font-size: 14px;">
                    ${saveData.cols}x${saveData.rows} (${totalCount}ç‰‡)
                </p>
                <p style="margin: 0 0 8px; color: #aaa; font-size: 14px;">
                    é€²åº¦ï¼š${placedCount}/${totalCount} ç‰‡
                </p>
                <p style="margin: 0 0 20px; color: #888; font-size: 12px;">
                    ${timeStr}
                </p>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="restoreYes" style="
                        padding: 12px 24px; border: none; border-radius: 8px;
                        background: #4a90d9; color: white; font-size: 16px;
                        cursor: pointer;
                    ">ç¹¼çºŒéŠæˆ²</button>
                    <button id="restoreNo" style="
                        padding: 12px 24px; border: none; border-radius: 8px;
                        background: #555; color: white; font-size: 16px;
                        cursor: pointer;
                    ">é‡æ–°é–‹å§‹</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // äº‹ä»¶è™•ç†
            document.getElementById('restoreYes').onclick = async () => {
                overlay.remove();
                try {
                    await restoreGame(saveData);
                } catch (e) {
                    console.error('æ¢å¾©å¤±æ•—:', e);
                    clearSave();
                    alert('æ¢å¾©å¤±æ•—ï¼Œè«‹é‡æ–°é–‹å§‹éŠæˆ²');
                }
            };
            
            document.getElementById('restoreNo').onclick = () => {
                overlay.remove();
                clearSave();
            };
        }
        
        // é é¢è¼‰å…¥æ™‚æª¢æŸ¥å­˜æª”
        window.addEventListener('load', () => {
            const saveData = loadGame();
            if (saveData && saveData.pieces && saveData.pieces.length > 0) {
                // æª¢æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„é€²åº¦
                const hasProgress = saveData.pieces.some(p => p.isPlaced);
                const allComplete = saveData.pieces.every(p => p.isPlaced);
                
                if (hasProgress && !allComplete) {
                    showRestoreDialog(saveData);
                } else {
                    // å…¨éƒ¨å®Œæˆæˆ–æ²’æœ‰é€²åº¦ï¼Œæ¸…é™¤å­˜æª”
                    clearSave();
                }
            }
        });
        
        // é é¢é—œé–‰å‰å„²å­˜
        window.addEventListener('beforeunload', () => {
            if (isPlaying) {
                saveGame();
            }
        });
        
        // é é¢éš±è—æ™‚å„²å­˜ï¼ˆæ‰‹æ©Ÿåˆ‡æ› appï¼‰
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden' && isPlaying) {
                saveGame();
            }
        });
    </script>
</body>
</html>
