<!DOCTYPE html>
<html>

<head>
    <title>Êõ≤Á∑öÊãºÂúñÈÅäÊà≤</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            height: 100vh;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }

        .game-area {
            width: 100%;
            height: 100%;
            background-color: #000000;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }

        .puzzle-container {
            position: absolute;
            background-color: #000000;
            box-sizing: border-box;
            /* ‰ΩçÁΩÆÁî± JS ÂãïÊÖãË®≠ÁΩÆ */
        }

        .puzzle-piece {
            position: absolute;
            cursor: move;
            transition: none;
            background-repeat: no-repeat;
            z-index: 1;
            touch-action: none;
        }

        .puzzle-piece.dragging {
            z-index: 1001;
            filter: brightness(1.1) drop-shadow(0 0 15px rgba(255, 255, 255, 0.3));
        }

        /* ÊéßÂà∂Èù¢ÊùøÊäΩÂ±ú - Â∞àÊ•≠Ê∑±Ëâ≤È¢®Ê†º */
        .controls-drawer {
            position: absolute;
            top: 0;
            left: 0;
            width: 200px;
            height: 100%;
            background: rgba(20, 20, 20, 0.95);
            border-right: 2px solid rgba(255, 215, 0, 0.6);
            box-shadow: 2px 0 15px rgba(0,0,0,0.5);
            z-index: 300;
            transition: transform 0.3s ease;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
            color: white;
        }
        .controls-drawer.collapsed {
            transform: translateX(-200px);
        }
        .controls-toggle {
            position: absolute;
            top: 50%;
            left: 200px;
            transform: translateY(-50%);
            width: 28px;
            height: 50px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-left: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 14px;
            color: white;
            z-index: 301;
            transition: left 0.3s ease;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }
        .controls-toggle:hover {
            background: rgba(40, 40, 40, 0.95);
        }
        .controls-drawer.collapsed + .controls-toggle {
            left: 0;
        }
        .controls-drawer h1 {
            margin: 0 0 12px 0;
            font-size: 1.2em;
            color: gold;
            text-align: center;
        }
        .controls-drawer .button {
            width: 100%;
            padding: 10px;
            margin: 4px 0;
            background: rgba(255, 215, 0, 0.2);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        .controls-drawer .button:hover {
            background: rgba(255, 215, 0, 0.3);
            border-color: gold;
        }
        .controls-drawer .button:active { 
            background: rgba(255, 215, 0, 0.4);
        }
        .controls-drawer select {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            background: rgba(40, 40, 40, 0.9);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
        }
        .controls-drawer select option {
            background: #222;
            color: white;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 6px 0;
            font-size: 13px;
            color: #ddd;
        }
        .checkbox-input { 
            width: 16px; 
            height: 16px;
            accent-color: gold;
        }

        /* ÊµÆÂãïÈ†êË¶ΩÂúñ */
        .floating-preview {
            position: absolute;
            top: 10px;
            right: 60px;
            width: 180px;
            background: rgba(0,0,0,0.85);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 200;
            cursor: move;
            user-select: none;
            touch-action: none;
            display: none;
        }
        .floating-preview.visible { display: block; }
        .floating-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(255,255,255,0.15);
            border-radius: 8px 8px 0 0;
            font-size: 11px;
            color: rgba(255,255,255,0.8);
        }
        .floating-preview-close {
            background: none;
            border: none;
            color: rgba(255,255,255,0.8);
            cursor: pointer;
            font-size: 14px;
            padding: 0 2px;
        }
        .floating-preview img {
            width: 100%;
            display: block;
            border-radius: 0 0 8px 8px;
        }
        .floating-preview-resize {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 18px;
            height: 18px;
            cursor: se-resize;
            background: linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.3) 50%);
            border-radius: 0 0 8px 0;
        }
        .show-preview-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 16px;
            cursor: pointer;
            z-index: 199;
            display: none;
        }
        .show-preview-btn.visible { display: block; }

        /* ÊãºÂúñÊäΩÂ±ú - Ê∑±ËóçËâ≤Ë™øËàáÊãºÂúñÂçÄÂçÄÈöî */
        .puzzle-drawer {
            position: absolute;
            background: linear-gradient(135deg, rgba(20, 30, 50, 0.95), rgba(30, 40, 60, 0.95));
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            overflow: auto;
            z-index: 100;
            padding: 10px;
            gap: 8px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        .puzzle-drawer.drawer-bottom { bottom: 0; left: 0; right: 0; height: 180px; border-top: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-top { top: 0; left: 0; right: 0; height: 180px; border-bottom: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-left { top: 0; left: 0; bottom: 0; width: 180px; border-right: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-right { top: 0; right: 0; bottom: 0; width: 180px; border-left: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-none { display: none; }

        .drawer-piece-wrapper {
            position: relative;
            cursor: grab;
            flex-shrink: 0;
            margin: 9px;
        }
        .drawer-piece-wrapper.dragging { opacity: 0.3; }
        .drawer-piece-wrapper.placed { display: none; }
        
        .drawer-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 14px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
            pointer-events: none;
        }
        
        .drawer-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: gold;
            font-size: 16px;
            font-weight: bold;
            padding: 4px 10px;
            border-radius: 6px;
            border: 2px solid gold;
            pointer-events: none;
            animation: hintFade 3s ease-out forwards;
        }
        
        @keyframes hintFade {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        .drawer-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 4px;
            z-index: 101;
        }
        .drawer-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 12px;
            cursor: pointer;
        }
        .drawer-btn:hover { background: rgba(0,0,0,0.9); }
        .drawer-btn.active { background: rgba(74,144,217,0.8); border-color: #4a90d9; }
        .drawer-btn.shuffle-btn { background: rgba(0,0,0,0.7); }
        .drawer-btn.shuffle-btn:hover { background: rgba(0,0,0,0.9); }
        
        /* ÂÆåÊàêË®äÊÅØ */
        .completion-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(0,0,0,0.9);
            color: white;
            font-size: 28px;
            font-weight: bold;
            padding: 30px 50px;
            border-radius: 20px;
            border: 3px solid gold;
            z-index: 9999;
            opacity: 0;
            transition: all 0.3s ease;
            text-align: center;
        }
        .completion-message.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        /* ËºâÂÖ•ÈÄ≤Â∫¶ */
        .progress-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .progress-text {
            color: gold;
            font-size: 20px;
            margin-bottom: 20px;
        }
        .progress-bar {
            width: 250px;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid gold;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, gold, orange);
            width: 0%;
            transition: width 0.1s;
        }
        
        .drawer-count {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 12px;
            z-index: 101;
        }

        .piece-outline { pointer-events: none; }
        .piece-number {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            pointer-events: none;
        }

        /* Èï∑ÊåâÈ†êË¶Ω */
        .preview-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .preview-overlay.show { display: flex; }
        .preview-overlay img { max-width: 90%; max-height: 90%; }
    </style>
</head>

<body>
    <div class="game-area" id="gameArea">
        <div id="puzzleContainer" class="puzzle-container"></div>
        
        <!-- ÊéßÂà∂Èù¢ÊùøÊäΩÂ±ú -->
        <div class="controls-drawer" id="controlsDrawer">
            <h1>üß© ÊãºÂúñÈÅäÊà≤</h1>
            <input type="file" id="imageInput" accept="image/*" style="display:none;">
            <button class="button" onclick="selectImage()">üì∑ ÈÅ∏ÊìáÂúñÁâá</button>
            <select id="pieceCount">
                <option value="16">4x4 (16Áâá)</option>
                <option value="25">5x5 (25Áâá)</option>
                <option value="36">6x6 (36Áâá)</option>
                <option value="49">7x7 (49Áâá)</option>
                <option value="64">8x8 (64Áâá)</option>
                <option value="81">9x9 (81Áâá)</option>
                <option value="100">10x10 (100Áâá)</option>
                <option value="121">11x11 (121Áâá)</option>
                <option value="144">12x12 (144Áâá)</option>
            </select>
            <button class="button" onclick="startGame()">‚ñ∂ ÈñãÂßãÈÅäÊà≤</button>
            <button class="button" onclick="autoComplete()">‚ú® Ëá™ÂãïÂÆåÊàê</button>
            <div class="checkbox-container">
                <input type="checkbox" id="toggleHint" class="checkbox-input">
                <label for="toggleHint" class="checkbox-label">ÊèêÁ§∫</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="toggleRotation" class="checkbox-input">
                <label for="toggleRotation" class="checkbox-label">ÊóãËΩâ</label>
            </div>
            <div style="margin-top:10px; font-size:10px; color:#aaa;">üí° Èï∑ÊåâÁ©∫ÁôΩËôïÊü•ÁúãÂéüÂúñ</div>
        </div>
        <button class="controls-toggle" id="controlsToggle" onclick="toggleControls()">‚óÄ</button>
        
        <!-- ÊµÆÂãïÈ†êË¶ΩÂúñ -->
        <div class="floating-preview" id="floatingPreview">
            <div class="floating-preview-header">
                <span>üì∑ È†êË¶Ω</span>
                <button class="floating-preview-close" onclick="hidePreview()">‚úï</button>
            </div>
            <img id="previewImg" src="">
            <div class="floating-preview-resize" id="previewResize"></div>
        </div>
        <button class="show-preview-btn" id="showPreviewBtn" onclick="showPreview()">üñº</button>
        
        <!-- ÊäΩÂ±úÊéßÂà∂ -->
        <div class="drawer-count" id="drawerCount">Ââ©È§ò: 0 Â°ä</div>
        <div class="drawer-controls">
            <button class="drawer-btn" onclick="setDrawerPosition('top')">‚¨Ü</button>
            <button class="drawer-btn active" onclick="setDrawerPosition('bottom')">‚¨á</button>
            <button class="drawer-btn" onclick="setDrawerPosition('left')">‚¨Ö</button>
            <button class="drawer-btn" onclick="setDrawerPosition('right')">‚û°</button>
            <button class="drawer-btn" onclick="setDrawerPosition('none')">‚úï</button>
            <button class="drawer-btn shuffle-btn" onclick="shuffleDrawer()">üîÄ</button>
        </div>
        
        <!-- ÊãºÂúñÊäΩÂ±ú -->
        <div class="puzzle-drawer drawer-bottom" id="puzzleDrawer"></div>
    </div>

    <div class="preview-overlay" id="previewOverlay">
        <img id="previewOverlayImg" src="">
    </div>

    <script>
        // ÂÖ®Â±ÄËÆäÈáè
        let originalImage = null;
        let pieces = [];
        let currentPiece = null;
        let isPlaying = false;
        let edges = null;
        let showHint = false;
        let enableRotation = false;
        let rows, cols;
        let drawerPosition = 'bottom';
        let drawerPieces = [];
        let audioContext = null;
        let controlsCollapsed = false;

        // ÈÅ∏ÊìáÂúñÁâá
        function selectImage() {
            document.getElementById('imageInput').click();
        }

        // ÊéßÂà∂Èù¢ÊùøÊî∂Âêà
        function toggleControls() {
            controlsCollapsed = !controlsCollapsed;
            document.getElementById('controlsDrawer').classList.toggle('collapsed', controlsCollapsed);
            document.getElementById('controlsToggle').textContent = controlsCollapsed ? '‚ñ∂' : '‚óÄ';
        }

        // ÊµÆÂãïÈ†êË¶ΩÊãñÊõ≥ËàáÁ∏ÆÊîæ
        let previewDrag = { active: false, x: 0, y: 0 };
        let previewResize = { active: false, w: 0 };

        function showPreview() {
            document.getElementById('floatingPreview').classList.add('visible');
            document.getElementById('showPreviewBtn').classList.remove('visible');
        }
        
        function hidePreview() {
            document.getElementById('floatingPreview').classList.remove('visible');
            document.getElementById('showPreviewBtn').classList.add('visible');
        }

        // È†êË¶ΩÊãñÊõ≥
        document.getElementById('floatingPreview').addEventListener('mousedown', function(e) {
            if (e.target.closest('.floating-preview-close') || e.target.closest('.floating-preview-resize')) return;
            previewDrag.active = true;
            const rect = this.getBoundingClientRect();
            previewDrag.x = e.clientX - rect.left;
            previewDrag.y = e.clientY - rect.top;
            e.preventDefault();
        });
        
        document.getElementById('floatingPreview').addEventListener('touchstart', function(e) {
            if (e.target.closest('.floating-preview-close') || e.target.closest('.floating-preview-resize')) return;
            previewDrag.active = true;
            const rect = this.getBoundingClientRect();
            const t = e.touches[0];
            previewDrag.x = t.clientX - rect.left;
            previewDrag.y = t.clientY - rect.top;
            e.preventDefault();
        }, {passive: false});

        document.addEventListener('mousemove', function(e) {
            if (previewDrag.active) {
                const fp = document.getElementById('floatingPreview');
                fp.style.left = (e.clientX - previewDrag.x) + 'px';
                fp.style.top = (e.clientY - previewDrag.y) + 'px';
                fp.style.right = 'auto';
            }
            if (previewResize.active) {
                const fp = document.getElementById('floatingPreview');
                const w = Math.max(80, Math.min(300, e.clientX - fp.getBoundingClientRect().left));
                fp.style.width = w + 'px';
            }
        });
        
        document.addEventListener('touchmove', function(e) {
            if (previewDrag.active) {
                const t = e.touches[0];
                const fp = document.getElementById('floatingPreview');
                fp.style.left = (t.clientX - previewDrag.x) + 'px';
                fp.style.top = (t.clientY - previewDrag.y) + 'px';
                fp.style.right = 'auto';
            }
            if (previewResize.active) {
                const t = e.touches[0];
                const fp = document.getElementById('floatingPreview');
                const w = Math.max(80, Math.min(300, t.clientX - fp.getBoundingClientRect().left));
                fp.style.width = w + 'px';
            }
        }, {passive: false});

        document.addEventListener('mouseup', function() { previewDrag.active = false; previewResize.active = false; });
        document.addEventListener('touchend', function() { previewDrag.active = false; previewResize.active = false; });

        // È†êË¶ΩÁ∏ÆÊîæ
        document.getElementById('previewResize').addEventListener('mousedown', function(e) {
            previewResize.active = true;
            e.preventDefault();
            e.stopPropagation();
        });
        document.getElementById('previewResize').addEventListener('touchstart', function(e) {
            previewResize.active = true;
            e.preventDefault();
            e.stopPropagation();
        }, {passive: false});

        // Èü≥Êïà
        function playSnapSound() {
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain); gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(880, audioContext.currentTime);
                osc.frequency.setValueAtTime(1175, audioContext.currentTime + 0.05);
                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                osc.start(); osc.stop(audioContext.currentTime + 0.15);
            } catch(e) {}
        }
        
        function playWinSound() {
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                [523, 659, 784, 1047].forEach((f, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain); gain.connect(audioContext.destination);
                    osc.frequency.setValueAtTime(f, audioContext.currentTime);
                    const t = audioContext.currentTime + i * 0.12;
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.3, t + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                    osc.start(t); osc.stop(t + 0.3);
                });
            } catch(e) {}
        }

        // ÊäΩÂ±úÊéßÂà∂
        function setDrawerPosition(pos) {
            drawerPosition = pos;
            document.getElementById('puzzleDrawer').className = 'puzzle-drawer drawer-' + pos;
            document.querySelectorAll('.drawer-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            // Âè™Êõ¥Êñ∞‰ΩçÁΩÆÔºå‰∏çÊîπËÆäÂ§ßÂ∞è
            if (originalImage && isPlaying) {
                const container = document.getElementById('puzzleContainer');
                const w = parseFloat(container.style.width);
                const h = parseFloat(container.style.height);
                const pos = calculateContainerPosition(w, h);
                container.style.left = pos.left + 'px';
                container.style.top = pos.top + 'px';
            }
        }
        
        function updateDrawerCount() {
            document.getElementById('drawerCount').textContent = 'Ââ©È§ò: ' + drawerPieces.filter(d => !d.isPlaced).length + ' Â°ä';
        }
        
        function shuffleDrawer() {
            const drawer = document.getElementById('puzzleDrawer');
            const items = Array.from(drawer.children);
            for (let i = items.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                drawer.appendChild(items[j]);
            }
        }
        
        function updateDrawerLabels() {
            // Âè™Êõ¥Êñ∞ÁãÄÊÖãÔºå‰∏çÊ∑ªÂä†Ê∞∏‰πÖÊ®ôÁ±§
            // ÂãæÈÅ∏ÂæåÈªûÊìäÊãºÂúñÊúÉÈ°ØÁ§∫ 3 ÁßíÊèêÁ§∫
        }

        // Èï∑ÊåâÈ†êË¶Ω
        let longPressTimer = null;
        
        function showFullPreview() {
            if (!originalImage) return;
            document.getElementById('previewOverlayImg').src = originalImage.src;
            document.getElementById('previewOverlay').classList.add('show');
            if (navigator.vibrate) navigator.vibrate(30);
        }
        
        function hideFullPreview() {
            document.getElementById('previewOverlay').classList.remove('show');
        }
        
        document.getElementById('gameArea').addEventListener('touchstart', function(e) {
            if (e.target.closest('.drawer-piece-wrapper') || e.target.closest('.drawer-btn') || 
                e.target.closest('.puzzle-drawer') || e.target.closest('.controls-drawer') ||
                e.target.closest('.controls-toggle') || e.target.closest('.floating-preview')) return;
            longPressTimer = setTimeout(showFullPreview, 500);
        }, {passive: true});
        
        document.getElementById('gameArea').addEventListener('touchend', function() {
            clearTimeout(longPressTimer); hideFullPreview();
        }, {passive: true});
        
        document.getElementById('gameArea').addEventListener('touchmove', function() {
            clearTimeout(longPressTimer);
        }, {passive: true});
        
        document.getElementById('previewOverlay').addEventListener('click', hideFullPreview);

        // ÊãºÂúñË∑ØÂæëÁîüÊàê - Ê®ôÊ∫ñÁâàÊú¨
        function generateCurvedPath(width, height, edges) {
            const { top, right, bottom, left } = edges;
            const tabHeight = Math.min(width, height) * 0.15;
            const tabWidth = Math.min(width, height) * 0.5;

            let path = `M ${tabHeight},${tabHeight}`;
            
            // Top
            if (top === 'tab') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${(width-tabWidth)/2}`;
            else if (top === 'slot') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${(width-tabWidth)/2}`;
            else path += ` h ${width}`;
            
            // Right
            if (right === 'tab') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else if (right === 'slot') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else path += ` v ${height}`;
            
            // Bottom
            if (bottom === 'tab') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${(width-tabWidth)/2}`;
            else if (bottom === 'slot') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${(width-tabWidth)/2}`;
            else path += ` h -${width}`;
            
            // Left
            if (left === 'tab') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else if (left === 'slot') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else path += ` v -${height}`;
            
            return path + ' Z';
        }

        function generateEdges(rows, cols) {
            const p = Array(rows).fill().map(() => Array(cols).fill().map(() => ({top:null,right:null,bottom:null,left:null})));
            for (let i = 0; i < rows-1; i++) for (let j = 0; j < cols; j++) { const t = Math.random() < 0.5; p[i][j].bottom = t ? 'tab' : 'slot'; p[i+1][j].top = t ? 'slot' : 'tab'; }
            for (let i = 0; i < rows; i++) for (let j = 0; j < cols-1; j++) { const t = Math.random() < 0.5; p[i][j].right = t ? 'tab' : 'slot'; p[i][j+1].left = t ? 'slot' : 'tab'; }
            return p;
        }

        // ÂúñÁâáËºâÂÖ•
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(ev) { loadImage(ev.target.result); };
                reader.readAsDataURL(file);
            }
            e.target.value = '';
        });

        function loadImage(src) {
            originalImage = new Image();
            originalImage.onload = function() {
                document.getElementById('previewImg').src = src;
                showPreview();
                startGame();
            };
            originalImage.src = src;
        }

        // Ë®àÁÆóÊãºÂúñÂçÄÂ§ßÂ∞èÔºàÂè™Âú®ÈñãÂßãÈÅäÊà≤ÊôÇË™øÁî®‰∏ÄÊ¨°Ôºâ
        // ‰ΩøÁî®ÊúÄÂ∞èÂèØÁî®Á©∫ÈñìÔºåÁ¢∫‰øù drawer Âú®‰ªª‰Ωï‰ΩçÁΩÆÈÉΩ‰∏çÊúÉË∂ÖÂá∫
        function calculateContainerSize() {
            const gameArea = document.querySelector('.game-area');
            const totalWidth = gameArea.offsetWidth;
            const totalHeight = gameArea.offsetHeight;
            
            const drawerSize = 180;
            const tabMargin = 10; // È†êÁïô tab Á™ÅÂá∫Á©∫ÈñìÔºàÊúÄÂ∞èÂåñÔºâ
            
            // ÂêåÊôÇÈ†êÁïô‰∏ä‰∏ãÂíåÂ∑¶Âè≥ÁöÑ drawer Á©∫ÈñìÔºåÂèñÊúÄÂ∞èÂèØÁî®ÂçÄÂüü
            // ÈÄôÊ®£ÁÑ°Ë´ñ drawer Âú®Âì™ÂÄãÊñπÂêëÔºåÊãºÂúñÂçÄÈÉΩËÉΩÂÆåÊï¥È°ØÁ§∫
            const availableWidth = totalWidth - drawerSize - tabMargin * 2;
            const availableHeight = totalHeight - drawerSize - tabMargin * 2;
            
            // Ê†πÊìöÂúñÁâáÊØî‰æãË®àÁÆóÊãºÂúñÂçÄÂ§ßÂ∞è
            const ratio = originalImage.width / originalImage.height;
            let w, h;
            if (availableWidth / availableHeight > ratio) {
                h = availableHeight;
                w = h * ratio;
            } else {
                w = availableWidth;
                h = w / ratio;
            }
            
            return { width: w, height: h };
        }
        
        // Ë®àÁÆóÊãºÂúñÂçÄ‰ΩçÁΩÆÔºàÂàáÊèõÊäΩÂ±úÊñπÂêëÊôÇË™øÁî®Ôºâ
        function calculateContainerPosition(containerWidth, containerHeight) {
            const gameArea = document.querySelector('.game-area');
            const totalWidth = gameArea.offsetWidth;
            const totalHeight = gameArea.offsetHeight;
            
            const drawerSize = 180;
            
            // Ë®àÁÆóÂèØÁî®ÂçÄÂüüÁöÑÈÇäÁïå
            let left = 0, top = 0;
            let right = totalWidth;
            let bottom = totalHeight;
            
            // Ê†πÊìöÊäΩÂ±ú‰ΩçÁΩÆË™øÊï¥ÈÇäÁïå
            if (drawerPosition === 'left') left = drawerSize;
            else if (drawerPosition === 'right') right = totalWidth - drawerSize;
            else if (drawerPosition === 'top') top = drawerSize;
            else if (drawerPosition === 'bottom') bottom = totalHeight - drawerSize;
            
            const availableWidth = right - left;
            const availableHeight = bottom - top;
            
            // Ë®àÁÆóÁΩÆ‰∏≠‰ΩçÁΩÆ
            const centerX = left + (availableWidth - containerWidth) / 2;
            const centerY = top + (availableHeight - containerHeight) / 2;
            
            return { left: centerX, top: centerY };
        }

        // ÂâµÂª∫ÊãºÂúñÂ°ä - ÂúñÁâáÂÖßÁ∏ÆÔºåËÆìÈÇäÁ∑£ÊãºÂúñÊúâÂª∂‰º∏Á©∫Èñì
        function createPuzzlePiece(i, j, pw, ph, size, ed) {
            const piece = document.createElement('div');
            piece.className = 'puzzle-piece';
            const tab = Math.min(pw, ph) * 0.15;
            
            // ÈÇäÁ∑£ÊãºÂúñ‰ΩøÁî®Âª∂‰º∏Ë∑ØÂæë
            const path = generatePiecePath(pw, ph, ed);
            
            const actualW = pw + 2*tab;
            const actualH = ph + 2*tab;
            
            // ÂúñÁâáÂÖßÁ∏ÆÔºöËÆìÂúñÁâáÂæû tab ‰ΩçÁΩÆÈñãÂßãÔºåÂõõÂë®ÁïôÂá∫ tab Á©∫Èñì
            // ËÉåÊôØÂúñÂ§ßÂ∞è‰∏çËÆäÔºå‰ΩÜ‰ΩçÁΩÆÂæÄÂÖßÂÅèÁßª tab
            const bgX = -(j * pw) + tab;
            const bgY = -(i * ph) + tab;
            
            piece.style.cssText = `width:${actualW}px; height:${actualH}px; background-image:url(${originalImage.src}); background-size:${size.width}px ${size.height}px; background-position:${bgX}px ${bgY}px; clip-path:path('${path}'); -webkit-clip-path:path('${path}'); position:absolute; transform:translate(-${tab}px,-${tab}px);`;
            piece.correctX = j * pw;
            piece.correctY = i * ph;
            piece.pieceNumber = i * cols + j + 1;
            piece.isPlaced = false;
            return piece;
        }
        
        // ÊãºÂúñÂ°äË∑ØÂæë - Âπ≥Áõ¥ÈÇäÂª∂‰º∏Âà∞ tab ‰ΩçÁΩÆ
        function generatePiecePath(width, height, edges) {
            const { top, right, bottom, left } = edges;
            const tabHeight = Math.min(width, height) * 0.15;
            const tabWidth = Math.min(width, height) * 0.5;

            let path = `M ${tabHeight},${tabHeight}`;
            
            // Top
            if (top === 'tab') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${(width-tabWidth)/2}`;
            else if (top === 'slot') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${(width-tabWidth)/2}`;
            else path += ` v -${tabHeight} h ${width} v ${tabHeight}`;
            
            // Right
            if (right === 'tab') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else if (right === 'slot') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else path += ` h ${tabHeight} v ${height} h -${tabHeight}`;
            
            // Bottom
            if (bottom === 'tab') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${(width-tabWidth)/2}`;
            else if (bottom === 'slot') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${(width-tabWidth)/2}`;
            else path += ` v ${tabHeight} h -${width} v -${tabHeight}`;
            
            // Left
            if (left === 'tab') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else if (left === 'slot') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else path += ` h -${tabHeight} v -${height} h ${tabHeight}`;
            
            return path + ' Z';
        }

        // Ëº™ÂªìÁ∑ö - ‰ΩøÁî®ËàáÊãºÂúñÂ°äÁõ∏ÂêåÁöÑË∑ØÂæë
        function createPieceOutline(i, j, pw, ph, size, ed) {
            const outline = document.createElement('div');
            outline.className = 'piece-outline';
            const tab = Math.min(pw, ph) * 0.15;
            // Ê†ºÁ∑ö‰ΩøÁî® generateCurvedPathÔºà‰∏çÂª∂‰º∏Âπ≥Áõ¥ÈÇäÔºâ
            const path = generateCurvedPath(pw, ph, ed);
            
            const svgW = pw + 2*tab;
            const svgH = ph + 2*tab;
            
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", svgW); 
            svg.setAttribute("height", svgH);
            const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
            p.setAttribute("d", path); 
            p.setAttribute("fill", "none"); 
            p.setAttribute("stroke", "rgba(255,255,255,0.35)"); 
            p.setAttribute("stroke-width", "1");
            p.setAttribute("stroke-linejoin", "round");
            p.setAttribute("stroke-linecap", "round");
            svg.appendChild(p); 
            outline.appendChild(svg);
            outline.style.cssText = `position:absolute; left:${j*pw}px; top:${i*ph}px; pointer-events:none; z-index:0; transform:translate(-${tab}px,-${tab}px);`;
            if (showHint) { 
                const n = document.createElement('div'); 
                n.className = 'piece-number'; 
                n.textContent = i*cols+j+1; 
                outline.appendChild(n); 
            }
            return outline;
        }

        function createDrawerItem(piece, pw, ph, tab) {
            const wrapper = document.createElement('div');
            wrapper.className = 'drawer-piece-wrapper';
            wrapper.style.cssText = `width:${pw+2*tab}px; height:${ph+2*tab}px;`;
            const div = document.createElement('div');
            div.style.cssText = `width:${pw+2*tab}px; height:${ph+2*tab}px; background-image:${piece.style.backgroundImage}; background-size:${piece.style.backgroundSize}; background-position:${piece.style.backgroundPosition}; clip-path:${piece.style.clipPath}; -webkit-clip-path:${piece.style.webkitClipPath}; transform:${piece.style.transform};`;
            wrapper.appendChild(div);
            
            // Èö®Ê©üÊóãËΩâÔºàÂ¶ÇÊûúÂïüÁî®Ôºâ
            const randomRotation = enableRotation ? [0, 90, 180, 270][Math.floor(Math.random() * 4)] : 0;
            wrapper.currentRotation = randomRotation;
            piece.currentRotation = randomRotation;
            if (randomRotation !== 0) {
                div.style.transform = `${piece.style.transform} rotate(${randomRotation}deg)`;
            }
            
            // ÂÑ≤Â≠òÁ∑®Ëôü‰æõÊèêÁ§∫Áî®
            wrapper.pieceNumber = piece.pieceNumber;
            wrapper.pieceRef = piece;
            wrapper.pieceDiv = div;
            wrapper.addEventListener('mousedown', startDragFromDrawer);
            wrapper.addEventListener('touchstart', startTouchFromDrawer, {passive: true});
            return wrapper;
        }
        
        // È°ØÁ§∫ÊäΩÂ±úÊãºÂúñÁ∑®ËôüÊèêÁ§∫
        function showDrawerHint(wrapper) {
            if (!showHint) return;
            if (!wrapper || wrapper.classList.contains('placed')) return;
            
            // ÁßªÈô§Â∑≤Â≠òÂú®ÁöÑÊèêÁ§∫
            const existing = wrapper.querySelector('.drawer-hint');
            if (existing) existing.remove();
            
            // ÂâµÂª∫ÊèêÁ§∫
            const hint = document.createElement('div');
            hint.className = 'drawer-hint';
            hint.textContent = wrapper.pieceNumber;
            wrapper.appendChild(hint);
            
            // 3 ÁßíÂæåÁßªÈô§
            setTimeout(() => hint.remove(), 3000);
        }

        // ÈñãÂßãÈÅäÊà≤
        function startGame() {
            if (!originalImage) { alert('Ë´ãÂÖàÈÅ∏ÊìáÂúñÁâáÔºÅ'); return; }
            
            // È°ØÁ§∫ÈÄ≤Â∫¶
            const progressOverlay = document.createElement('div');
            progressOverlay.className = 'progress-overlay';
            progressOverlay.innerHTML = `
                <div class="progress-text" id="progressText">Ê∫ñÂÇô‰∏≠...</div>
                <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
            `;
            document.body.appendChild(progressOverlay);
            
            // ‰ΩøÁî® async ËÆì UI ÊúâÊ©üÊúÉÊõ¥Êñ∞
            const updateProgress = (percent, text) => {
                return new Promise(resolve => {
                    document.getElementById('progressFill').style.width = percent + '%';
                    if (text) document.getElementById('progressText').textContent = text;
                    requestAnimationFrame(() => requestAnimationFrame(resolve));
                });
            };
            
            (async () => {
                await updateProgress(10, 'ÂàùÂßãÂåñ...');
                
                const container = document.getElementById('puzzleContainer');
                const drawer = document.getElementById('puzzleDrawer');
                container.innerHTML = ''; drawer.innerHTML = '';
                pieces = []; drawerPieces = []; isPlaying = true;

                const size = calculateContainerSize();
                const count = parseInt(document.getElementById('pieceCount').value);
                rows = cols = Math.sqrt(count);
                
                const pw = size.width / cols;
                const ph = size.height / rows;
                const tab = Math.min(pw, ph) * 0.15;
                
                const pos = calculateContainerPosition(size.width, size.height);

                container.style.width = size.width + 'px';
                container.style.height = size.height + 'px';
                container.style.left = pos.left + 'px';
                container.style.top = pos.top + 'px';

                const outlines = document.createElement('div');
                outlines.className = 'outlines-container';
                outlines.style.cssText = 'position:absolute;z-index:0;left:0;top:0;';
                container.appendChild(outlines);

                edges = generateEdges(rows, cols);
                
                await updateProgress(30, 'Áπ™Ë£ΩÊ†ºÁ∑ö...');
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        outlines.appendChild(createPieceOutline(i, j, pw, ph, size, edges[i][j]));
                    }
                }

                await updateProgress(50, 'ÂàáÂâ≤ÊãºÂúñ...');

                let temp = [];
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        temp.push(createPuzzlePiece(i, j, pw, ph, size, edges[i][j]));
                    }
                    await updateProgress(50 + Math.floor((i / rows) * 30), 'ÂàáÂâ≤ÊãºÂúñ...');
                }
                
                for (let i = temp.length - 1; i > 0; i--) { 
                    const j = Math.floor(Math.random() * (i + 1)); 
                    [temp[i], temp[j]] = [temp[j], temp[i]]; 
                }
                
                await updateProgress(85, 'Êâì‰∫ÇÈ†ÜÂ∫è...');
                
                temp.forEach(piece => {
                    const item = createDrawerItem(piece, pw, ph, tab);
                    drawer.appendChild(item);
                    drawerPieces.push({piece, drawerItem: item, isPlaced: false});
                    pieces.push(piece);
                });
                
                updateDrawerCount();
                
                await updateProgress(100, 'ÂÆåÊàêÔºÅ');
                setTimeout(() => progressOverlay.remove(), 300);
            })();
        }

        // ÂæûÊäΩÂ±úÊãñÊõ≥ (ÊªëÈº†)
        function startDragFromDrawer(e) {
            if (!isPlaying) return;
            e.preventDefault();
            const wrapper = this, piece = wrapper.pieceRef;
            if (!piece || piece.isPlaced) return;
            
            wrapper.classList.add('dragging');
            const container = document.getElementById('puzzleContainer');
            const rect = container.getBoundingClientRect();
            
            piece.style.left = (e.clientX - rect.left - piece.offsetWidth/2) + 'px';
            piece.style.top = (e.clientY - rect.top - piece.offsetHeight/2) + 'px';
            piece.style.zIndex = '1000';
            piece.classList.add('dragging');
            container.appendChild(piece);
            
            currentPiece = piece;
            currentPiece.drawerWrapper = wrapper;
            currentPiece.offX = piece.offsetWidth/2;
            currentPiece.offY = piece.offsetHeight/2;
            
            document.addEventListener('mousemove', dragFromDrawer);
            document.addEventListener('mouseup', stopDragFromDrawer);
        }
        
        function dragFromDrawer(e) {
            if (!currentPiece) return;
            const rect = document.getElementById('puzzleContainer').getBoundingClientRect();
            currentPiece.style.left = (e.clientX - rect.left - currentPiece.offX) + 'px';
            currentPiece.style.top = (e.clientY - rect.top - currentPiece.offY) + 'px';
        }
        
        function stopDragFromDrawer() {
            if (!currentPiece) return;
            document.removeEventListener('mousemove', dragFromDrawer);
            document.removeEventListener('mouseup', stopDragFromDrawer);
            
            currentPiece.classList.remove('dragging');
            currentPiece.style.zIndex = '';
            
            const left = parseInt(currentPiece.style.left), top = parseInt(currentPiece.style.top);
            
            // ‰ΩçÁΩÆÊ≠£Á¢∫Â∞±ÊîæÁΩÆÔºå‰∏¶Ëá™ÂãïËΩâÊ≠£
            if (Math.abs(left - currentPiece.correctX) < 15 && Math.abs(top - currentPiece.correctY) < 15) {
                currentPiece.style.transition = 'transform 0.3s';
                currentPiece.style.left = currentPiece.correctX + 'px';
                currentPiece.style.top = currentPiece.correctY + 'px';
                // Ëá™ÂãïËΩâÊ≠£ÔºàÁßªÈô§ÊóãËΩâÔºâ
                currentPiece.style.transform = currentPiece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                currentPiece.currentRotation = 0;
                setTimeout(() => currentPiece.style.transition = '', 300);
                currentPiece.isPlaced = true;
                currentPiece.drawerWrapper.classList.add('placed');
                const dp = drawerPieces.find(d => d.piece === currentPiece);
                if (dp) dp.isPlaced = true;
                playSnapSound();
                if (navigator.vibrate) navigator.vibrate(20);
                updateDrawerCount();
                checkWin();
            } else {
                document.getElementById('puzzleContainer').removeChild(currentPiece);
                currentPiece.drawerWrapper.classList.remove('dragging');
                if (navigator.vibrate) navigator.vibrate([30,20,30]);
            }
            currentPiece = null;
        }

        // ÂæûÊäΩÂ±úÊãñÊõ≥ (Ëß∏Êéß) - Âä†ÂÖ•ÊªæÂãïÂà§Êñ∑
        let touchStartInfo = null;
        let dragDelayTimer = null;
        let isDraggingFromDrawer = false;
        const DRAG_DELAY = 150; // Èï∑Êåâ150msÊâçÈñãÂßãÊãñÊõ≥
        const SCROLL_THRESHOLD = 10; // ÁßªÂãïË∂ÖÈÅé10pxË¶ñÁÇ∫ÊªæÂãï

        function startTouchFromDrawer(e) {
            if (!isPlaying) return;
            
            const wrapper = this;
            const piece = wrapper.pieceRef;
            if (!piece || piece.isPlaced) return;
            
            // È°ØÁ§∫Á∑®ËôüÊèêÁ§∫
            showDrawerHint(wrapper);
            
            const touch = e.touches[0];
            const wrapperRect = wrapper.getBoundingClientRect();
            
            touchStartInfo = {
                wrapper: wrapper,
                piece: piece,
                startX: touch.clientX,
                startY: touch.clientY,
                lastX: touch.clientX,
                lastY: touch.clientY,
                // Ë®òÈåÑÊâãÊåáÂú® wrapper ÂÖßÁöÑÂÅèÁßª
                offsetInWrapperX: touch.clientX - wrapperRect.left,
                offsetInWrapperY: touch.clientY - wrapperRect.top,
                scrollLeft: document.getElementById('puzzleDrawer').scrollLeft,
                scrollTop: document.getElementById('puzzleDrawer').scrollTop
            };
            isDraggingFromDrawer = false;
            
            // Âª∂ÈÅ≤ÂïüÂãïÊãñÊõ≥ÔºåÁµ¶ÊªæÂãïÊ©üÊúÉ
            dragDelayTimer = setTimeout(() => {
                if (touchStartInfo && !isDraggingFromDrawer) {
                    // Ê™¢Êü•ÊòØÂê¶Â∑≤Á∂ìÂú®ÊªæÂãï
                    const drawer = document.getElementById('puzzleDrawer');
                    const scrolled = Math.abs(drawer.scrollLeft - touchStartInfo.scrollLeft) > 5 || 
                                    Math.abs(drawer.scrollTop - touchStartInfo.scrollTop) > 5;
                    if (!scrolled) {
                        startActualDrag();
                    }
                }
            }, DRAG_DELAY);
            
            document.addEventListener('touchmove', handleDrawerTouchMove, {passive: false});
            document.addEventListener('touchend', handleDrawerTouchEnd);
        }
        
        function handleDrawerTouchMove(e) {
            if (!touchStartInfo) return;
            
            const touch = e.touches[0];
            const dx = touch.clientX - touchStartInfo.startX;
            const dy = touch.clientY - touchStartInfo.startY;
            
            // Êõ¥Êñ∞ÊúÄÂæåËß∏Êéß‰ΩçÁΩÆ
            touchStartInfo.lastX = touch.clientX;
            touchStartInfo.lastY = touch.clientY;
            
            if (isDraggingFromDrawer) {
                // Ê≠£Âú®ÊãñÊõ≥ÊãºÂúñ
                e.preventDefault();
                const rect = document.getElementById('puzzleContainer').getBoundingClientRect();
                currentPiece.style.left = (touch.clientX - rect.left - currentPiece.offX) + 'px';
                currentPiece.style.top = (touch.clientY - rect.top - currentPiece.offY) + 'px';
            } else {
                // Ê™¢Êü•ÊòØÂê¶ÁÇ∫ÊªæÂãïÊÑèÂúñ
                if (Math.abs(dx) > SCROLL_THRESHOLD || Math.abs(dy) > SCROLL_THRESHOLD) {
                    // ÂèñÊ∂àÊãñÊõ≥ÔºåÂÖÅË®±ÊªæÂãï
                    clearTimeout(dragDelayTimer);
                    dragDelayTimer = null;
                }
            }
        }
        
        function startActualDrag() {
            if (!touchStartInfo) return;
            
            isDraggingFromDrawer = true;
            const { wrapper, piece, lastX, lastY, offsetInWrapperX, offsetInWrapperY } = touchStartInfo;
            
            wrapper.classList.add('dragging');
            const container = document.getElementById('puzzleContainer');
            const rect = container.getBoundingClientRect();
            
            // ‰ΩøÁî®ÂÅèÁßªÈáèÔºåËÆìÊãºÂúñ‰∏çÊúÉË∑≥Âãï
            piece.style.left = (lastX - rect.left - offsetInWrapperX) + 'px';
            piece.style.top = (lastY - rect.top - offsetInWrapperY) + 'px';
            piece.style.zIndex = '1000';
            piece.classList.add('dragging');
            container.appendChild(piece);
            
            currentPiece = piece;
            currentPiece.drawerWrapper = wrapper;
            // ‰øùÂ≠òÂÅèÁßªÈáè‰æõÁßªÂãïÊôÇ‰ΩøÁî®
            currentPiece.offX = offsetInWrapperX;
            currentPiece.offY = offsetInWrapperY;
            
            if (navigator.vibrate) navigator.vibrate(10);
        }
        
        function handleDrawerTouchEnd() {
            clearTimeout(dragDelayTimer);
            dragDelayTimer = null;
            
            document.removeEventListener('touchmove', handleDrawerTouchMove);
            document.removeEventListener('touchend', handleDrawerTouchEnd);
            
            if (!isDraggingFromDrawer) {
                touchStartInfo = null;
                return;
            }
            
            if (!currentPiece) {
                touchStartInfo = null;
                isDraggingFromDrawer = false;
                return;
            }
            
            currentPiece.classList.remove('dragging');
            currentPiece.style.zIndex = '';
            
            const left = parseInt(currentPiece.style.left), top = parseInt(currentPiece.style.top);
            
            // ‰ΩçÁΩÆÊ≠£Á¢∫Â∞±ÊîæÁΩÆÔºå‰∏¶Ëá™ÂãïËΩâÊ≠£
            if (Math.abs(left - currentPiece.correctX) < 15 && Math.abs(top - currentPiece.correctY) < 15) {
                currentPiece.style.transition = 'transform 0.3s';
                currentPiece.style.left = currentPiece.correctX + 'px';
                currentPiece.style.top = currentPiece.correctY + 'px';
                // Ëá™ÂãïËΩâÊ≠£ÔºàÁßªÈô§ÊóãËΩâÔºâ
                currentPiece.style.transform = currentPiece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                currentPiece.currentRotation = 0;
                setTimeout(() => currentPiece.style.transition = '', 300);
                currentPiece.isPlaced = true;
                currentPiece.drawerWrapper.classList.add('placed');
                const dp = drawerPieces.find(d => d.piece === currentPiece);
                if (dp) dp.isPlaced = true;
                playSnapSound();
                if (navigator.vibrate) navigator.vibrate(20);
                updateDrawerCount();
                checkWin();
            } else {
                document.getElementById('puzzleContainer').removeChild(currentPiece);
                currentPiece.drawerWrapper.classList.remove('dragging');
                if (navigator.vibrate) navigator.vibrate([30,20,30]);
            }
            
            currentPiece = null;
            touchStartInfo = null;
            isDraggingFromDrawer = false;
        }

        function checkWin() {
            if (drawerPieces.every(d => d.isPlaced)) {
                isPlaying = false;
                playWinSound();
                if (navigator.vibrate) navigator.vibrate([100,50,100]);
                // Â±ïÈñãÊéßÂà∂Èù¢Êùø
                showControlsDrawer();
                setTimeout(() => showCompletionMessage(), 300);
            }
        }
        
        // È°ØÁ§∫ÁæéÂåñÁöÑÂÆåÊàêË®äÊÅØ
        function showCompletionMessage() {
            const msg = document.createElement('div');
            msg.className = 'completion-message';
            msg.innerHTML = 'üéâ ÊÅ≠ÂñúÂÆåÊàêÊãºÂúñÔºÅ';
            document.body.appendChild(msg);
            setTimeout(() => msg.classList.add('show'), 10);
            setTimeout(() => {
                msg.classList.remove('show');
                setTimeout(() => msg.remove(), 500);
            }, 3000);
        }
        
        // Â±ïÈñãÊéßÂà∂Èù¢Êùø
        function showControlsDrawer() {
            controlsCollapsed = false;
            document.getElementById('controlsDrawer').classList.remove('collapsed');
            document.getElementById('controlsToggle').textContent = '‚óÄ';
        }

        function autoComplete() {
            if (!isPlaying) return;
            const container = document.getElementById('puzzleContainer');
            drawerPieces.forEach((dp, i) => {
                if (!dp.isPlaced) {
                    setTimeout(() => {
                        dp.piece.style.transition = 'all 0.4s';
                        dp.piece.style.left = dp.piece.correctX + 'px';
                        dp.piece.style.top = dp.piece.correctY + 'px';
                        // ÈáçÁΩÆÊóãËΩâËßíÂ∫¶
                        dp.piece.style.transform = dp.piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                        dp.piece.currentRotation = 0;
                        dp.piece.isPlaced = true; dp.isPlaced = true;
                        if (!dp.piece.parentElement) container.appendChild(dp.piece);
                        dp.drawerItem.classList.add('placed');
                        updateDrawerCount();
                    }, i * 80);
                }
            });
            setTimeout(() => { 
                isPlaying = false; 
                playWinSound(); 
                showControlsDrawer();
                showCompletionMessage();
            }, drawerPieces.length * 80 + 500);
        }

        // ÊèêÁ§∫ÈñãÈóú
        document.getElementById('toggleHint').addEventListener('change', function() {
            showHint = this.checked;
            // Êõ¥Êñ∞ÊãºÂúñÂçÄÁ∑®Ëôü
            document.querySelectorAll('.piece-outline').forEach((o, idx) => {
                const n = o.querySelector('.piece-number');
                if (n) o.removeChild(n);
                if (showHint) {
                    const num = document.createElement('div');
                    num.className = 'piece-number';
                    num.textContent = Math.floor(idx/cols)*cols + (idx%cols) + 1;
                    o.appendChild(num);
                }
            });
        });
        
        // ÊóãËΩâÈñãÈóú
        document.getElementById('toggleRotation').addEventListener('change', function() {
            enableRotation = this.checked;
            // Êõ¥Êñ∞Êú™ÊîæÁΩÆÊãºÂúñÁöÑÊóãËΩâ
            drawerPieces.forEach(dp => {
                if (!dp.isPlaced) {
                    const randomRotation = enableRotation ? [0, 90, 180, 270][Math.floor(Math.random() * 4)] : 0;
                    dp.drawerItem.currentRotation = randomRotation;
                    dp.piece.currentRotation = randomRotation;
                    const div = dp.drawerItem.pieceDiv;
                    if (div) {
                        const baseTransform = dp.piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                        div.style.transform = randomRotation !== 0 ? `${baseTransform} rotate(${randomRotation}deg)` : baseTransform;
                    }
                }
            });
        });
        
        // ÁâáÊï∏ÊîπËÆäÊôÇÈáçÊñ∞ÈñãÂßãÈÅäÊà≤
        document.getElementById('pieceCount').addEventListener('change', function() {
            if (originalImage) {
                startGame();
            }
        });
    </script>
</body>
</html>
