<!DOCTYPE html>
<html>

<head>
    <title>æ›²ç·šæ‹¼åœ–éŠæˆ²</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            height: 100vh;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }

        .game-area {
            width: 100%;
            height: 100%;
            background-color: #000000;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }

        .puzzle-container {
            position: absolute;
            background-color: #000000;
            box-sizing: border-box;
            /* ä½ç½®ç”± JS å‹•æ…‹è¨­ç½® */
        }

        .puzzle-piece {
            position: absolute;
            cursor: move;
            transition: none;
            background-repeat: no-repeat;
            z-index: 1;
            touch-action: none;
        }

        .puzzle-piece.dragging {
            z-index: 1001;
            filter: brightness(1.1) drop-shadow(0 0 15px rgba(255, 255, 255, 0.3));
        }

        /* æ§åˆ¶é¢æ¿æŠ½å±œ - å°ˆæ¥­æ·±è‰²é¢¨æ ¼ */
        .controls-drawer {
            position: absolute;
            top: 0;
            left: 0;
            width: 200px;
            height: 100%;
            background: rgba(20, 20, 20, 0.95);
            border-right: 2px solid rgba(255, 215, 0, 0.6);
            box-shadow: 2px 0 15px rgba(0,0,0,0.5);
            z-index: 300;
            transition: transform 0.3s ease;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
            color: white;
        }
        .controls-drawer.collapsed {
            transform: translateX(-200px);
        }
        .controls-toggle {
            position: absolute;
            top: 50%;
            left: 200px;
            transform: translateY(-50%);
            width: 28px;
            height: 50px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-left: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 14px;
            color: white;
            z-index: 301;
            transition: left 0.3s ease;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }
        .controls-toggle:hover {
            background: rgba(40, 40, 40, 0.95);
        }
        .controls-drawer.collapsed + .controls-toggle {
            left: 0;
        }
        .controls-drawer h1 {
            margin: 0 0 12px 0;
            font-size: 1.2em;
            color: gold;
            text-align: center;
        }
        .controls-drawer .button {
            width: 100%;
            padding: 10px;
            margin: 4px 0;
            background: rgba(255, 215, 0, 0.2);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        .controls-drawer .button:hover {
            background: rgba(255, 215, 0, 0.3);
            border-color: gold;
        }
        .controls-drawer .button:active { 
            background: rgba(255, 215, 0, 0.4);
        }
        .controls-drawer select {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            background: rgba(40, 40, 40, 0.9);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
        }
        .controls-drawer select option {
            background: #222;
            color: white;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 6px 0;
            font-size: 13px;
            color: #ddd;
        }
        .checkbox-input { 
            width: 16px; 
            height: 16px;
            accent-color: gold;
        }

        /* æµ®å‹•é è¦½åœ– */
        .floating-preview {
            position: absolute;
            top: 10px;
            right: 60px;
            width: 180px;
            background: rgba(0,0,0,0.85);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 200;
            cursor: move;
            user-select: none;
            touch-action: none;
            display: none;
        }
        .floating-preview.visible { display: block; }
        .floating-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(255,255,255,0.15);
            border-radius: 8px 8px 0 0;
            font-size: 11px;
            color: rgba(255,255,255,0.8);
        }
        .floating-preview-close {
            background: none;
            border: none;
            color: rgba(255,255,255,0.8);
            cursor: pointer;
            font-size: 14px;
            padding: 0 2px;
        }
        .floating-preview img {
            width: 100%;
            display: block;
            border-radius: 0 0 8px 8px;
        }
        .floating-preview-resize {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 18px;
            height: 18px;
            cursor: se-resize;
            background: linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.3) 50%);
            border-radius: 0 0 8px 0;
        }
        .show-preview-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 16px;
            cursor: pointer;
            z-index: 199;
            display: none;
        }
        .show-preview-btn.visible { display: block; }

        /* æ‹¼åœ–æŠ½å±œ - æ·±è—è‰²èª¿èˆ‡æ‹¼åœ–å€å€éš” */
        .puzzle-drawer {
            position: absolute;
            background: linear-gradient(135deg, rgba(20, 30, 50, 0.95), rgba(30, 40, 60, 0.95));
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            overflow: auto;
            z-index: 100;
            padding: 10px;
            gap: 8px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        .puzzle-drawer.drawer-bottom { bottom: 0; left: 0; right: 0; height: 180px; border-top: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-top { top: 0; left: 0; right: 0; height: 180px; border-bottom: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-left { top: 0; left: 0; bottom: 0; width: 180px; border-right: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-right { top: 0; right: 0; bottom: 0; width: 180px; border-left: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-none { display: none; }

        .drawer-piece-wrapper {
            position: relative;
            cursor: grab;
            flex-shrink: 0;
            margin: 9px;
            overflow: visible;
        }
        .drawer-piece-wrapper.dragging { opacity: 0.3; }
        .drawer-piece-wrapper.placed { display: none; }
        
        .drawer-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 14px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
            pointer-events: none;
        }
        
        .drawer-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: gold;
            font-size: 16px;
            font-weight: bold;
            padding: 4px 10px;
            border-radius: 6px;
            border: 2px solid gold;
            pointer-events: none;
            animation: hintFade 3s ease-out forwards;
        }
        
        @keyframes hintFade {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        .drawer-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 4px;
            z-index: 101;
        }
        .drawer-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 12px;
            cursor: pointer;
        }
        .drawer-btn:hover { background: rgba(0,0,0,0.9); }
        .drawer-btn.active { background: rgba(74,144,217,0.8); border-color: #4a90d9; }
        .drawer-btn.shuffle-btn { background: rgba(0,0,0,0.7); }
        .drawer-btn.shuffle-btn:hover { background: rgba(0,0,0,0.9); }
        
        /* å®Œæˆè¨Šæ¯ */
        .completion-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(0,0,0,0.9);
            color: white;
            font-size: 28px;
            font-weight: bold;
            padding: 30px 50px;
            border-radius: 20px;
            border: 3px solid gold;
            z-index: 9999;
            opacity: 0;
            transition: all 0.3s ease;
            text-align: center;
        }
        .completion-message.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        /* è¼‰å…¥é€²åº¦ */
        .progress-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .progress-text {
            color: gold;
            font-size: 20px;
            margin-bottom: 20px;
        }
        .progress-bar {
            width: 250px;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid gold;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, gold, orange);
            width: 0%;
            transition: width 0.1s;
        }
        
        .drawer-count {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 12px;
            z-index: 101;
        }

        .piece-outline { pointer-events: none; }
        .piece-number {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            pointer-events: none;
        }

        /* é•·æŒ‰é è¦½ */
        .preview-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .preview-overlay.show { display: flex; }
        .preview-overlay img { max-width: 90%; max-height: 90%; }
    </style>
</head>

<body>
    <div class="game-area" id="gameArea">
        <div id="puzzleContainer" class="puzzle-container"></div>
        
        <!-- æ§åˆ¶é¢æ¿æŠ½å±œ -->
        <div class="controls-drawer" id="controlsDrawer">
            <h1>ğŸ§© æ‹¼åœ–éŠæˆ²</h1>
            <input type="file" id="imageInput" accept="image/*" style="display:none;">
            <button class="button" onclick="selectImage()">ğŸ“· é¸æ“‡åœ–ç‰‡</button>
            <select id="pieceCount">
                <option value="16">4x4 (16ç‰‡)</option>
                <option value="25">5x5 (25ç‰‡)</option>
                <option value="36">6x6 (36ç‰‡)</option>
                <option value="49">7x7 (49ç‰‡)</option>
                <option value="64">8x8 (64ç‰‡)</option>
                <option value="81">9x9 (81ç‰‡)</option>
                <option value="100">10x10 (100ç‰‡)</option>
                <option value="121">11x11 (121ç‰‡)</option>
                <option value="144">12x12 (144ç‰‡)</option>
            </select>
            <button class="button" onclick="startGame()">â–¶ é–‹å§‹éŠæˆ²</button>
            <button class="button" onclick="autoComplete()">âœ¨ è‡ªå‹•å®Œæˆ</button>
            <div class="checkbox-container">
                <input type="checkbox" id="toggleHint" class="checkbox-input">
                <label for="toggleHint" class="checkbox-label">æç¤º</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="toggleRotation" class="checkbox-input">
                <label for="toggleRotation" class="checkbox-label">æ—‹è½‰</label>
            </div>
            <div style="margin-top:10px; font-size:10px; color:#aaa;">ğŸ’¡ é•·æŒ‰ç©ºç™½è™•æŸ¥çœ‹åŸåœ–</div>
        </div>
        <button class="controls-toggle" id="controlsToggle" onclick="toggleControls()">â—€</button>
        
        <!-- æµ®å‹•é è¦½åœ– -->
        <div class="floating-preview" id="floatingPreview">
            <div class="floating-preview-header">
                <span>ğŸ“· é è¦½</span>
                <button class="floating-preview-close" onclick="hidePreview()">âœ•</button>
            </div>
            <img id="previewImg" src="">
            <div class="floating-preview-resize" id="previewResize"></div>
        </div>
        <button class="show-preview-btn" id="showPreviewBtn" onclick="showPreview()">ğŸ–¼</button>
        
        <!-- æŠ½å±œæ§åˆ¶ -->
        <div class="drawer-count" id="drawerCount">å‰©é¤˜: 0 å¡Š</div>
        <div class="drawer-controls">
            <button class="drawer-btn" onclick="setDrawerPosition('top')">â¬†</button>
            <button class="drawer-btn active" onclick="setDrawerPosition('bottom')">â¬‡</button>
            <button class="drawer-btn" onclick="setDrawerPosition('left')">â¬…</button>
            <button class="drawer-btn" onclick="setDrawerPosition('right')">â¡</button>
            <button class="drawer-btn" onclick="setDrawerPosition('none')">âœ•</button>
            <button class="drawer-btn shuffle-btn" onclick="shuffleDrawer()">ğŸ”€</button>
        </div>
        
        <!-- æ‹¼åœ–æŠ½å±œ -->
        <div class="puzzle-drawer drawer-bottom" id="puzzleDrawer"></div>
    </div>

    <div class="preview-overlay" id="previewOverlay">
        <img id="previewOverlayImg" src="">
    </div>

    <script>
        // å…¨å±€è®Šé‡
        let originalImage = null;
        let pieces = [];
        let currentPiece = null;
        let isPlaying = false;
        let edges = null;
        let showHint = false;
        let enableRotation = false;
        let rows, cols;
        let drawerPosition = 'bottom';
        let drawerPieces = [];
        let audioContext = null;
        let controlsCollapsed = false;

        // é¸æ“‡åœ–ç‰‡
        function selectImage() {
            document.getElementById('imageInput').click();
        }

        // æ§åˆ¶é¢æ¿æ”¶åˆ
        function toggleControls() {
            controlsCollapsed = !controlsCollapsed;
            document.getElementById('controlsDrawer').classList.toggle('collapsed', controlsCollapsed);
            document.getElementById('controlsToggle').textContent = controlsCollapsed ? 'â–¶' : 'â—€';
        }

        // æµ®å‹•é è¦½æ‹–æ›³èˆ‡ç¸®æ”¾
        let previewDrag = { active: false, x: 0, y: 0 };
        let previewResize = { active: false, w: 0 };

        function showPreview() {
            document.getElementById('floatingPreview').classList.add('visible');
            document.getElementById('showPreviewBtn').classList.remove('visible');
        }
        
        function hidePreview() {
            document.getElementById('floatingPreview').classList.remove('visible');
            document.getElementById('showPreviewBtn').classList.add('visible');
        }

        // é è¦½æ‹–æ›³
        document.getElementById('floatingPreview').addEventListener('mousedown', function(e) {
            if (e.target.closest('.floating-preview-close') || e.target.closest('.floating-preview-resize')) return;
            previewDrag.active = true;
            const rect = this.getBoundingClientRect();
            previewDrag.x = e.clientX - rect.left;
            previewDrag.y = e.clientY - rect.top;
            e.preventDefault();
        });
        
        document.getElementById('floatingPreview').addEventListener('touchstart', function(e) {
            if (e.target.closest('.floating-preview-close') || e.target.closest('.floating-preview-resize')) return;
            previewDrag.active = true;
            const rect = this.getBoundingClientRect();
            const t = e.touches[0];
            previewDrag.x = t.clientX - rect.left;
            previewDrag.y = t.clientY - rect.top;
            e.preventDefault();
        }, {passive: false});

        document.addEventListener('mousemove', function(e) {
            if (previewDrag.active) {
                const fp = document.getElementById('floatingPreview');
                fp.style.left = (e.clientX - previewDrag.x) + 'px';
                fp.style.top = (e.clientY - previewDrag.y) + 'px';
                fp.style.right = 'auto';
            }
            if (previewResize.active) {
                const fp = document.getElementById('floatingPreview');
                const w = Math.max(80, Math.min(300, e.clientX - fp.getBoundingClientRect().left));
                fp.style.width = w + 'px';
            }
        });
        
        document.addEventListener('touchmove', function(e) {
            if (previewDrag.active) {
                const t = e.touches[0];
                const fp = document.getElementById('floatingPreview');
                fp.style.left = (t.clientX - previewDrag.x) + 'px';
                fp.style.top = (t.clientY - previewDrag.y) + 'px';
                fp.style.right = 'auto';
            }
            if (previewResize.active) {
                const t = e.touches[0];
                const fp = document.getElementById('floatingPreview');
                const w = Math.max(80, Math.min(300, t.clientX - fp.getBoundingClientRect().left));
                fp.style.width = w + 'px';
            }
        }, {passive: false});

        document.addEventListener('mouseup', function() { previewDrag.active = false; previewResize.active = false; });
        document.addEventListener('touchend', function() { previewDrag.active = false; previewResize.active = false; });

        // é è¦½ç¸®æ”¾
        document.getElementById('previewResize').addEventListener('mousedown', function(e) {
            previewResize.active = true;
            e.preventDefault();
            e.stopPropagation();
        });
        document.getElementById('previewResize').addEventListener('touchstart', function(e) {
            previewResize.active = true;
            e.preventDefault();
            e.stopPropagation();
        }, {passive: false});

        // éŸ³æ•ˆ
        function playSnapSound() {
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain); gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(880, audioContext.currentTime);
                osc.frequency.setValueAtTime(1175, audioContext.currentTime + 0.05);
                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                osc.start(); osc.stop(audioContext.currentTime + 0.15);
            } catch(e) {}
        }
        
        function playWinSound() {
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                [523, 659, 784, 1047].forEach((f, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain); gain.connect(audioContext.destination);
                    osc.frequency.setValueAtTime(f, audioContext.currentTime);
                    const t = audioContext.currentTime + i * 0.12;
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.3, t + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                    osc.start(t); osc.stop(t + 0.3);
                });
            } catch(e) {}
        }

        // æŠ½å±œæ§åˆ¶
        function setDrawerPosition(pos) {
            drawerPosition = pos;
            document.getElementById('puzzleDrawer').className = 'puzzle-drawer drawer-' + pos;
            document.querySelectorAll('.drawer-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            // åªæ›´æ–°ä½ç½®ï¼Œä¸æ”¹è®Šå¤§å°
            if (originalImage && isPlaying) {
                const container = document.getElementById('puzzleContainer');
                const w = parseFloat(container.style.width);
                const h = parseFloat(container.style.height);
                const pos = calculateContainerPosition(w, h);
                container.style.left = pos.left + 'px';
                container.style.top = pos.top + 'px';
            }
        }
        
        function updateDrawerCount() {
            document.getElementById('drawerCount').textContent = 'å‰©é¤˜: ' + drawerPieces.filter(d => !d.isPlaced).length + ' å¡Š';
        }
        
        function shuffleDrawer() {
            const drawer = document.getElementById('puzzleDrawer');
            const items = Array.from(drawer.children);
            for (let i = items.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                drawer.appendChild(items[j]);
            }
        }
        
        function updateDrawerLabels() {
            // åªæ›´æ–°ç‹€æ…‹ï¼Œä¸æ·»åŠ æ°¸ä¹…æ¨™ç±¤
            // å‹¾é¸å¾Œé»æ“Šæ‹¼åœ–æœƒé¡¯ç¤º 3 ç§’æç¤º
        }

        // é•·æŒ‰é è¦½
        let longPressTimer = null;
        
        function showFullPreview() {
            if (!originalImage) return;
            document.getElementById('previewOverlayImg').src = originalImage.src;
            document.getElementById('previewOverlay').classList.add('show');
            if (navigator.vibrate) navigator.vibrate(30);
        }
        
        function hideFullPreview() {
            document.getElementById('previewOverlay').classList.remove('show');
        }
        
        document.getElementById('gameArea').addEventListener('touchstart', function(e) {
            if (e.target.closest('.drawer-piece-wrapper') || e.target.closest('.drawer-btn') || 
                e.target.closest('.puzzle-drawer') || e.target.closest('.controls-drawer') ||
                e.target.closest('.controls-toggle') || e.target.closest('.floating-preview')) return;
            longPressTimer = setTimeout(showFullPreview, 500);
        }, {passive: true});
        
        document.getElementById('gameArea').addEventListener('touchend', function() {
            clearTimeout(longPressTimer); hideFullPreview();
        }, {passive: true});
        
        document.getElementById('gameArea').addEventListener('touchmove', function() {
            clearTimeout(longPressTimer);
        }, {passive: true});
        
        document.getElementById('previewOverlay').addEventListener('click', hideFullPreview);

        // æ‹¼åœ–è·¯å¾‘ç”Ÿæˆ - æ¨™æº–ç‰ˆæœ¬
        function generateCurvedPath(width, height, edges) {
            const { top, right, bottom, left } = edges;
            const tabHeight = Math.min(width, height) * 0.15;
            const tabWidth = Math.min(width, height) * 0.5;

            let path = `M ${tabHeight},${tabHeight}`;
            
            // Top
            if (top === 'tab') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${(width-tabWidth)/2}`;
            else if (top === 'slot') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${(width-tabWidth)/2}`;
            else path += ` h ${width}`;
            
            // Right
            if (right === 'tab') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else if (right === 'slot') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else path += ` v ${height}`;
            
            // Bottom
            if (bottom === 'tab') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${(width-tabWidth)/2}`;
            else if (bottom === 'slot') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${(width-tabWidth)/2}`;
            else path += ` h -${width}`;
            
            // Left
            if (left === 'tab') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else if (left === 'slot') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else path += ` v -${height}`;
            
            return path + ' Z';
        }

        function generateEdges(rows, cols) {
            const p = Array(rows).fill().map(() => Array(cols).fill().map(() => ({top:null,right:null,bottom:null,left:null})));
            for (let i = 0; i < rows-1; i++) for (let j = 0; j < cols; j++) { const t = Math.random() < 0.5; p[i][j].bottom = t ? 'tab' : 'slot'; p[i+1][j].top = t ? 'slot' : 'tab'; }
            for (let i = 0; i < rows; i++) for (let j = 0; j < cols-1; j++) { const t = Math.random() < 0.5; p[i][j].right = t ? 'tab' : 'slot'; p[i][j+1].left = t ? 'slot' : 'tab'; }
            return p;
        }

        // åœ–ç‰‡è¼‰å…¥
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(ev) { loadImage(ev.target.result); };
                reader.readAsDataURL(file);
            }
            e.target.value = '';
        });

        function loadImage(src) {
            originalImage = new Image();
            originalImage.onload = function() {
                document.getElementById('previewImg').src = src;
                showPreview();
                startGame();
            };
            originalImage.src = src;
        }

        // è¨ˆç®—æ‹¼åœ–å€å¤§å°ï¼ˆåªåœ¨é–‹å§‹éŠæˆ²æ™‚èª¿ç”¨ä¸€æ¬¡ï¼‰
        // ä½¿ç”¨æœ€å°å¯ç”¨ç©ºé–“ï¼Œç¢ºä¿ drawer åœ¨ä»»ä½•ä½ç½®éƒ½ä¸æœƒè¶…å‡º
        function calculateContainerSize() {
            const gameArea = document.querySelector('.game-area');
            const totalWidth = gameArea.offsetWidth;
            const totalHeight = gameArea.offsetHeight;
            
            const drawerSize = 180;
            const tabMargin = 10; // é ç•™ tab çªå‡ºç©ºé–“ï¼ˆæœ€å°åŒ–ï¼‰
            
            // åŒæ™‚é ç•™ä¸Šä¸‹å’Œå·¦å³çš„ drawer ç©ºé–“ï¼Œå–æœ€å°å¯ç”¨å€åŸŸ
            // é€™æ¨£ç„¡è«– drawer åœ¨å“ªå€‹æ–¹å‘ï¼Œæ‹¼åœ–å€éƒ½èƒ½å®Œæ•´é¡¯ç¤º
            const availableWidth = totalWidth - drawerSize - tabMargin * 2;
            const availableHeight = totalHeight - drawerSize - tabMargin * 2;
            
            // æ ¹æ“šåœ–ç‰‡æ¯”ä¾‹è¨ˆç®—æ‹¼åœ–å€å¤§å°
            const ratio = originalImage.width / originalImage.height;
            let w, h;
            if (availableWidth / availableHeight > ratio) {
                h = availableHeight;
                w = h * ratio;
            } else {
                w = availableWidth;
                h = w / ratio;
            }
            
            return { width: w, height: h };
        }
        
        // è¨ˆç®—æ‹¼åœ–å€ä½ç½®ï¼ˆåˆ‡æ›æŠ½å±œæ–¹å‘æ™‚èª¿ç”¨ï¼‰
        function calculateContainerPosition(containerWidth, containerHeight) {
            const gameArea = document.querySelector('.game-area');
            const totalWidth = gameArea.offsetWidth;
            const totalHeight = gameArea.offsetHeight;
            
            const drawerSize = 180;
            
            // è¨ˆç®—å¯ç”¨å€åŸŸçš„é‚Šç•Œ
            let left = 0, top = 0;
            let right = totalWidth;
            let bottom = totalHeight;
            
            // æ ¹æ“šæŠ½å±œä½ç½®èª¿æ•´é‚Šç•Œ
            if (drawerPosition === 'left') left = drawerSize;
            else if (drawerPosition === 'right') right = totalWidth - drawerSize;
            else if (drawerPosition === 'top') top = drawerSize;
            else if (drawerPosition === 'bottom') bottom = totalHeight - drawerSize;
            
            const availableWidth = right - left;
            const availableHeight = bottom - top;
            
            // è¨ˆç®—ç½®ä¸­ä½ç½®
            const centerX = left + (availableWidth - containerWidth) / 2;
            const centerY = top + (availableHeight - containerHeight) / 2;
            
            return { left: centerX, top: centerY };
        }

        // å‰µå»ºæ‹¼åœ–å¡Š - åœ–ç‰‡å…§ç¸®ï¼Œè®“é‚Šç·£æ‹¼åœ–æœ‰å»¶ä¼¸ç©ºé–“
        function createPuzzlePiece(i, j, pw, ph, size, ed) {
            const piece = document.createElement('div');
            piece.className = 'puzzle-piece';
            const tab = Math.min(pw, ph) * 0.15;
            
            // é‚Šç·£æ‹¼åœ–ä½¿ç”¨å»¶ä¼¸è·¯å¾‘
            const path = generatePiecePath(pw, ph, ed);
            
            const actualW = pw + 2*tab;
            const actualH = ph + 2*tab;
            
            // åœ–ç‰‡å…§ç¸®ï¼šè®“åœ–ç‰‡å¾ tab ä½ç½®é–‹å§‹ï¼Œå››å‘¨ç•™å‡º tab ç©ºé–“
            // èƒŒæ™¯åœ–å¤§å°ä¸è®Šï¼Œä½†ä½ç½®å¾€å…§åç§» tab
            const bgX = -(j * pw) + tab;
            const bgY = -(i * ph) + tab;
            
            piece.style.cssText = `width:${actualW}px; height:${actualH}px; background-image:url(${originalImage.src}); background-size:${size.width}px ${size.height}px; background-position:${bgX}px ${bgY}px; background-repeat:no-repeat; clip-path:path('${path}'); -webkit-clip-path:path('${path}'); position:absolute; transform:translate(-${tab}px,-${tab}px);`;
            piece.correctX = j * pw;
            piece.correctY = i * ph;
            piece.pieceNumber = i * cols + j + 1;
            piece.isPlaced = false;
            return piece;
        }
        
        // æ‹¼åœ–å¡Šè·¯å¾‘ - å¹³ç›´é‚Šå»¶ä¼¸åˆ° tab ä½ç½®
        function generatePiecePath(width, height, edges) {
            const { top, right, bottom, left } = edges;
            const tabHeight = Math.min(width, height) * 0.15;
            const tabWidth = Math.min(width, height) * 0.5;

            let path = `M ${tabHeight},${tabHeight}`;
            
            // Top
            if (top === 'tab') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${(width-tabWidth)/2}`;
            else if (top === 'slot') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${(width-tabWidth)/2}`;
            else path += ` v -${tabHeight} h ${width} v ${tabHeight}`;
            
            // Right
            if (right === 'tab') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else if (right === 'slot') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else path += ` h ${tabHeight} v ${height} h -${tabHeight}`;
            
            // Bottom
            if (bottom === 'tab') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${(width-tabWidth)/2}`;
            else if (bottom === 'slot') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${(width-tabWidth)/2}`;
            else path += ` v ${tabHeight} h -${width} v -${tabHeight}`;
            
            // Left
            if (left === 'tab') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else if (left === 'slot') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else path += ` h -${tabHeight} v -${height} h ${tabHeight}`;
            
            return path + ' Z';
        }

        // è¼ªå»“ç·š - ä½¿ç”¨èˆ‡æ‹¼åœ–å¡Šç›¸åŒçš„è·¯å¾‘
        function createPieceOutline(i, j, pw, ph, size, ed) {
            const outline = document.createElement('div');
            outline.className = 'piece-outline';
            const tab = Math.min(pw, ph) * 0.15;
            // æ ¼ç·šä½¿ç”¨ generateCurvedPathï¼ˆä¸å»¶ä¼¸å¹³ç›´é‚Šï¼‰
            const path = generateCurvedPath(pw, ph, ed);
            
            const svgW = pw + 2*tab;
            const svgH = ph + 2*tab;
            
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", svgW); 
            svg.setAttribute("height", svgH);
            const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
            p.setAttribute("d", path); 
            p.setAttribute("fill", "none"); 
            p.setAttribute("stroke", "rgba(255,255,255,0.35)"); 
            p.setAttribute("stroke-width", "1");
            p.setAttribute("stroke-linejoin", "round");
            p.setAttribute("stroke-linecap", "round");
            svg.appendChild(p); 
            outline.appendChild(svg);
            outline.style.cssText = `position:absolute; left:${j*pw}px; top:${i*ph}px; pointer-events:none; z-index:0; transform:translate(-${tab}px,-${tab}px);`;
            if (showHint) { 
                const n = document.createElement('div'); 
                n.className = 'piece-number'; 
                n.textContent = i*cols+j+1; 
                outline.appendChild(n); 
            }
            return outline;
        }

        function createDrawerItem(piece, pw, ph, tab) {
            const wrapper = document.createElement('div');
            wrapper.className = 'drawer-piece-wrapper';
            // wrapper ç”¨ padding ä¾†å®¹ç´ translate å¾Œçš„æ‹¼åœ–
            wrapper.style.cssText = `width:${pw}px; height:${ph}px; padding:${tab}px; position:relative; box-sizing:content-box;`;
            
            const div = document.createElement('div');
            // å®Œæ•´è¤‡è£½ piece æ¨£å¼ï¼ˆåŒ…å« translateï¼‰
            div.style.cssText = piece.style.cssText.replace('position:absolute;', 'position:relative;');
            
            wrapper.appendChild(div);
            
            // éš¨æ©Ÿæ—‹è½‰ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
            const randomRotation = enableRotation ? [0, 90, 180, 270][Math.floor(Math.random() * 4)] : 0;
            wrapper.currentRotation = randomRotation;
            piece.currentRotation = randomRotation;
            if (randomRotation !== 0) {
                div.style.transform = `translate(-${tab}px,-${tab}px) rotate(${randomRotation}deg)`;
            }
            
            // å„²å­˜ç·¨è™Ÿä¾›æç¤ºç”¨
            wrapper.pieceNumber = piece.pieceNumber;
            wrapper.pieceRef = piece;
            wrapper.pieceDiv = div;
            wrapper.tab = tab;
            wrapper.addEventListener('mousedown', startDragFromDrawer);
            wrapper.addEventListener('touchstart', startTouchFromDrawer, {passive: true});
            return wrapper;
        }
        
        // é¡¯ç¤ºæŠ½å±œæ‹¼åœ–ç·¨è™Ÿæç¤º
        function showDrawerHint(wrapper) {
            if (!showHint) return;
            if (!wrapper || wrapper.classList.contains('placed')) return;
            
            // ç§»é™¤å·²å­˜åœ¨çš„æç¤º
            const existing = wrapper.querySelector('.drawer-hint');
            if (existing) existing.remove();
            
            // å‰µå»ºæç¤º
            const hint = document.createElement('div');
            hint.className = 'drawer-hint';
            hint.textContent = wrapper.pieceNumber;
            wrapper.appendChild(hint);
            
            // 3 ç§’å¾Œç§»é™¤
            setTimeout(() => hint.remove(), 3000);
        }

        // é–‹å§‹éŠæˆ²
        function startGame() {
            if (!originalImage) { alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡ï¼'); return; }
            
            // é¡¯ç¤ºé€²åº¦
            const progressOverlay = document.createElement('div');
            progressOverlay.className = 'progress-overlay';
            progressOverlay.innerHTML = `
                <div class="progress-text" id="progressText">æº–å‚™ä¸­...</div>
                <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
            `;
            document.body.appendChild(progressOverlay);
            
            // ä½¿ç”¨ async è®“ UI æœ‰æ©Ÿæœƒæ›´æ–°
            const updateProgress = (percent, text) => {
                return new Promise(resolve => {
                    document.getElementById('progressFill').style.width = percent + '%';
                    if (text) document.getElementById('progressText').textContent = text;
                    requestAnimationFrame(() => requestAnimationFrame(resolve));
                });
            };
            
            (async () => {
                await updateProgress(10, 'åˆå§‹åŒ–...');
                
                const container = document.getElementById('puzzleContainer');
                const drawer = document.getElementById('puzzleDrawer');
                container.innerHTML = ''; drawer.innerHTML = '';
                pieces = []; drawerPieces = []; isPlaying = true;

                const size = calculateContainerSize();
                const count = parseInt(document.getElementById('pieceCount').value);
                rows = cols = Math.sqrt(count);
                
                const pw = size.width / cols;
                const ph = size.height / rows;
                const tab = Math.min(pw, ph) * 0.15;
                
                const pos = calculateContainerPosition(size.width, size.height);

                container.style.width = size.width + 'px';
                container.style.height = size.height + 'px';
                container.style.left = pos.left + 'px';
                container.style.top = pos.top + 'px';

                const outlines = document.createElement('div');
                outlines.className = 'outlines-container';
                outlines.style.cssText = 'position:absolute;z-index:0;left:0;top:0;';
                container.appendChild(outlines);

                edges = generateEdges(rows, cols);
                
                await updateProgress(30, 'ç¹ªè£½æ ¼ç·š...');
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        outlines.appendChild(createPieceOutline(i, j, pw, ph, size, edges[i][j]));
                    }
                }

                await updateProgress(50, 'åˆ‡å‰²æ‹¼åœ–...');

                let temp = [];
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        temp.push(createPuzzlePiece(i, j, pw, ph, size, edges[i][j]));
                    }
                    await updateProgress(50 + Math.floor((i / rows) * 30), 'åˆ‡å‰²æ‹¼åœ–...');
                }
                
                for (let i = temp.length - 1; i > 0; i--) { 
                    const j = Math.floor(Math.random() * (i + 1)); 
                    [temp[i], temp[j]] = [temp[j], temp[i]]; 
                }
                
                await updateProgress(85, 'æ‰“äº‚é †åº...');
                
                temp.forEach(piece => {
                    const item = createDrawerItem(piece, pw, ph, tab);
                    drawer.appendChild(item);
                    drawerPieces.push({piece, drawerItem: item, isPlaced: false});
                    pieces.push(piece);
                });
                
                updateDrawerCount();
                
                await updateProgress(100, 'å®Œæˆï¼');
                setTimeout(() => progressOverlay.remove(), 300);
            })();
        }

        // å¾æŠ½å±œæ‹–æ›³ (æ»‘é¼ ) - åŠ å…¥å»¶é²åˆ¤æ–·ï¼ŒçŸ­æŒ‰é¡¯ç¤ºæç¤ºï¼Œé•·æŒ‰æ‰æ‹–æ›³
        let mouseStartInfo = null;
        let mouseDragTimer = null;
        let isMouseDragging = false;
        const MOUSE_DRAG_DELAY = 150;

        function startDragFromDrawer(e) {
            if (!isPlaying) return;
            e.preventDefault();
            const wrapper = this, piece = wrapper.pieceRef;
            if (!piece || piece.isPlaced) return;
            
            // é¡¯ç¤ºç·¨è™Ÿæç¤º
            showDrawerHint(wrapper);
            
            // è¨˜éŒ„æ»‘é¼ è³‡è¨Š
            const wrapperRect = wrapper.getBoundingClientRect();
            mouseStartInfo = {
                wrapper: wrapper,
                piece: piece,
                clientX: e.clientX,
                clientY: e.clientY,
                offsetInWrapperX: e.clientX - wrapperRect.left,
                offsetInWrapperY: e.clientY - wrapperRect.top
            };
            isMouseDragging = false;
            
            // å»¶é²å•Ÿå‹•æ‹–æ›³
            mouseDragTimer = setTimeout(() => {
                if (mouseStartInfo) {
                    startActualMouseDrag();
                }
            }, MOUSE_DRAG_DELAY);
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        
        function handleMouseMove(e) {
            if (!mouseStartInfo) return;
            
            // æ›´æ–°ä½ç½®
            mouseStartInfo.clientX = e.clientX;
            mouseStartInfo.clientY = e.clientY;
            
            // å¦‚æœå·²ç¶“åœ¨æ‹–æ›³ï¼Œç§»å‹•æ‹¼åœ–
            if (isMouseDragging && currentPiece) {
                const rect = document.getElementById('puzzleContainer').getBoundingClientRect();
                currentPiece.style.left = (e.clientX - rect.left - currentPiece.offX) + 'px';
                currentPiece.style.top = (e.clientY - rect.top - currentPiece.offY) + 'px';
            }
        }
        
        function startActualMouseDrag() {
            if (!mouseStartInfo) return;
            
            isMouseDragging = true;
            const { wrapper, piece, clientX, clientY, offsetInWrapperX, offsetInWrapperY } = mouseStartInfo;
            
            wrapper.classList.add('dragging');
            // éš±è— drawer ä¸­çš„é è¦½åœ–
            if (wrapper.pieceDiv) wrapper.pieceDiv.style.visibility = 'hidden';
            
            const container = document.getElementById('puzzleContainer');
            const rect = container.getBoundingClientRect();
            
            // ç¢ºä¿ piece ä¸åœ¨ container è£¡ï¼ˆä»¥é˜²è¬ä¸€ï¼‰
            if (piece.parentElement === container) {
                container.removeChild(piece);
            }
            
            // æ‹–æ›³é–‹å§‹æ™‚ç«‹å³è½‰æ­£ï¼ˆä¸å¥—ç”¨æ—‹è½‰ï¼‰
            const baseTransform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
            piece.style.transform = baseTransform;
            
            piece.style.left = (clientX - rect.left - offsetInWrapperX) + 'px';
            piece.style.top = (clientY - rect.top - offsetInWrapperY) + 'px';
            piece.style.zIndex = '1000';
            piece.classList.add('dragging');
            container.appendChild(piece);
            
            currentPiece = piece;
            currentPiece.drawerWrapper = wrapper;
            currentPiece.offX = offsetInWrapperX;
            currentPiece.offY = offsetInWrapperY;
        }
        
        function handleMouseUp() {
            clearTimeout(mouseDragTimer);
            mouseDragTimer = null;
            
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            
            if (!isMouseDragging) {
                // åªæ˜¯çŸ­æŒ‰ï¼Œä¸éœ€è¦è™•ç†æ‹–æ›³
                mouseStartInfo = null;
                return;
            }
            
            if (!currentPiece) {
                mouseStartInfo = null;
                isMouseDragging = false;
                return;
            }
            
            const piece = currentPiece; // ä¿å­˜å¼•ç”¨
            piece.classList.remove('dragging');
            piece.style.zIndex = '';
            
            const left = parseInt(piece.style.left), top = parseInt(piece.style.top);
            
            // ä½ç½®æ­£ç¢ºå°±æ”¾ç½®ï¼Œä¸¦è‡ªå‹•è½‰æ­£
            if (Math.abs(left - piece.correctX) < 15 && Math.abs(top - piece.correctY) < 15) {
                piece.style.transition = 'transform 0.3s';
                piece.style.left = piece.correctX + 'px';
                piece.style.top = piece.correctY + 'px';
                // è‡ªå‹•è½‰æ­£ï¼ˆç§»é™¤æ—‹è½‰ï¼‰
                piece.style.transform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.currentRotation = 0;
                setTimeout(() => piece.style.transition = '', 300);
                piece.isPlaced = true;
                piece.drawerWrapper.classList.add('placed');
                const dp = drawerPieces.find(d => d.piece === piece);
                if (dp) dp.isPlaced = true;
                playSnapSound();
                if (navigator.vibrate) navigator.vibrate(20);
                updateDrawerCount();
                checkWin();
            } else {
                // æ‹–æ›³å¤±æ•—ï¼Œå¾ container ç§»é™¤ piece
                document.getElementById('puzzleContainer').removeChild(piece);
                // é‡ç½® piece çš„æ—‹è½‰ï¼ˆä¿æŒ drawer ä¸­çš„æ—‹è½‰ç‹€æ…‹ï¼‰
                const baseTransform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.style.transform = baseTransform;
                // é¡¯ç¤º drawer ä¸­çš„é è¦½åœ–
                if (piece.drawerWrapper.pieceDiv) {
                    piece.drawerWrapper.pieceDiv.style.visibility = 'visible';
                }
                piece.drawerWrapper.classList.remove('dragging');
                if (navigator.vibrate) navigator.vibrate([30,20,30]);
            }
            
            currentPiece = null;
            mouseStartInfo = null;
            isMouseDragging = false;
        }
        
        function dragFromDrawer(e) {
            // ä¸å†ä½¿ç”¨ï¼Œæ”¹ç”¨ handleMouseMove
        }

        // å¾æŠ½å±œæ‹–æ›³ (è§¸æ§) - åŠ å…¥æ»¾å‹•åˆ¤æ–·
        let touchStartInfo = null;
        let dragDelayTimer = null;
        let isDraggingFromDrawer = false;
        const DRAG_DELAY = 150; // é•·æŒ‰150msæ‰é–‹å§‹æ‹–æ›³
        const SCROLL_THRESHOLD = 10; // ç§»å‹•è¶…é10pxè¦–ç‚ºæ»¾å‹•

        function startTouchFromDrawer(e) {
            if (!isPlaying) return;
            
            const wrapper = this;
            const piece = wrapper.pieceRef;
            if (!piece || piece.isPlaced) return;
            
            // é¡¯ç¤ºç·¨è™Ÿæç¤º
            showDrawerHint(wrapper);
            
            const touch = e.touches[0];
            const wrapperRect = wrapper.getBoundingClientRect();
            
            touchStartInfo = {
                wrapper: wrapper,
                piece: piece,
                startX: touch.clientX,
                startY: touch.clientY,
                lastX: touch.clientX,
                lastY: touch.clientY,
                // è¨˜éŒ„æ‰‹æŒ‡åœ¨ wrapper å…§çš„åç§»
                offsetInWrapperX: touch.clientX - wrapperRect.left,
                offsetInWrapperY: touch.clientY - wrapperRect.top,
                scrollLeft: document.getElementById('puzzleDrawer').scrollLeft,
                scrollTop: document.getElementById('puzzleDrawer').scrollTop
            };
            isDraggingFromDrawer = false;
            
            // å»¶é²å•Ÿå‹•æ‹–æ›³ï¼Œçµ¦æ»¾å‹•æ©Ÿæœƒ
            dragDelayTimer = setTimeout(() => {
                if (touchStartInfo && !isDraggingFromDrawer) {
                    // æª¢æŸ¥æ˜¯å¦å·²ç¶“åœ¨æ»¾å‹•
                    const drawer = document.getElementById('puzzleDrawer');
                    const scrolled = Math.abs(drawer.scrollLeft - touchStartInfo.scrollLeft) > 5 || 
                                    Math.abs(drawer.scrollTop - touchStartInfo.scrollTop) > 5;
                    if (!scrolled) {
                        startActualDrag();
                    }
                }
            }, DRAG_DELAY);
            
            document.addEventListener('touchmove', handleDrawerTouchMove, {passive: false});
            document.addEventListener('touchend', handleDrawerTouchEnd);
        }
        
        function handleDrawerTouchMove(e) {
            if (!touchStartInfo) return;
            
            const touch = e.touches[0];
            const dx = touch.clientX - touchStartInfo.startX;
            const dy = touch.clientY - touchStartInfo.startY;
            
            // æ›´æ–°æœ€å¾Œè§¸æ§ä½ç½®
            touchStartInfo.lastX = touch.clientX;
            touchStartInfo.lastY = touch.clientY;
            
            if (isDraggingFromDrawer) {
                // æ­£åœ¨æ‹–æ›³æ‹¼åœ–
                e.preventDefault();
                const rect = document.getElementById('puzzleContainer').getBoundingClientRect();
                currentPiece.style.left = (touch.clientX - rect.left - currentPiece.offX) + 'px';
                currentPiece.style.top = (touch.clientY - rect.top - currentPiece.offY) + 'px';
            } else {
                // æª¢æŸ¥æ˜¯å¦ç‚ºæ»¾å‹•æ„åœ–
                if (Math.abs(dx) > SCROLL_THRESHOLD || Math.abs(dy) > SCROLL_THRESHOLD) {
                    // å–æ¶ˆæ‹–æ›³ï¼Œå…è¨±æ»¾å‹•
                    clearTimeout(dragDelayTimer);
                    dragDelayTimer = null;
                }
            }
        }
        
        function startActualDrag() {
            if (!touchStartInfo) return;
            
            isDraggingFromDrawer = true;
            const { wrapper, piece, lastX, lastY, offsetInWrapperX, offsetInWrapperY } = touchStartInfo;
            
            wrapper.classList.add('dragging');
            // éš±è— drawer ä¸­çš„é è¦½åœ–
            if (wrapper.pieceDiv) wrapper.pieceDiv.style.visibility = 'hidden';
            
            const container = document.getElementById('puzzleContainer');
            const rect = container.getBoundingClientRect();
            
            // ç¢ºä¿ piece ä¸åœ¨ container è£¡ï¼ˆä»¥é˜²è¬ä¸€ï¼‰
            if (piece.parentElement === container) {
                container.removeChild(piece);
            }
            
            // æ‹–æ›³é–‹å§‹æ™‚ç«‹å³è½‰æ­£ï¼ˆä¸å¥—ç”¨æ—‹è½‰ï¼‰
            const baseTransform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
            piece.style.transform = baseTransform;
            
            // ä½¿ç”¨åç§»é‡ï¼Œè®“æ‹¼åœ–ä¸æœƒè·³å‹•
            piece.style.left = (lastX - rect.left - offsetInWrapperX) + 'px';
            piece.style.top = (lastY - rect.top - offsetInWrapperY) + 'px';
            piece.style.zIndex = '1000';
            piece.classList.add('dragging');
            container.appendChild(piece);
            
            currentPiece = piece;
            currentPiece.drawerWrapper = wrapper;
            // ä¿å­˜åç§»é‡ä¾›ç§»å‹•æ™‚ä½¿ç”¨
            currentPiece.offX = offsetInWrapperX;
            currentPiece.offY = offsetInWrapperY;
            
            if (navigator.vibrate) navigator.vibrate(10);
        }
        
        function handleDrawerTouchEnd() {
            clearTimeout(dragDelayTimer);
            dragDelayTimer = null;
            
            document.removeEventListener('touchmove', handleDrawerTouchMove);
            document.removeEventListener('touchend', handleDrawerTouchEnd);
            
            if (!isDraggingFromDrawer) {
                touchStartInfo = null;
                return;
            }
            
            if (!currentPiece) {
                touchStartInfo = null;
                isDraggingFromDrawer = false;
                return;
            }
            
            const piece = currentPiece; // ä¿å­˜å¼•ç”¨
            piece.classList.remove('dragging');
            piece.style.zIndex = '';
            
            const left = parseInt(piece.style.left), top = parseInt(piece.style.top);
            
            // ä½ç½®æ­£ç¢ºå°±æ”¾ç½®ï¼Œä¸¦è‡ªå‹•è½‰æ­£
            if (Math.abs(left - piece.correctX) < 15 && Math.abs(top - piece.correctY) < 15) {
                piece.style.transition = 'transform 0.3s';
                piece.style.left = piece.correctX + 'px';
                piece.style.top = piece.correctY + 'px';
                // è‡ªå‹•è½‰æ­£ï¼ˆç§»é™¤æ—‹è½‰ï¼‰
                piece.style.transform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.currentRotation = 0;
                setTimeout(() => piece.style.transition = '', 300);
                piece.isPlaced = true;
                piece.drawerWrapper.classList.add('placed');
                const dp = drawerPieces.find(d => d.piece === piece);
                if (dp) dp.isPlaced = true;
                playSnapSound();
                if (navigator.vibrate) navigator.vibrate(20);
                updateDrawerCount();
                checkWin();
            } else {
                // æ‹–æ›³å¤±æ•—ï¼Œå¾ container ç§»é™¤ piece
                document.getElementById('puzzleContainer').removeChild(piece);
                // é‡ç½® piece çš„æ—‹è½‰ï¼ˆä¿æŒ drawer ä¸­çš„æ—‹è½‰ç‹€æ…‹ï¼‰
                const baseTransform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.style.transform = baseTransform;
                // é¡¯ç¤º drawer ä¸­çš„é è¦½åœ–
                if (piece.drawerWrapper.pieceDiv) {
                    piece.drawerWrapper.pieceDiv.style.visibility = 'visible';
                }
                piece.drawerWrapper.classList.remove('dragging');
                if (navigator.vibrate) navigator.vibrate([30,20,30]);
            }
            
            currentPiece = null;
            touchStartInfo = null;
            isDraggingFromDrawer = false;
        }

        function checkWin() {
            if (drawerPieces.every(d => d.isPlaced)) {
                isPlaying = false;
                playWinSound();
                if (navigator.vibrate) navigator.vibrate([100,50,100]);
                // å±•é–‹æ§åˆ¶é¢æ¿
                showControlsDrawer();
                setTimeout(() => showCompletionMessage(), 300);
            }
        }
        
        // é¡¯ç¤ºç¾åŒ–çš„å®Œæˆè¨Šæ¯
        function showCompletionMessage() {
            const msg = document.createElement('div');
            msg.className = 'completion-message';
            msg.innerHTML = 'ğŸ‰ æ­å–œå®Œæˆæ‹¼åœ–ï¼';
            document.body.appendChild(msg);
            setTimeout(() => msg.classList.add('show'), 10);
            setTimeout(() => {
                msg.classList.remove('show');
                setTimeout(() => msg.remove(), 500);
            }, 3000);
        }
        
        // å±•é–‹æ§åˆ¶é¢æ¿
        function showControlsDrawer() {
            controlsCollapsed = false;
            document.getElementById('controlsDrawer').classList.remove('collapsed');
            document.getElementById('controlsToggle').textContent = 'â—€';
        }

        function autoComplete() {
            if (!isPlaying) return;
            const container = document.getElementById('puzzleContainer');
            drawerPieces.forEach((dp, i) => {
                if (!dp.isPlaced) {
                    setTimeout(() => {
                        dp.piece.style.transition = 'all 0.4s';
                        dp.piece.style.left = dp.piece.correctX + 'px';
                        dp.piece.style.top = dp.piece.correctY + 'px';
                        // é‡ç½®æ—‹è½‰è§’åº¦
                        dp.piece.style.transform = dp.piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                        dp.piece.currentRotation = 0;
                        dp.piece.isPlaced = true; dp.isPlaced = true;
                        if (!dp.piece.parentElement) container.appendChild(dp.piece);
                        dp.drawerItem.classList.add('placed');
                        updateDrawerCount();
                    }, i * 80);
                }
            });
            setTimeout(() => { 
                isPlaying = false; 
                playWinSound(); 
                showControlsDrawer();
                showCompletionMessage();
            }, drawerPieces.length * 80 + 500);
        }

        // æç¤ºé–‹é—œ
        document.getElementById('toggleHint').addEventListener('change', function() {
            showHint = this.checked;
            // æ›´æ–°æ‹¼åœ–å€ç·¨è™Ÿ
            document.querySelectorAll('.piece-outline').forEach((o, idx) => {
                const n = o.querySelector('.piece-number');
                if (n) o.removeChild(n);
                if (showHint) {
                    const num = document.createElement('div');
                    num.className = 'piece-number';
                    num.textContent = Math.floor(idx/cols)*cols + (idx%cols) + 1;
                    o.appendChild(num);
                }
            });
        });
        
        // æ—‹è½‰é–‹é—œ
        document.getElementById('toggleRotation').addEventListener('change', function() {
            enableRotation = this.checked;
            // æ›´æ–°æœªæ”¾ç½®æ‹¼åœ–çš„æ—‹è½‰
            drawerPieces.forEach(dp => {
                if (!dp.isPlaced) {
                    const randomRotation = enableRotation ? [0, 90, 180, 270][Math.floor(Math.random() * 4)] : 0;
                    dp.drawerItem.currentRotation = randomRotation;
                    dp.piece.currentRotation = randomRotation;
                    const div = dp.drawerItem.pieceDiv;
                    const tab = dp.drawerItem.tab;
                    if (div) {
                        div.style.transform = randomRotation !== 0 
                            ? `translate(-${tab}px,-${tab}px) rotate(${randomRotation}deg)` 
                            : `translate(-${tab}px,-${tab}px)`;
                    }
                }
            });
        });
        
        // ç‰‡æ•¸æ”¹è®Šæ™‚é‡æ–°é–‹å§‹éŠæˆ²
        document.getElementById('pieceCount').addEventListener('change', function() {
            if (originalImage) {
                startGame();
            }
        });
    </script>
</body>
</html>
