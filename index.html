<!DOCTYPE html>
<html>

<head>
    <title>æ›²ç·šæ‹¼åœ–éŠæˆ²</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            height: 100vh;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }

        .game-area {
            width: 100%;
            height: 100%;
            background-color: #000000;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }

        .puzzle-container {
            position: absolute;
            background-color: #000000;
            box-sizing: border-box;
            /* ä½ç½®ç”± JS å‹•æ…‹è¨­ç½® */
        }

        .puzzle-piece {
            position: absolute;
            cursor: move;
            transition: none;
            background-repeat: no-repeat;
            z-index: 1;
            touch-action: none;
        }

        .puzzle-piece.dragging {
            z-index: 1001;
            filter: brightness(1.1);
        }

        /* æ§åˆ¶é¢æ¿æŠ½å±œ - å°ˆæ¥­æ·±è‰²é¢¨æ ¼ */
        .controls-drawer {
            position: absolute;
            top: 0;
            left: 0;
            width: 200px;
            height: 100%;
            background: rgba(20, 20, 20, 0.95);
            border-right: 2px solid rgba(255, 215, 0, 0.6);
            box-shadow: 2px 0 15px rgba(0,0,0,0.5);
            z-index: 2000;
            transition: transform 0.3s ease;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
            color: white;
        }
        .controls-drawer.collapsed {
            transform: translateX(-200px);
        }
        .controls-toggle {
            position: absolute;
            top: 50%;
            left: 200px;
            transform: translateY(-50%);
            width: 28px;
            height: 50px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-left: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 14px;
            color: white;
            z-index: 2001;
            transition: left 0.3s ease;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }
        .controls-toggle:hover {
            background: rgba(40, 40, 40, 0.95);
        }
        .controls-drawer.collapsed + .controls-toggle {
            left: 0;
        }
        .controls-drawer h1 {
            margin: 0 0 12px 0;
            font-size: 1.2em;
            color: gold;
            text-align: center;
        }
        .controls-drawer .button {
            width: 100%;
            padding: 10px;
            margin: 4px 0;
            background: rgba(255, 215, 0, 0.2);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        .controls-drawer .button:hover {
            background: rgba(255, 215, 0, 0.3);
            border-color: gold;
        }
        .controls-drawer .button:active { 
            background: rgba(255, 215, 0, 0.4);
        }
        .controls-drawer select {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            background: rgba(40, 40, 40, 0.9);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 6px;
        }
        .controls-drawer select option {
            background: #222;
            color: white;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 6px 0;
            font-size: 13px;
            color: #ddd;
        }
        .checkbox-input { 
            width: 16px; 
            height: 16px;
            accent-color: gold;
        }

        /* æµ®å‹•é è¦½åœ– */
        /* æ‹¼åœ–æŠ½å±œ - æ·±è—è‰²èª¿èˆ‡æ‹¼åœ–å€å€éš” */
        .puzzle-drawer {
            position: absolute;
            background: linear-gradient(135deg, rgba(20, 30, 50, 0.95), rgba(30, 40, 60, 0.95));
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            overflow: auto;
            z-index: 100;
            padding: 10px;
            gap: 8px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        /* æ•£äº‚æ¨¡å¼ - é—œé–‰ flex æ’åˆ—ï¼Œç¦æ­¢æ»¾å‹• */
        .puzzle-drawer.scatter-mode {
            display: block;
            overflow: hidden;
        }
        .puzzle-drawer.scatter-mode .drawer-piece-wrapper {
            position: absolute !important;
        }
        .puzzle-drawer.drawer-bottom { bottom: 0; left: 0; right: 0; height: 180px; border-top: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-top { top: 0; left: 0; right: 0; height: 180px; border-bottom: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-left { top: 0; left: 0; bottom: 0; width: 180px; border-right: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-right { top: 0; right: 0; bottom: 0; width: 180px; border-left: 2px solid rgba(100, 150, 255, 0.5); }
        .puzzle-drawer.drawer-none { display: none; }
        
        /* Drawer èª¿æ•´å¤§å°çš„æ‹–æ›³æ¢ï¼ˆç¨ç«‹æ–¼ drawer å¤–ï¼‰ */
        .drawer-resize-handle {
            position: absolute;
            background: rgba(25, 35, 55, 0.95);
            z-index: 150;
            transition: background 0.2s;
            display: none;
        }
        .drawer-resize-handle.visible { display: block; }
        .drawer-resize-handle:hover, .drawer-resize-handle.active {
            background: rgba(60, 100, 180, 0.9);
        }
        .drawer-resize-handle.horizontal {
            left: 0; right: 0; height: 20px; cursor: ns-resize;
        }
        .drawer-resize-handle.vertical {
            width: 20px; cursor: ew-resize;
        }
        .puzzle-drawer.drawer-none { display: none; }

        .drawer-piece-wrapper {
            position: relative;
            cursor: grab;
            flex-shrink: 0;
            margin: 9px;
            overflow: visible;
        }
        .drawer-piece-wrapper.dragging { opacity: 0.3; }
        .drawer-piece-wrapper.placed { display: none; }
        
        .drawer-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 14px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
            pointer-events: none;
        }
        
        .drawer-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: gold;
            font-size: 16px;
            font-weight: bold;
            padding: 4px 10px;
            border-radius: 6px;
            border: 2px solid gold;
            pointer-events: none;
            animation: hintFade 3s ease-out forwards;
        }
        
        @keyframes hintFade {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        .drawer-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 4px;
            z-index: 101;
        }
        .drawer-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 12px;
            cursor: pointer;
        }
        .drawer-btn:hover { background: rgba(0,0,0,0.9); }
        .drawer-btn.active { background: rgba(74,144,217,0.8); border-color: #4a90d9; }
        .drawer-btn.shuffle-btn { background: rgba(0,0,0,0.7); }
        .drawer-btn.shuffle-btn:hover { background: rgba(0,0,0,0.9); }
        
        /* å®Œæˆè¨Šæ¯ */
        .completion-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(0,0,0,0.9);
            color: white;
            font-size: 28px;
            font-weight: bold;
            padding: 30px 50px;
            border-radius: 20px;
            border: 3px solid gold;
            z-index: 9999;
            opacity: 0;
            transition: all 0.3s ease;
            text-align: center;
        }
        .completion-message.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        /* è¼‰å…¥é€²åº¦ */
        .progress-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .progress-text {
            color: gold;
            font-size: 20px;
            margin-bottom: 20px;
        }
        .progress-bar {
            width: 250px;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid gold;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, gold, orange);
            width: 0%;
            transition: width 0.1s;
        }
        
        .drawer-count {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 12px;
            z-index: 101;
        }

        .piece-outline { pointer-events: none; }
        .puzzle-piece.dragging {
            z-index: 1000 !important;
        }
        .piece-number {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            pointer-events: none;
        }

        /* é•·æŒ‰é è¦½ */
        .preview-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .preview-overlay.show { display: flex; }
        .preview-overlay img { max-width: 90%; max-height: 90%; }
    </style>
</head>

<body>
    <div class="game-area" id="gameArea">
        <div id="puzzleContainer" class="puzzle-container"></div>
        
        <!-- æ§åˆ¶é¢æ¿æŠ½å±œ -->
        <div class="controls-drawer" id="controlsDrawer">
            <h1>ğŸ§© æ‹¼åœ–éŠæˆ²</h1>
            <input type="file" id="imageInput" accept="image/*" style="display:none;">
            <button class="button" onclick="selectImage()">ğŸ“· é¸æ“‡åœ–ç‰‡</button>
            <select id="pieceCount">
                <option value="25">5x5 (25ç‰‡)</option>
                <option value="36">6x6 (36ç‰‡)</option>
                <option value="49">7x7 (49ç‰‡)</option>
                <option value="64">8x8 (64ç‰‡)</option>
                <option value="81">9x9 (81ç‰‡)</option>
                <option value="100">10x10 (100ç‰‡)</option>
                <option value="121">11x11 (121ç‰‡)</option>
                <option value="144">12x12 (144ç‰‡)</option>
                <option value="169">13x13 (169ç‰‡)</option>
                <option value="196">14x14 (196ç‰‡)</option>
                <option value="225">15x15 (225ç‰‡)</option>
                <option value="256">16x16 (256ç‰‡)</option>
                <option value="289">17x17 (289ç‰‡)</option>
                <option value="324">18x18 (324ç‰‡)</option>
                <option value="361">19x19 (361ç‰‡)</option>
                <option value="400">20x20 (400ç‰‡)</option>
            </select>
            <button class="button" onclick="startGame()">â–¶ é–‹å§‹éŠæˆ²</button>
            <button class="button" onclick="autoComplete()">âœ¨ è‡ªå‹•å®Œæˆ</button>
            <div class="checkbox-container">
                <input type="checkbox" id="toggleHint" class="checkbox-input">
                <label for="toggleHint" class="checkbox-label">æç¤º</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="toggleRotation" class="checkbox-input">
                <label for="toggleRotation" class="checkbox-label">æ—‹è½‰</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="toggleScatter" class="checkbox-input">
                <label for="toggleScatter" class="checkbox-label">æ•£äº‚</label>
            </div>
            <div style="margin-top:10px; font-size:10px; color:#aaa;">ğŸ’¡ é•·æŒ‰ç©ºç™½è™•æŸ¥çœ‹åŸåœ–</div>
        </div>
        <button class="controls-toggle" id="controlsToggle" onclick="toggleControls()">â—€</button>
        
        <!-- æŠ½å±œæ§åˆ¶ -->
        <div class="drawer-count" id="drawerCount">å‰©é¤˜: 0 å¡Š</div>
        <div class="drawer-controls">
            <button class="drawer-btn" onclick="setDrawerPosition('top')">â¬†</button>
            <button class="drawer-btn active" onclick="setDrawerPosition('bottom')">â¬‡</button>
            <button class="drawer-btn" onclick="setDrawerPosition('left')">â¬…</button>
            <button class="drawer-btn" onclick="setDrawerPosition('right')">â¡</button>
            <button class="drawer-btn" onclick="setDrawerPosition('none')">âœ•</button>
            <button class="drawer-btn shuffle-btn" onclick="shuffleDrawer()">ğŸ”€</button>
        </div>
        
        <!-- æ‹¼åœ–æŠ½å±œ -->
        <div class="puzzle-drawer drawer-bottom" id="puzzleDrawer"></div>
        <!-- Drawer å¤§å°èª¿æ•´æ‹–æ›³æ¢ï¼ˆç¨ç«‹æ–¼ drawer å¤–ï¼‰ -->
        <div class="drawer-resize-handle horizontal" id="drawerResizeHandle"></div>
    </div>

    <div class="preview-overlay" id="previewOverlay">
        <img id="previewOverlayImg" src="">
    </div>

    <script>
        // å…¨å±€è®Šé‡
        let originalImage = null;
        let pieces = [];
        let currentPiece = null;
        let isPlaying = false;
        let edges = null;
        let showHint = false;
        let enableRotation = false;
        let scatterMode = false; // æ•£äº‚æ¨¡å¼
        let rows, cols;
        let drawerPosition = 'bottom';
        let drawerPieces = [];
        let audioContext = null;
        let controlsCollapsed = false;
        let drawerPieceZIndex = 1; // æ•£äº‚æ¨¡å¼ä¸­æ‹¼åœ–çš„ z-index è¨ˆæ•¸å™¨
        
        // å­˜æª”ç›¸é—œ
        const SAVE_KEY = 'jigsaw_puzzle_save';
        let autoSaveTimer = null;
        
        // æ‹¼åœ–å€æ‹–æ›³ç›¸é—œ
        let containerDrag = {
            active: false,
            startX: 0,
            startY: 0,
            startLeft: 0,
            startTop: 0
        };
        let containerOriginalPos = { left: 0, top: 0 };
        let containerDragLimit = { x: 0, y: 0 };
        
        // Drawer å¤§å°èª¿æ•´ç›¸é—œ
        let drawerResize = {
            active: false,
            startPos: 0,
            startSize: 0
        };
        let drawerSize = 180; // åˆå§‹å¤§å°
        let pieceWidth = 0, pieceHeight = 0; // å–®å€‹æ‹¼åœ–å¤§å°ï¼ˆå« tabï¼‰
        
        // å…©æŒ‡ç¸®æ”¾ç›¸é—œ
        let pinchZoom = {
            active: false,
            startDistance: 0,
            startScale: 1
        };
        let containerScale = 1; // ç›®å‰ç¸®æ”¾æ¯”ä¾‹
        let baseContainerWidth = 0, baseContainerHeight = 0; // åŸå§‹å®¹å™¨å¤§å°

        // é¸æ“‡åœ–ç‰‡
        function selectImage() {
            document.getElementById('imageInput').click();
        }

        // æ§åˆ¶é¢æ¿æ”¶åˆ
        function toggleControls() {
            controlsCollapsed = !controlsCollapsed;
            document.getElementById('controlsDrawer').classList.toggle('collapsed', controlsCollapsed);
            document.getElementById('controlsToggle').textContent = controlsCollapsed ? 'â–¶' : 'â—€';
        }

        // éŸ³æ•ˆ
        function playSnapSound() {
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain); gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(880, audioContext.currentTime);
                osc.frequency.setValueAtTime(1175, audioContext.currentTime + 0.05);
                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                osc.start(); osc.stop(audioContext.currentTime + 0.15);
            } catch(e) {}
        }
        
        function playWinSound() {
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                [523, 659, 784, 1047].forEach((f, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain); gain.connect(audioContext.destination);
                    osc.frequency.setValueAtTime(f, audioContext.currentTime);
                    const t = audioContext.currentTime + i * 0.12;
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.3, t + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                    osc.start(t); osc.stop(t + 0.3);
                });
            } catch(e) {}
        }

        // æŠ½å±œæ§åˆ¶
        function setDrawerPosition(pos) {
            const wasScatterMode = scatterMode;
            drawerPosition = pos;
            const drawer = document.getElementById('puzzleDrawer');
            const handle = document.getElementById('drawerResizeHandle');
            const gameArea = document.getElementById('gameArea');
            
            drawer.className = 'puzzle-drawer drawer-' + pos + (wasScatterMode ? ' scatter-mode' : '');
            document.querySelectorAll('.drawer-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            // æ›´æ–° resize handle æ–¹å‘ã€ä½ç½®å’Œ drawer å¤§å°ï¼ˆç·Šè²¼ drawer é‚Šç·£ï¼‰
            if (pos === 'none') {
                handle.classList.remove('visible');
            } else if (pos === 'top' || pos === 'bottom') {
                handle.className = 'drawer-resize-handle horizontal visible';
                drawer.style.width = '';
                drawer.style.height = drawerSize + 'px';
                handle.style.top = (pos === 'bottom') ? (gameArea.offsetHeight - drawerSize - 20) + 'px' : drawerSize + 'px';
                handle.style.bottom = '';
                handle.style.left = '0';
                handle.style.right = '0';
            } else if (pos === 'left' || pos === 'right') {
                handle.className = 'drawer-resize-handle vertical visible';
                drawer.style.height = '';
                drawer.style.width = drawerSize + 'px';
                handle.style.left = (pos === 'left') ? drawerSize + 'px' : '';
                handle.style.right = (pos === 'right') ? (drawerSize + 20) + 'px' : '';
                handle.style.top = '0';
                handle.style.bottom = '0';
            }
            
            // åªæ›´æ–°ä½ç½®ï¼Œä¸æ”¹è®Šå¤§å°
            if (originalImage && isPlaying) {
                const container = document.getElementById('puzzleContainer');
                const w = parseFloat(container.style.width);
                const h = parseFloat(container.style.height);
                const newPos = calculateContainerPosition(w, h);
                container.style.left = newPos.left + 'px';
                container.style.top = newPos.top + 'px';
                // æ›´æ–°åŸå§‹ä½ç½®ï¼ˆé‡ç½®æ‹–æ›³ï¼‰
                containerOriginalPos = { left: newPos.left, top: newPos.top };
            }
            
            // æ•£äº‚æ¨¡å¼ä¸‹ï¼Œåˆ‡æ› drawer æ–¹å‘æ™‚é‡æ–°æ’åˆ—
            if (wasScatterMode && pos !== 'none') {
                repositionScatteredPieces();
            }
        }
        
        // é‡æ–°æ’åˆ—æ•£äº‚æ¨¡å¼çš„æ‹¼åœ–ï¼ˆè®“å®ƒå€‘éš¨æ©Ÿæ•£è½åœ¨å¯è¦–å€å…§ï¼‰
        function repositionScatteredPieces() {
            if (!scatterMode || drawerPieces.length === 0) return;
            
            const drawer = document.getElementById('puzzleDrawer');
            const isVerticalDrawer = (drawerPosition === 'left' || drawerPosition === 'right');
            
            // drawer çš„å¯¦éš›å¯è¦–å°ºå¯¸
            const drawerW = isVerticalDrawer ? drawerSize : drawer.offsetWidth;
            const drawerH = isVerticalDrawer ? drawer.offsetHeight : drawerSize;
            
            // å–å¾—æœªæ”¾ç½®çš„æ‹¼åœ–
            const unplacedPieces = drawerPieces.filter(dp => !dp.isPlaced);
            if (unplacedPieces.length === 0) return;
            
            // éš¨æ©Ÿæ”¾ç½®ç¯„åœï¼ˆç•™ä¸€é»é‚Šè·ï¼Œä½†æ‹¼åœ–å¯ä»¥é‡ç–Šã€å¯ä»¥éƒ¨åˆ†è¶…å‡ºï¼‰
            const maxX = Math.max(10, drawerW - 50);
            const maxY = Math.max(10, drawerH - 50);
            
            unplacedPieces.forEach(dp => {
                const item = dp.drawerItem;
                // ç›´æ¥ç”¨äº‚æ•¸æ”¾ç½®
                item.style.left = (Math.random() * maxX) + 'px';
                item.style.top = (Math.random() * maxY) + 'px';
                item.style.zIndex = drawerPieceZIndex++;
            });
        }
        
        // æ›´æ–° resize handle ä½ç½®ï¼ˆç•¶ drawer å¤§å°æ”¹è®Šæ™‚å‘¼å«ï¼Œç·Šè²¼ drawer é‚Šç·£ï¼‰
        function updateResizeHandlePosition() {
            const handle = document.getElementById('drawerResizeHandle');
            const gameArea = document.getElementById('gameArea');
            
            if (drawerPosition === 'bottom') {
                handle.style.top = (gameArea.offsetHeight - drawerSize - 20) + 'px';
            } else if (drawerPosition === 'top') {
                handle.style.top = drawerSize + 'px';
            } else if (drawerPosition === 'left') {
                handle.style.left = drawerSize + 'px';
                handle.style.right = '';
            } else if (drawerPosition === 'right') {
                handle.style.right = (drawerSize + 20) + 'px';
                handle.style.left = '';
            }
        }
        
        function updateDrawerCount() {
            document.getElementById('drawerCount').textContent = 'å‰©é¤˜: ' + drawerPieces.filter(d => !d.isPlaced).length + ' å¡Š';
        }
        
        function shuffleDrawer() {
            const drawer = document.getElementById('puzzleDrawer');
            
            // æ•£äº‚æ¨¡å¼ï¼šé‡æ–°éš¨æ©Ÿæ”¾ç½®æ‰€æœ‰æœªæ”¾ç½®çš„æ‹¼åœ–
            if (scatterMode) {
                repositionScatteredPieces();
                return;
            }
            
            // éæ•£äº‚æ¨¡å¼ï¼šé‡æ–°æ’åˆ— DOM é †åº
            const items = Array.from(drawer.children);
            for (let i = items.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                drawer.appendChild(items[j]);
            }
        }
        
        function updateDrawerLabels() {
            // åªæ›´æ–°ç‹€æ…‹ï¼Œä¸æ·»åŠ æ°¸ä¹…æ¨™ç±¤
            // å‹¾é¸å¾Œé»æ“Šæ‹¼åœ–æœƒé¡¯ç¤º 3 ç§’æç¤º
        }

        // é•·æŒ‰é è¦½
        let longPressTimer = null;
        
        function showFullPreview() {
            if (!originalImage) return;
            document.getElementById('previewOverlayImg').src = originalImage.src;
            document.getElementById('previewOverlay').classList.add('show');
            if (navigator.vibrate) navigator.vibrate(30);
        }
        
        function hideFullPreview() {
            document.getElementById('previewOverlay').classList.remove('show');
        }
        
        document.getElementById('gameArea').addEventListener('touchstart', function(e) {
            // å…©æŒ‡ä»¥ä¸Šä¸è§¸ç™¼é•·æŒ‰é è¦½
            if (e.touches.length > 1) {
                clearTimeout(longPressTimer);
                return;
            }
            if (e.target.closest('.drawer-piece-wrapper') || e.target.closest('.drawer-btn') || 
                e.target.closest('.puzzle-drawer') || e.target.closest('.controls-drawer') ||
                e.target.closest('.controls-toggle') || e.target.closest('.drawer-resize-handle')) return;
            longPressTimer = setTimeout(showFullPreview, 500);
        }, {passive: true});
        
        document.getElementById('gameArea').addEventListener('touchend', function() {
            clearTimeout(longPressTimer); hideFullPreview();
        }, {passive: true});
        
        document.getElementById('gameArea').addEventListener('touchmove', function(e) {
            // å…©æŒ‡ç¸®æ”¾æ™‚ä¹Ÿå–æ¶ˆé•·æŒ‰
            if (e.touches.length > 1) {
                clearTimeout(longPressTimer);
                hideFullPreview();
            }
            clearTimeout(longPressTimer);
        }, {passive: true});
        
        document.getElementById('previewOverlay').addEventListener('click', hideFullPreview);

        // æ‹¼åœ–å€æ‹–æ›³åŠŸèƒ½
        function initContainerDrag() {
            const gameArea = document.getElementById('gameArea');
            const container = document.getElementById('puzzleContainer');
            
            // æ»‘é¼ äº‹ä»¶ - åœ¨ game-area ç©ºç™½è™•æ‹–æ›³æ•´å€‹æ‹¼åœ–å€
            gameArea.addEventListener('mousedown', function(e) {
                if (!isPlaying) return;
                // æ’é™¤ UI å…ƒç´ 
                if (e.target.closest('.puzzle-piece') || 
                    e.target.closest('.drawer-piece-wrapper') ||
                    e.target.closest('.puzzle-drawer') ||
                    e.target.closest('.controls-drawer') ||
                    e.target.closest('.controls-toggle') ||
                    e.target.closest('.drawer-controls')) return;
                
                containerDrag.active = true;
                containerDrag.startX = e.clientX;
                containerDrag.startY = e.clientY;
                containerDrag.startLeft = parseFloat(container.style.left) || 0;
                containerDrag.startTop = parseFloat(container.style.top) || 0;
                e.preventDefault();
            });
            
            // è§¸æ§äº‹ä»¶ - åœ¨ game-area ç©ºç™½è™•æ‹–æ›³æ•´å€‹æ‹¼åœ–å€
            gameArea.addEventListener('touchstart', function(e) {
                if (!isPlaying) return;
                if (e.target.closest('.puzzle-piece') || 
                    e.target.closest('.drawer-piece-wrapper') ||
                    e.target.closest('.puzzle-drawer') ||
                    e.target.closest('.controls-drawer') ||
                    e.target.closest('.controls-toggle') ||
                    e.target.closest('.drawer-controls')) return;
                
                const touch = e.touches[0];
                containerDrag.active = true;
                containerDrag.startX = touch.clientX;
                containerDrag.startY = touch.clientY;
                containerDrag.startLeft = parseFloat(container.style.left) || 0;
                containerDrag.startTop = parseFloat(container.style.top) || 0;
            }, {passive: true});
        }
        
        document.addEventListener('mousemove', function(e) {
            if (!containerDrag.active) return;
            
            const container = document.getElementById('puzzleContainer');
            const dx = e.clientX - containerDrag.startX;
            const dy = e.clientY - containerDrag.startY;
            
            // é™åˆ¶æ‹–æ›³ç¯„åœ
            let newLeft = containerDrag.startLeft + dx;
            let newTop = containerDrag.startTop + dy;
            
            newLeft = Math.max(containerOriginalPos.left - containerDragLimit.x, 
                              Math.min(containerOriginalPos.left + containerDragLimit.x, newLeft));
            newTop = Math.max(containerOriginalPos.top - containerDragLimit.y, 
                             Math.min(containerOriginalPos.top + containerDragLimit.y, newTop));
            
            container.style.left = newLeft + 'px';
            container.style.top = newTop + 'px';
        });
        
        document.addEventListener('touchmove', function(e) {
            if (!containerDrag.active) return;
            
            const touch = e.touches[0];
            const container = document.getElementById('puzzleContainer');
            const dx = touch.clientX - containerDrag.startX;
            const dy = touch.clientY - containerDrag.startY;
            
            // é™åˆ¶æ‹–æ›³ç¯„åœ
            let newLeft = containerDrag.startLeft + dx;
            let newTop = containerDrag.startTop + dy;
            
            newLeft = Math.max(containerOriginalPos.left - containerDragLimit.x, 
                              Math.min(containerOriginalPos.left + containerDragLimit.x, newLeft));
            newTop = Math.max(containerOriginalPos.top - containerDragLimit.y, 
                             Math.min(containerOriginalPos.top + containerDragLimit.y, newTop));
            
            container.style.left = newLeft + 'px';
            container.style.top = newTop + 'px';
        }, {passive: true});
        
        document.addEventListener('mouseup', function() {
            containerDrag.active = false;
            if (drawerResize.active) {
                drawerResize.active = false;
                document.getElementById('drawerResizeHandle').classList.remove('active');
            }
        });
        
        document.addEventListener('touchend', function() {
            containerDrag.active = false;
            if (drawerResize.active) {
                drawerResize.active = false;
                document.getElementById('drawerResizeHandle').classList.remove('active');
            }
        });
        
        // åˆå§‹åŒ–æ‹–æ›³äº‹ä»¶
        initContainerDrag();
        
        // Drawer å¤§å°èª¿æ•´åŠŸèƒ½
        function initDrawerResize() {
            const handle = document.getElementById('drawerResizeHandle');
            const drawer = document.getElementById('puzzleDrawer');
            const gameArea = document.getElementById('gameArea');
            
            handle.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation();
                drawerResize.active = true;
                handle.classList.add('active');
                
                if (drawerPosition === 'top' || drawerPosition === 'bottom') {
                    drawerResize.startPos = e.clientY;
                    drawerResize.startSize = drawer.offsetHeight;
                } else {
                    drawerResize.startPos = e.clientX;
                    drawerResize.startSize = drawer.offsetWidth;
                }
            });
            
            handle.addEventListener('touchstart', function(e) {
                e.stopPropagation();
                drawerResize.active = true;
                handle.classList.add('active');
                const touch = e.touches[0];
                
                if (drawerPosition === 'top' || drawerPosition === 'bottom') {
                    drawerResize.startPos = touch.clientY;
                    drawerResize.startSize = drawer.offsetHeight;
                } else {
                    drawerResize.startPos = touch.clientX;
                    drawerResize.startSize = drawer.offsetWidth;
                }
            }, {passive: true});
        }
        
        document.addEventListener('mousemove', function(e) {
            if (!drawerResize.active) return;
            
            const gameArea = document.getElementById('gameArea');
            const drawer = document.getElementById('puzzleDrawer');
            let newSize;
            
            if (drawerPosition === 'bottom') {
                newSize = drawerResize.startSize - (e.clientY - drawerResize.startPos);
            } else if (drawerPosition === 'top') {
                newSize = drawerResize.startSize + (e.clientY - drawerResize.startPos);
            } else if (drawerPosition === 'right') {
                newSize = drawerResize.startSize - (e.clientX - drawerResize.startPos);
            } else if (drawerPosition === 'left') {
                newSize = drawerResize.startSize + (e.clientX - drawerResize.startPos);
            }
            
            // é™åˆ¶ç¯„åœï¼šæœ€å°å®¹ç´ä¸€å€‹æ‹¼åœ–ï¼Œæœ€å¤§ 1/2 è¢å¹•
            const isVertical = (drawerPosition === 'top' || drawerPosition === 'bottom');
            const maxDimension = isVertical ? gameArea.offsetHeight : gameArea.offsetWidth;
            const minSize = isVertical ? (pieceHeight || 100) : (pieceWidth || 100);
            const maxSize = maxDimension / 2;
            
            newSize = Math.max(minSize, Math.min(maxSize, newSize));
            drawerSize = newSize;
            
            if (isVertical) {
                drawer.style.height = newSize + 'px';
            } else {
                drawer.style.width = newSize + 'px';
            }
            
            // æ›´æ–° resize handle ä½ç½®
            updateResizeHandlePosition();
            
            // æ›´æ–°æ‹¼åœ–å€ä½ç½®
            if (originalImage && isPlaying) {
                const container = document.getElementById('puzzleContainer');
                const w = parseFloat(container.style.width);
                const h = parseFloat(container.style.height);
                const newPos = calculateContainerPosition(w, h);
                container.style.left = newPos.left + 'px';
                container.style.top = newPos.top + 'px';
                containerOriginalPos = { left: newPos.left, top: newPos.top };
            }
        });
        
        document.addEventListener('touchmove', function(e) {
            if (!drawerResize.active) return;
            
            const touch = e.touches[0];
            const gameArea = document.getElementById('gameArea');
            const drawer = document.getElementById('puzzleDrawer');
            let newSize;
            
            if (drawerPosition === 'bottom') {
                newSize = drawerResize.startSize - (touch.clientY - drawerResize.startPos);
            } else if (drawerPosition === 'top') {
                newSize = drawerResize.startSize + (touch.clientY - drawerResize.startPos);
            } else if (drawerPosition === 'right') {
                newSize = drawerResize.startSize - (touch.clientX - drawerResize.startPos);
            } else if (drawerPosition === 'left') {
                newSize = drawerResize.startSize + (touch.clientX - drawerResize.startPos);
            }
            
            // é™åˆ¶ç¯„åœï¼šæœ€å°å®¹ç´ä¸€å€‹æ‹¼åœ–ï¼Œæœ€å¤§ 1/2 è¢å¹•
            const isVertical2 = (drawerPosition === 'top' || drawerPosition === 'bottom');
            const maxDimension2 = isVertical2 ? gameArea.offsetHeight : gameArea.offsetWidth;
            const minSize2 = isVertical2 ? (pieceHeight || 100) : (pieceWidth || 100);
            const maxSize2 = maxDimension2 / 2;
            
            newSize = Math.max(minSize2, Math.min(maxSize2, newSize));
            drawerSize = newSize;
            
            if (isVertical2) {
                drawer.style.height = newSize + 'px';
            } else {
                drawer.style.width = newSize + 'px';
            }
            
            // æ›´æ–° resize handle ä½ç½®
            updateResizeHandlePosition();
            
            // æ›´æ–°æ‹¼åœ–å€ä½ç½®
            if (originalImage && isPlaying) {
                const container = document.getElementById('puzzleContainer');
                const w = parseFloat(container.style.width);
                const h = parseFloat(container.style.height);
                const newPos = calculateContainerPosition(w, h);
                container.style.left = newPos.left + 'px';
                container.style.top = newPos.top + 'px';
                containerOriginalPos = { left: newPos.left, top: newPos.top };
            }
        }, {passive: true});
        
        // åˆå§‹åŒ– drawer resize
        initDrawerResize();
        
        // å…©æŒ‡ç¸®æ”¾åŠŸèƒ½
        function getDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function initPinchZoom() {
            const gameArea = document.getElementById('gameArea');
            
            gameArea.addEventListener('touchstart', function(e) {
                if (!isPlaying) return;
                if (e.touches.length === 2) {
                    // æª¢æŸ¥å…©æ ¹æ‰‹æŒ‡æ˜¯å¦éƒ½åœ¨æ‹¼åœ–å€å…§
                    const container = document.getElementById('puzzleContainer');
                    const containerRect = container.getBoundingClientRect();
                    
                    let bothInContainer = true;
                    for (let i = 0; i < 2; i++) {
                        const touch = e.touches[i];
                        const x = touch.clientX;
                        const y = touch.clientY;
                        
                        // å¿…é ˆåœ¨ container ç¯„åœå…§
                        if (x < containerRect.left || x > containerRect.right ||
                            y < containerRect.top || y > containerRect.bottom) {
                            bothInContainer = false;
                            break;
                        }
                    }
                    
                    if (!bothInContainer) return;
                    
                    pinchZoom.active = true;
                    pinchZoom.startDistance = getDistance(e.touches);
                    pinchZoom.startScale = containerScale;
                    e.preventDefault();
                }
            }, {passive: false});
            
            gameArea.addEventListener('touchmove', function(e) {
                if (!pinchZoom.active || e.touches.length !== 2) return;
                
                const currentDistance = getDistance(e.touches);
                const scale = (currentDistance / pinchZoom.startDistance) * pinchZoom.startScale;
                
                // é™åˆ¶ç¸®æ”¾ç¯„åœï¼š0.5 ~ 2.0
                containerScale = Math.max(0.5, Math.min(2.0, scale));
                
                const container = document.getElementById('puzzleContainer');
                container.style.transform = `scale(${containerScale})`;
                
                e.preventDefault();
            }, {passive: false});
            
            gameArea.addEventListener('touchend', function(e) {
                if (e.touches.length < 2) {
                    pinchZoom.active = false;
                }
            });
        }
        
        initPinchZoom();

        // æ‹¼åœ–è·¯å¾‘ç”Ÿæˆ - æ¨™æº–ç‰ˆæœ¬
        function generateCurvedPath(width, height, edges) {
            const { top, right, bottom, left } = edges;
            const tabHeight = Math.min(width, height) * 0.15;
            const tabWidth = Math.min(width, height) * 0.5;

            let path = `M ${tabHeight},${tabHeight}`;
            
            // Top
            if (top === 'tab') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${(width-tabWidth)/2}`;
            else if (top === 'slot') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${(width-tabWidth)/2}`;
            else path += ` h ${width}`;
            
            // Right
            if (right === 'tab') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else if (right === 'slot') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else path += ` v ${height}`;
            
            // Bottom
            if (bottom === 'tab') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${(width-tabWidth)/2}`;
            else if (bottom === 'slot') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${(width-tabWidth)/2}`;
            else path += ` h -${width}`;
            
            // Left
            if (left === 'tab') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else if (left === 'slot') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else path += ` v -${height}`;
            
            return path + ' Z';
        }

        function generateEdges(rows, cols) {
            const p = Array(rows).fill().map(() => Array(cols).fill().map(() => ({top:null,right:null,bottom:null,left:null})));
            for (let i = 0; i < rows-1; i++) for (let j = 0; j < cols; j++) { const t = Math.random() < 0.5; p[i][j].bottom = t ? 'tab' : 'slot'; p[i+1][j].top = t ? 'slot' : 'tab'; }
            for (let i = 0; i < rows; i++) for (let j = 0; j < cols-1; j++) { const t = Math.random() < 0.5; p[i][j].right = t ? 'tab' : 'slot'; p[i][j+1].left = t ? 'slot' : 'tab'; }
            return p;
        }

        // åœ–ç‰‡è¼‰å…¥
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(ev) { loadImage(ev.target.result); };
                reader.readAsDataURL(file);
            }
            e.target.value = '';
        });

        function loadImage(src) {
            originalImage = new Image();
            originalImage.onload = function() {
                startGame();
            };
            originalImage.src = src;
        }

        // è¨ˆç®—æ‹¼åœ–å€å¤§å°ï¼ˆåªåœ¨é–‹å§‹éŠæˆ²æ™‚èª¿ç”¨ä¸€æ¬¡ï¼‰
        // ä½¿ç”¨æœ€å°å¯ç”¨ç©ºé–“ï¼Œç¢ºä¿ drawer åœ¨ä»»ä½•ä½ç½®éƒ½ä¸æœƒè¶…å‡º
        function calculateContainerSize() {
            const gameArea = document.querySelector('.game-area');
            const totalWidth = gameArea.offsetWidth;
            const totalHeight = gameArea.offsetHeight;
            
            const tabMargin = 10; // é ç•™ tab çªå‡ºç©ºé–“ï¼ˆæœ€å°åŒ–ï¼‰
            
            // åŒæ™‚é ç•™ä¸Šä¸‹å’Œå·¦å³çš„ drawer ç©ºé–“ï¼Œå–æœ€å°å¯ç”¨å€åŸŸ
            // é€™æ¨£ç„¡è«– drawer åœ¨å“ªå€‹æ–¹å‘ï¼Œæ‹¼åœ–å€éƒ½èƒ½å®Œæ•´é¡¯ç¤º
            const availableWidth = totalWidth - drawerSize - tabMargin * 2;
            const availableHeight = totalHeight - drawerSize - tabMargin * 2;
            
            // æ ¹æ“šåœ–ç‰‡æ¯”ä¾‹è¨ˆç®—æ‹¼åœ–å€å¤§å°
            const ratio = originalImage.width / originalImage.height;
            let w, h;
            if (availableWidth / availableHeight > ratio) {
                h = availableHeight;
                w = h * ratio;
            } else {
                w = availableWidth;
                h = w / ratio;
            }
            
            return { width: w, height: h };
        }
        
        // è¨ˆç®—æ‹¼åœ–å€ä½ç½®ï¼ˆåˆ‡æ›æŠ½å±œæ–¹å‘æ™‚èª¿ç”¨ï¼‰
        function calculateContainerPosition(containerWidth, containerHeight) {
            const gameArea = document.querySelector('.game-area');
            const totalWidth = gameArea.offsetWidth;
            const totalHeight = gameArea.offsetHeight;
            
            // è¨ˆç®—å¯ç”¨å€åŸŸçš„é‚Šç•Œ
            let left = 0, top = 0;
            let right = totalWidth;
            let bottom = totalHeight;
            
            // æ ¹æ“šæŠ½å±œä½ç½®èª¿æ•´é‚Šç•Œ
            if (drawerPosition === 'left') left = drawerSize;
            else if (drawerPosition === 'right') right = totalWidth - drawerSize;
            else if (drawerPosition === 'top') top = drawerSize;
            else if (drawerPosition === 'bottom') bottom = totalHeight - drawerSize;
            
            const availableWidth = right - left;
            const availableHeight = bottom - top;
            
            // è¨ˆç®—ç½®ä¸­ä½ç½®
            const centerX = left + (availableWidth - containerWidth) / 2;
            const centerY = top + (availableHeight - containerHeight) / 2;
            
            return { left: centerX, top: centerY };
        }

        // å‰µå»ºæ‹¼åœ–å¡Š - åœ–ç‰‡å…§ç¸®ï¼Œè®“é‚Šç·£æ‹¼åœ–æœ‰å»¶ä¼¸ç©ºé–“
        function createPuzzlePiece(i, j, pw, ph, size, ed) {
            const piece = document.createElement('div');
            piece.className = 'puzzle-piece';
            const tab = Math.min(pw, ph) * 0.15;
            
            // é‚Šç·£æ‹¼åœ–ä½¿ç”¨å»¶ä¼¸è·¯å¾‘
            const path = generatePiecePath(pw, ph, ed);
            
            const actualW = pw + 2*tab;
            const actualH = ph + 2*tab;
            
            // åœ–ç‰‡å…§ç¸®ï¼šè®“åœ–ç‰‡å¾ tab ä½ç½®é–‹å§‹ï¼Œå››å‘¨ç•™å‡º tab ç©ºé–“
            // èƒŒæ™¯åœ–å¤§å°ä¸è®Šï¼Œä½†ä½ç½®å¾€å…§åç§» tab
            const bgX = -(j * pw) + tab;
            const bgY = -(i * ph) + tab;
            
            piece.style.cssText = `width:${actualW}px; height:${actualH}px; background-image:url(${originalImage.src}); background-size:${size.width}px ${size.height}px; background-position:${bgX}px ${bgY}px; background-repeat:no-repeat; clip-path:path('${path}'); -webkit-clip-path:path('${path}'); position:absolute; transform:translate(-${tab}px,-${tab}px);`;
            piece.correctX = j * pw;
            piece.correctY = i * ph;
            piece.pieceNumber = i * cols + j + 1;
            piece.isPlaced = false;
            piece.edges = ed;  // å„²å­˜é‚Šç·£è³‡è¨Šä¾› drawer é‚Šæ¡†ä½¿ç”¨
            return piece;
        }
        
        // æ‹¼åœ–å¡Šè·¯å¾‘ - å¹³ç›´é‚Šå»¶ä¼¸åˆ° tab ä½ç½®
        function generatePiecePath(width, height, edges) {
            const { top, right, bottom, left } = edges;
            const tabHeight = Math.min(width, height) * 0.15;
            const tabWidth = Math.min(width, height) * 0.5;

            let path = `M ${tabHeight},${tabHeight}`;
            
            // Top
            if (top === 'tab') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${(width-tabWidth)/2}`;
            else if (top === 'slot') path += ` h ${(width-tabWidth)/2} c ${tabWidth/6},0 ${tabWidth/6},${tabHeight} ${tabWidth/3},${tabHeight} h ${tabWidth/3} c ${tabWidth/6},0 ${tabWidth/6},-${tabHeight} ${tabWidth/3},-${tabHeight} h ${(width-tabWidth)/2}`;
            else path += ` v -${tabHeight} h ${width} v ${tabHeight}`;
            
            // Right
            if (right === 'tab') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else if (right === 'slot') path += ` v ${(height-tabWidth)/2} c 0,${tabWidth/6} -${tabHeight},${tabWidth/6} -${tabHeight},${tabWidth/3} v ${tabWidth/3} c 0,${tabWidth/6} ${tabHeight},${tabWidth/6} ${tabHeight},${tabWidth/3} v ${(height-tabWidth)/2}`;
            else path += ` h ${tabHeight} v ${height} h -${tabHeight}`;
            
            // Bottom
            if (bottom === 'tab') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${(width-tabWidth)/2}`;
            else if (bottom === 'slot') path += ` h -${(width-tabWidth)/2} c -${tabWidth/6},0 -${tabWidth/6},-${tabHeight} -${tabWidth/3},-${tabHeight} h -${tabWidth/3} c -${tabWidth/6},0 -${tabWidth/6},${tabHeight} -${tabWidth/3},${tabHeight} h -${(width-tabWidth)/2}`;
            else path += ` v ${tabHeight} h -${width} v -${tabHeight}`;
            
            // Left
            if (left === 'tab') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else if (left === 'slot') path += ` v -${(height-tabWidth)/2} c 0,-${tabWidth/6} ${tabHeight},-${tabWidth/6} ${tabHeight},-${tabWidth/3} v -${tabWidth/3} c 0,-${tabWidth/6} -${tabHeight},-${tabWidth/6} -${tabHeight},-${tabWidth/3} v -${(height-tabWidth)/2}`;
            else path += ` h -${tabHeight} v -${height} h ${tabHeight}`;
            
            return path + ' Z';
        }

        // è¼ªå»“ç·š - ä½¿ç”¨èˆ‡æ‹¼åœ–å¡Šç›¸åŒçš„è·¯å¾‘
        function createPieceOutline(i, j, pw, ph, size, ed) {
            const outline = document.createElement('div');
            outline.className = 'piece-outline';
            const tab = Math.min(pw, ph) * 0.15;
            // æ ¼ç·šä½¿ç”¨ generateCurvedPathï¼ˆä¸å»¶ä¼¸å¹³ç›´é‚Šï¼‰
            const path = generateCurvedPath(pw, ph, ed);
            
            const svgW = pw + 2*tab;
            const svgH = ph + 2*tab;
            
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", svgW); 
            svg.setAttribute("height", svgH);
            const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
            p.setAttribute("d", path); 
            p.setAttribute("fill", "none"); 
            p.setAttribute("stroke", "rgba(255,255,255,0.35)"); 
            p.setAttribute("stroke-width", "1");
            p.setAttribute("stroke-linejoin", "round");
            p.setAttribute("stroke-linecap", "round");
            svg.appendChild(p); 
            outline.appendChild(svg);
            outline.style.cssText = `position:absolute; left:${j*pw}px; top:${i*ph}px; pointer-events:none; z-index:0; transform:translate(-${tab}px,-${tab}px);`;
            if (showHint) { 
                const n = document.createElement('div'); 
                n.className = 'piece-number'; 
                n.textContent = i*cols+j+1; 
                outline.appendChild(n); 
            }
            return outline;
        }

        function createDrawerItem(piece, pw, ph, tab) {
            const wrapper = document.createElement('div');
            wrapper.className = 'drawer-piece-wrapper';
            // wrapper ç”¨ padding ä¾†å®¹ç´ translate å¾Œçš„æ‹¼åœ–
            wrapper.style.cssText = `width:${pw}px; height:${ph}px; padding:${tab}px; position:relative; box-sizing:content-box;`;
            
            const div = document.createElement('div');
            // å®Œæ•´è¤‡è£½ piece æ¨£å¼ï¼ˆåŒ…å« translateï¼‰
            div.style.cssText = piece.style.cssText.replace('position:absolute;', 'position:relative;');
            
            wrapper.appendChild(div);
            
            // åŠ å…¥ SVG é‚Šæ¡†ç·š
            const svgW = pw + 2 * tab;
            const svgH = ph + 2 * tab;
            const ed = piece.edges || {top: null, right: null, bottom: null, left: null};
            const borderPath = generateCurvedPath(pw, ph, ed);
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', svgW);
            svg.setAttribute('height', svgH);
            svg.style.cssText = 'position:absolute; top:0; left:0; pointer-events:none;';
            svg.innerHTML = `<path d="${borderPath}" fill="none" stroke="#000" stroke-width="1"/>`;
            wrapper.appendChild(svg);
            
            // éš¨æ©Ÿæ—‹è½‰ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰- 0~359 ä»»æ„è§’åº¦
            const randomRotation = enableRotation ? Math.floor(Math.random() * 360) : 0;
            wrapper.currentRotation = randomRotation;
            piece.currentRotation = randomRotation;
            if (randomRotation !== 0) {
                div.style.transform = `translate(-${tab}px,-${tab}px) rotate(${randomRotation}deg)`;
                svg.style.transform = `rotate(${randomRotation}deg)`;
                svg.style.transformOrigin = 'center center';
            }
            
            // å„²å­˜ç·¨è™Ÿä¾›æç¤ºç”¨
            wrapper.pieceNumber = piece.pieceNumber;
            wrapper.pieceRef = piece;
            wrapper.pieceDiv = div;
            wrapper.pieceSvg = svg;
            wrapper.tab = tab;
            wrapper.addEventListener('mousedown', startDragFromDrawer);
            wrapper.addEventListener('touchstart', startTouchFromDrawer, {passive: true});
            return wrapper;
        }
        
        // é¡¯ç¤ºæŠ½å±œæ‹¼åœ–ç·¨è™Ÿæç¤º
        function showDrawerHint(wrapper) {
            if (!showHint) return;
            if (!wrapper || wrapper.classList.contains('placed')) return;
            
            // ç§»é™¤å·²å­˜åœ¨çš„æç¤º
            const existing = wrapper.querySelector('.drawer-hint');
            if (existing) existing.remove();
            
            // å‰µå»ºæç¤º
            const hint = document.createElement('div');
            hint.className = 'drawer-hint';
            hint.textContent = wrapper.pieceNumber;
            wrapper.appendChild(hint);
            
            // 3 ç§’å¾Œç§»é™¤
            setTimeout(() => hint.remove(), 3000);
        }

        // é–‹å§‹éŠæˆ²
        function startGame(skipConfirm = false) {
            if (!originalImage) { alert('è«‹å…ˆé¸æ“‡åœ–ç‰‡ï¼'); return; }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰é€²è¡Œä¸­çš„éŠæˆ²
            if (!skipConfirm && isPlaying && drawerPieces.some(dp => dp.isPlaced)) {
                showConfirmNewGameDialog();
                return;
            }
            
            // æ¸…é™¤èˆŠå­˜æª”ï¼ˆé–‹å§‹æ–°éŠæˆ²ï¼‰
            clearSave();
            stopAutoSave();
            
            // é¡¯ç¤ºé€²åº¦
            const progressOverlay = document.createElement('div');
            progressOverlay.className = 'progress-overlay';
            progressOverlay.innerHTML = `
                <div class="progress-text" id="progressText">æº–å‚™ä¸­...</div>
                <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
            `;
            document.body.appendChild(progressOverlay);
            
            // ä½¿ç”¨ async è®“ UI æœ‰æ©Ÿæœƒæ›´æ–°
            const updateProgress = (percent, text) => {
                return new Promise(resolve => {
                    document.getElementById('progressFill').style.width = percent + '%';
                    if (text) document.getElementById('progressText').textContent = text;
                    requestAnimationFrame(() => requestAnimationFrame(resolve));
                });
            };
            
            (async () => {
                await updateProgress(10, 'åˆå§‹åŒ–...');
                
                const container = document.getElementById('puzzleContainer');
                const drawer = document.getElementById('puzzleDrawer');
                container.innerHTML = '';
                drawer.innerHTML = '';
                pieces = []; drawerPieces = []; isPlaying = true;
                drawerPieceZIndex = 1; // é‡ç½® z-index è¨ˆæ•¸å™¨
                
                // è®€å–æ•£äº‚æ¨¡å¼è¨­å®š
                scatterMode = document.getElementById('toggleScatter').checked;
                
                // è¨­å®š drawer classï¼ˆåŒ…å«æ–¹å‘å’Œæ•£äº‚æ¨¡å¼ï¼‰
                drawer.className = 'puzzle-drawer drawer-' + drawerPosition + (scatterMode ? ' scatter-mode' : '');
                
                // æ›´æ–° drawer æ–¹å‘æŒ‰éˆ•çš„ active ç‹€æ…‹
                document.querySelectorAll('.drawer-btn[onclick^="setDrawerPosition"]').forEach(b => {
                    const pos = b.getAttribute('onclick').match(/'(\w+)'/)[1];
                    b.classList.toggle('active', pos === drawerPosition);
                });
                
                // è¨­å®š drawer å¤§å°
                if (drawerPosition === 'top' || drawerPosition === 'bottom') {
                    drawer.style.width = '';
                    drawer.style.height = drawerSize + 'px';
                } else if (drawerPosition === 'left' || drawerPosition === 'right') {
                    drawer.style.height = '';
                    drawer.style.width = drawerSize + 'px';
                }

                const size = calculateContainerSize();
                const count = parseInt(document.getElementById('pieceCount').value);
                rows = cols = Math.sqrt(count);
                
                const pw = size.width / cols;
                const ph = size.height / rows;
                const tab = Math.min(pw, ph) * 0.15;
                
                // å„²å­˜æ‹¼åœ–å¤§å°ï¼ˆå« tab å’Œ paddingï¼‰ä¾› drawer resize ä½¿ç”¨
                pieceWidth = pw + 2 * tab + 20;  // åŠ ä¸Š padding/margin
                pieceHeight = ph + 2 * tab + 20;
                
                const pos = calculateContainerPosition(size.width, size.height);

                container.style.width = size.width + 'px';
                container.style.height = size.height + 'px';
                container.style.left = pos.left + 'px';
                container.style.top = pos.top + 'px';
                container.style.transform = 'scale(0.85)';
                container.style.transformOrigin = 'center center';
                
                // å„²å­˜åŸå§‹å®¹å™¨å¤§å°ä¾›ç¸®æ”¾ä½¿ç”¨
                baseContainerWidth = size.width;
                baseContainerHeight = size.height;
                containerScale = 0.85;  // åˆå§‹ç¸®æ”¾ç‚º 85%
                
                // è¨˜éŒ„åŸå§‹ä½ç½®ï¼Œè¨­å®šæ‹–æ›³ç¯„åœï¼ˆåŠå€‹æ‹¼åœ–å€å¤§å°ï¼‰
                containerOriginalPos = { left: pos.left, top: pos.top };
                containerDragLimit = { 
                    x: (cols / 2) * pw,  // å¯å·¦å³ç§»å‹•åŠå€‹æ‹¼åœ–å€
                    y: (rows / 2) * ph   // å¯ä¸Šä¸‹ç§»å‹•åŠå€‹æ‹¼åœ–å€
                };
                
                // åˆå§‹åŒ– resize handle ä½ç½®ï¼ˆç·Šè²¼ drawer é‚Šç·£ï¼‰
                const handle = document.getElementById('drawerResizeHandle');
                const gameArea = document.getElementById('gameArea');
                if (drawerPosition === 'bottom') {
                    handle.className = 'drawer-resize-handle horizontal visible';
                    handle.style.top = (gameArea.offsetHeight - drawerSize - 20) + 'px';
                    handle.style.left = '0';
                    handle.style.right = '0';
                    handle.style.bottom = '';
                } else if (drawerPosition === 'top') {
                    handle.className = 'drawer-resize-handle horizontal visible';
                    handle.style.top = drawerSize + 'px';
                    handle.style.left = '0';
                    handle.style.right = '0';
                    handle.style.bottom = '';
                } else if (drawerPosition === 'left') {
                    handle.className = 'drawer-resize-handle vertical visible';
                    handle.style.left = drawerSize + 'px';
                    handle.style.right = '';
                    handle.style.top = '0';
                    handle.style.bottom = '0';
                } else if (drawerPosition === 'right') {
                    handle.className = 'drawer-resize-handle vertical visible';
                    handle.style.right = (drawerSize + 20) + 'px';
                    handle.style.left = '';
                    handle.style.top = '0';
                    handle.style.bottom = '0';
                }

                const outlines = document.createElement('div');
                outlines.className = 'outlines-container';
                outlines.style.cssText = 'position:absolute;z-index:0;left:0;top:0;';
                container.appendChild(outlines);

                edges = generateEdges(rows, cols);
                
                await updateProgress(30, 'ç¹ªè£½æ ¼ç·š...');
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        outlines.appendChild(createPieceOutline(i, j, pw, ph, size, edges[i][j]));
                    }
                }

                await updateProgress(50, 'åˆ‡å‰²æ‹¼åœ–...');

                let temp = [];
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        temp.push(createPuzzlePiece(i, j, pw, ph, size, edges[i][j]));
                    }
                    await updateProgress(50 + Math.floor((i / rows) * 30), 'åˆ‡å‰²æ‹¼åœ–...');
                }
                
                for (let i = temp.length - 1; i > 0; i--) { 
                    const j = Math.floor(Math.random() * (i + 1)); 
                    [temp[i], temp[j]] = [temp[j], temp[i]]; 
                }
                
                await updateProgress(85, 'æ‰“äº‚é †åº...');
                
                temp.forEach(piece => {
                    const item = createDrawerItem(piece, pw, ph, tab);
                    drawer.appendChild(item);
                    drawerPieces.push({piece, drawerItem: item, isPlaced: false});
                    pieces.push(piece);
                });
                
                // æ•£äº‚æ¨¡å¼ï¼šä½¿ç”¨åˆ†æ•£æ’åˆ—
                if (scatterMode) {
                    repositionScatteredPieces();
                }
                
                updateDrawerCount();
                
                // å•Ÿå‹•è‡ªå‹•å­˜æª”
                startAutoSave();
                
                await updateProgress(100, 'å®Œæˆï¼');
                setTimeout(() => progressOverlay.remove(), 300);
            })();
        }
        
        // åˆ‡æ›æ•£äº‚æ¨¡å¼
        function toggleScatterMode() {
            if (!isPlaying || drawerPieces.length === 0) return;
            
            scatterMode = document.getElementById('toggleScatter').checked;
            const drawer = document.getElementById('puzzleDrawer');
            
            if (scatterMode) {
                drawer.classList.add('scatter-mode');
                repositionScatteredPieces();
            } else {
                drawer.classList.remove('scatter-mode');
                // ç§»é™¤æ‰€æœ‰ä½ç½®æ¨£å¼ï¼Œæ¢å¾© flex æ’åˆ—
                drawerPieces.forEach(dp => {
                    if (!dp.isPlaced) {
                        dp.drawerItem.style.left = '';
                        dp.drawerItem.style.top = '';
                        dp.drawerItem.style.zIndex = '';
                    }
                });
            }
        }
        
        // ç›£è½æ•£äº‚ checkbox è®ŠåŒ–
        document.getElementById('toggleScatter').addEventListener('change', toggleScatterMode);

        // å¾æŠ½å±œæ‹–æ›³ (æ»‘é¼ ) - åŠ å…¥å»¶é²åˆ¤æ–·ï¼ŒçŸ­æŒ‰é¡¯ç¤ºæç¤ºï¼Œé•·æŒ‰æ‰æ‹–æ›³
        let mouseStartInfo = null;
        let mouseDragTimer = null;
        let isMouseDragging = false;
        const MOUSE_DRAG_DELAY = 150;

        function startDragFromDrawer(e) {
            if (!isPlaying) return;
            e.preventDefault();
            const wrapper = this, piece = wrapper.pieceRef;
            if (!piece || piece.isPlaced) return;
            
            // æ•£äº‚æ¨¡å¼ï¼šé»æ“Šæ™‚æå‡ z-index
            if (scatterMode) {
                wrapper.style.zIndex = drawerPieceZIndex++;
            }
            
            // é¡¯ç¤ºç·¨è™Ÿæç¤º
            showDrawerHint(wrapper);
            
            // è¨˜éŒ„æ»‘é¼ è³‡è¨Š
            const wrapperRect = wrapper.getBoundingClientRect();
            const tab = wrapper.tab || 0;
            
            // piece æœ‰ translate(-tab,-tab)ï¼Œæ‰€ä»¥åç§»è¦åŠ å› tabï¼ˆç”¨æ–¼ container å…§å®šä½ï¼‰
            // wrapper åç§»ä¸éœ€è¦æ¸› tabï¼ˆç”¨æ–¼ drawer å…§å®šä½ï¼‰
            mouseStartInfo = {
                wrapper: wrapper,
                piece: piece,
                clientX: e.clientX,
                clientY: e.clientY,
                offsetInWrapperX: e.clientX - wrapperRect.left - tab,
                offsetInWrapperY: e.clientY - wrapperRect.top - tab,
                wrapperOffsetX: e.clientX - wrapperRect.left,
                wrapperOffsetY: e.clientY - wrapperRect.top
            };
            isMouseDragging = false;
            
            // å»¶é²å•Ÿå‹•æ‹–æ›³
            mouseDragTimer = setTimeout(() => {
                if (mouseStartInfo) {
                    startActualMouseDrag();
                }
            }, MOUSE_DRAG_DELAY);
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        
        function handleMouseMove(e) {
            if (!mouseStartInfo) return;
            
            // æ›´æ–°ä½ç½®
            mouseStartInfo.clientX = e.clientX;
            mouseStartInfo.clientY = e.clientY;
            
            // å¦‚æœå·²ç¶“åœ¨æ‹–æ›³ï¼Œç§»å‹•æ‹¼åœ–
            if (isMouseDragging && currentPiece) {
                const rect = document.getElementById('puzzleContainer').getBoundingClientRect();
                // æ‰‹æŒ‡åœ¨ container å…§çš„ä½ç½®ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
                const posInContainer = {
                    x: (e.clientX - rect.left) / containerScale,
                    y: (e.clientY - rect.top) / containerScale
                };
                // æ‹¼åœ–ä½ç½® = æ‰‹æŒ‡ä½ç½® - åç§»ï¼ˆåç§»å·²ç¶“åœ¨ startActualMouseDrag ä¸­è¨ˆç®—å¥½äº†ï¼‰
                currentPiece.style.left = (posInContainer.x - currentPiece.offX) + 'px';
                currentPiece.style.top = (posInContainer.y - currentPiece.offY) + 'px';
            }
        }
        
        function startActualMouseDrag() {
            if (!mouseStartInfo) return;
            
            isMouseDragging = true;
            const { wrapper, piece, clientX, clientY, offsetInWrapperX, offsetInWrapperY } = mouseStartInfo;
            
            wrapper.classList.add('dragging');
            // éš±è— drawer ä¸­çš„é è¦½åœ–å’Œé‚Šæ¡†
            if (wrapper.pieceDiv) wrapper.pieceDiv.style.visibility = 'hidden';
            if (wrapper.pieceSvg) wrapper.pieceSvg.style.visibility = 'hidden';
            
            const container = document.getElementById('puzzleContainer');
            const rect = container.getBoundingClientRect();
            
            // ç¢ºä¿ piece ä¸åœ¨ container è£¡ï¼ˆä»¥é˜²è¬ä¸€ï¼‰
            if (piece.parentElement === container) {
                container.removeChild(piece);
            }
            
            // æ‹–æ›³é–‹å§‹æ™‚ç«‹å³è½‰æ­£ï¼ˆä¸å¥—ç”¨æ—‹è½‰ï¼‰
            const baseTransform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
            piece.style.transform = baseTransform;
            
            // æ‰‹æŒ‡åœ¨ container å…§çš„ä½ç½®ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
            const posInContainer = {
                x: (clientX - rect.left) / containerScale,
                y: (clientY - rect.top) / containerScale
            };
            
            // è¨ˆç®—åç§»ï¼šdrawer ä¸­çš„åç§»éœ€è¦æ ¹æ“šæ‹¼åœ–å¤§å°æ¯”ä¾‹èª¿æ•´
            // drawer ä¸­æ‹¼åœ–å¤§å° vs container ä¸­æ‹¼åœ–å¤§å°çš„æ¯”ä¾‹
            // ç”±æ–¼ piece æœ¬èº«å¤§å°ä¸è®Šï¼Œåªæ˜¯ container ç¸®æ”¾äº†ï¼Œæ‰€ä»¥åç§»ä¸éœ€è¦é¡å¤–èª¿æ•´
            const offsetX = offsetInWrapperX;
            const offsetY = offsetInWrapperY;
            
            piece.style.left = (posInContainer.x - offsetX) + 'px';
            piece.style.top = (posInContainer.y - offsetY) + 'px';
            piece.style.zIndex = '1000';
            piece.classList.add('dragging');
            container.appendChild(piece);
            
            // æå‡ container z-index è®“æ‹¼åœ–é¡¯ç¤ºåœ¨ drawer ä¸Šæ–¹
            container.style.zIndex = '1000';
            
            currentPiece = piece;
            currentPiece.drawerWrapper = wrapper;
            currentPiece.offX = offsetX;
            currentPiece.offY = offsetY;
        }
        
        function handleMouseUp() {
            clearTimeout(mouseDragTimer);
            mouseDragTimer = null;
            
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            
            // æ¢å¾© container z-index
            document.getElementById('puzzleContainer').style.zIndex = '';
            
            if (!isMouseDragging) {
                // åªæ˜¯çŸ­æŒ‰ï¼Œä¸éœ€è¦è™•ç†æ‹–æ›³
                mouseStartInfo = null;
                return;
            }
            
            if (!currentPiece) {
                mouseStartInfo = null;
                isMouseDragging = false;
                return;
            }
            
            const piece = currentPiece; // ä¿å­˜å¼•ç”¨
            piece.classList.remove('dragging');
            piece.style.zIndex = '';
            
            const left = parseInt(piece.style.left), top = parseInt(piece.style.top);
            
            // ä½ç½®æ­£ç¢ºå°±æ”¾ç½®ï¼Œä¸¦è‡ªå‹•è½‰æ­£
            if (Math.abs(left - piece.correctX) < 15 && Math.abs(top - piece.correctY) < 15) {
                piece.style.transition = 'transform 0.3s';
                piece.style.left = piece.correctX + 'px';
                piece.style.top = piece.correctY + 'px';
                // è‡ªå‹•è½‰æ­£ï¼ˆç§»é™¤æ—‹è½‰ï¼‰
                piece.style.transform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.currentRotation = 0;
                setTimeout(() => piece.style.transition = '', 300);
                piece.isPlaced = true;
                piece.drawerWrapper.classList.add('placed');
                const dp = drawerPieces.find(d => d.piece === piece);
                if (dp) dp.isPlaced = true;
                playSnapSound();
                if (navigator.vibrate) navigator.vibrate(20);
                updateDrawerCount();
                checkWin();
            } else {
                // æ‹–æ›³å¤±æ•— - æª¢æŸ¥æ˜¯å¦åœ¨ drawer å€å…§ï¼ˆæ•£äº‚æ¨¡å¼ä¸‹å¯é‡æ–°å®šä½ï¼‰
                const drawer = document.getElementById('puzzleDrawer');
                const drawerRect = drawer.getBoundingClientRect();
                const mouseX = mouseStartInfo.clientX;
                const mouseY = mouseStartInfo.clientY;
                
                // å¾ container ç§»é™¤ piece
                document.getElementById('puzzleContainer').removeChild(piece);
                // é‡ç½® piece çš„æ—‹è½‰ï¼ˆä¿æŒ drawer ä¸­çš„æ—‹è½‰ç‹€æ…‹ï¼‰
                const baseTransform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.style.transform = baseTransform;
                
                // æ•£äº‚æ¨¡å¼ä¸”åœ¨ drawer å€å…§ - ç§»å‹•åˆ°æ–°ä½ç½®
                if (scatterMode && 
                    mouseX >= drawerRect.left && mouseX <= drawerRect.right &&
                    mouseY >= drawerRect.top && mouseY <= drawerRect.bottom) {
                    
                    // ä½¿ç”¨ wrapper åç§»ï¼ˆä¸å« tab è£œå„Ÿï¼‰ï¼Œè®“æ”¾ä¸‹ä½ç½®èˆ‡æ‹–æ›³æ™‚ä¸€è‡´
                    const offsetX = mouseStartInfo.wrapperOffsetX || piece.drawerWrapper.offsetWidth / 2;
                    const offsetY = mouseStartInfo.wrapperOffsetY || piece.drawerWrapper.offsetHeight / 2;
                    const newX = mouseX - drawerRect.left - offsetX;
                    const newY = mouseY - drawerRect.top - offsetY;
                    piece.drawerWrapper.style.left = Math.max(0, newX) + 'px';
                    piece.drawerWrapper.style.top = Math.max(0, newY) + 'px';
                    piece.drawerWrapper.style.zIndex = drawerPieceZIndex++;
                }
                
                // é¡¯ç¤º drawer ä¸­çš„é è¦½åœ–å’Œé‚Šæ¡†
                if (piece.drawerWrapper.pieceDiv) {
                    piece.drawerWrapper.pieceDiv.style.visibility = 'visible';
                }
                if (piece.drawerWrapper.pieceSvg) {
                    piece.drawerWrapper.pieceSvg.style.visibility = 'visible';
                }
                piece.drawerWrapper.classList.remove('dragging');
            }
            
            currentPiece = null;
            mouseStartInfo = null;
            isMouseDragging = false;
        }
        
        function dragFromDrawer(e) {
            // ä¸å†ä½¿ç”¨ï¼Œæ”¹ç”¨ handleMouseMove
        }

        // å¾æŠ½å±œæ‹–æ›³ (è§¸æ§) - åŠ å…¥æ»¾å‹•åˆ¤æ–·
        let touchStartInfo = null;
        let dragDelayTimer = null;
        let isDraggingFromDrawer = false;
        const DRAG_DELAY = 150; // é•·æŒ‰150msæ‰é–‹å§‹æ‹–æ›³
        const SCROLL_THRESHOLD = 10; // ç§»å‹•è¶…é10pxè¦–ç‚ºæ»¾å‹•

        function startTouchFromDrawer(e) {
            if (!isPlaying) return;
            
            const wrapper = this;
            const piece = wrapper.pieceRef;
            if (!piece || piece.isPlaced) return;
            
            // æ•£äº‚æ¨¡å¼ï¼šé»æ“Šæ™‚æå‡ z-index
            if (scatterMode) {
                wrapper.style.zIndex = drawerPieceZIndex++;
            }
            
            // é¡¯ç¤ºç·¨è™Ÿæç¤º
            showDrawerHint(wrapper);
            
            const touch = e.touches[0];
            const wrapperRect = wrapper.getBoundingClientRect();
            const tab = wrapper.tab || 0;
            
            touchStartInfo = {
                wrapper: wrapper,
                piece: piece,
                startX: touch.clientX,
                startY: touch.clientY,
                lastX: touch.clientX,
                lastY: touch.clientY,
                // è¨˜éŒ„æ‰‹æŒ‡åœ¨ wrapper å…§çš„åç§»ï¼Œæ¸›å» tab è£œå„Ÿ piece çš„ translate
                offsetInWrapperX: touch.clientX - wrapperRect.left - tab,
                offsetInWrapperY: touch.clientY - wrapperRect.top - tab,
                // wrapper åç§»ä¸å« tabï¼ˆç”¨æ–¼ drawer å…§å®šä½ï¼‰
                wrapperOffsetX: touch.clientX - wrapperRect.left,
                wrapperOffsetY: touch.clientY - wrapperRect.top,
                scrollLeft: document.getElementById('puzzleDrawer').scrollLeft,
                scrollTop: document.getElementById('puzzleDrawer').scrollTop
            };
            isDraggingFromDrawer = false;
            
            // å»¶é²å•Ÿå‹•æ‹–æ›³ï¼Œçµ¦æ»¾å‹•æ©Ÿæœƒ
            dragDelayTimer = setTimeout(() => {
                if (touchStartInfo && !isDraggingFromDrawer) {
                    // æª¢æŸ¥æ˜¯å¦å·²ç¶“åœ¨æ»¾å‹•
                    const drawer = document.getElementById('puzzleDrawer');
                    const scrolled = Math.abs(drawer.scrollLeft - touchStartInfo.scrollLeft) > 5 || 
                                    Math.abs(drawer.scrollTop - touchStartInfo.scrollTop) > 5;
                    if (!scrolled) {
                        startActualDrag();
                    }
                }
            }, DRAG_DELAY);
            
            document.addEventListener('touchmove', handleDrawerTouchMove, {passive: false});
            document.addEventListener('touchend', handleDrawerTouchEnd);
        }
        
        function handleDrawerTouchMove(e) {
            if (!touchStartInfo) return;
            
            const touch = e.touches[0];
            const dx = touch.clientX - touchStartInfo.startX;
            const dy = touch.clientY - touchStartInfo.startY;
            
            // æ›´æ–°æœ€å¾Œè§¸æ§ä½ç½®
            touchStartInfo.lastX = touch.clientX;
            touchStartInfo.lastY = touch.clientY;
            
            if (isDraggingFromDrawer) {
                // æ­£åœ¨æ‹–æ›³æ‹¼åœ–
                e.preventDefault();
                const rect = document.getElementById('puzzleContainer').getBoundingClientRect();
                // æ‰‹æŒ‡åœ¨ container å…§çš„ä½ç½®ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
                const posInContainer = {
                    x: (touch.clientX - rect.left) / containerScale,
                    y: (touch.clientY - rect.top) / containerScale
                };
                currentPiece.style.left = (posInContainer.x - currentPiece.offX) + 'px';
                currentPiece.style.top = (posInContainer.y - currentPiece.offY) + 'px';
            } else {
                // æª¢æŸ¥æ˜¯å¦ç‚ºæ»¾å‹•æ„åœ–
                if (Math.abs(dx) > SCROLL_THRESHOLD || Math.abs(dy) > SCROLL_THRESHOLD) {
                    // å–æ¶ˆæ‹–æ›³ï¼Œå…è¨±æ»¾å‹•
                    clearTimeout(dragDelayTimer);
                    dragDelayTimer = null;
                }
            }
        }
        
        function startActualDrag() {
            if (!touchStartInfo) return;
            
            isDraggingFromDrawer = true;
            const { wrapper, piece, lastX, lastY, offsetInWrapperX, offsetInWrapperY } = touchStartInfo;
            
            wrapper.classList.add('dragging');
            // éš±è— drawer ä¸­çš„é è¦½åœ–å’Œé‚Šæ¡†
            if (wrapper.pieceDiv) wrapper.pieceDiv.style.visibility = 'hidden';
            if (wrapper.pieceSvg) wrapper.pieceSvg.style.visibility = 'hidden';
            
            const container = document.getElementById('puzzleContainer');
            const rect = container.getBoundingClientRect();
            
            // ç¢ºä¿ piece ä¸åœ¨ container è£¡ï¼ˆä»¥é˜²è¬ä¸€ï¼‰
            if (piece.parentElement === container) {
                container.removeChild(piece);
            }
            
            // æ‹–æ›³é–‹å§‹æ™‚ç«‹å³è½‰æ­£ï¼ˆä¸å¥—ç”¨æ—‹è½‰ï¼‰
            const baseTransform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
            piece.style.transform = baseTransform;
            
            // æ‰‹æŒ‡åœ¨ container å…§çš„ä½ç½®ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
            const posInContainer = {
                x: (lastX - rect.left) / containerScale,
                y: (lastY - rect.top) / containerScale
            };
            
            const offsetX = offsetInWrapperX;
            const offsetY = offsetInWrapperY;
            
            piece.style.left = (posInContainer.x - offsetX) + 'px';
            piece.style.top = (posInContainer.y - offsetY) + 'px';
            piece.style.zIndex = '1000';
            piece.classList.add('dragging');
            container.appendChild(piece);
            
            // æå‡ container z-index è®“æ‹¼åœ–é¡¯ç¤ºåœ¨ drawer ä¸Šæ–¹
            container.style.zIndex = '1000';
            
            currentPiece = piece;
            currentPiece.drawerWrapper = wrapper;
            // ä¿å­˜åç§»é‡ä¾›ç§»å‹•æ™‚ä½¿ç”¨
            currentPiece.offX = offsetX;
            currentPiece.offY = offsetY;
            
            if (navigator.vibrate) navigator.vibrate(10);
        }
        
        function handleDrawerTouchEnd() {
            clearTimeout(dragDelayTimer);
            dragDelayTimer = null;
            
            document.removeEventListener('touchmove', handleDrawerTouchMove);
            document.removeEventListener('touchend', handleDrawerTouchEnd);
            
            // æ¢å¾© container z-index
            document.getElementById('puzzleContainer').style.zIndex = '';
            
            if (!isDraggingFromDrawer) {
                touchStartInfo = null;
                return;
            }
            
            if (!currentPiece) {
                touchStartInfo = null;
                isDraggingFromDrawer = false;
                return;
            }
            
            const piece = currentPiece; // ä¿å­˜å¼•ç”¨
            piece.classList.remove('dragging');
            piece.style.zIndex = '';
            
            const left = parseInt(piece.style.left), top = parseInt(piece.style.top);
            
            // ä½ç½®æ­£ç¢ºå°±æ”¾ç½®ï¼Œä¸¦è‡ªå‹•è½‰æ­£
            if (Math.abs(left - piece.correctX) < 15 && Math.abs(top - piece.correctY) < 15) {
                piece.style.transition = 'transform 0.3s';
                piece.style.left = piece.correctX + 'px';
                piece.style.top = piece.correctY + 'px';
                // è‡ªå‹•è½‰æ­£ï¼ˆç§»é™¤æ—‹è½‰ï¼‰
                piece.style.transform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.currentRotation = 0;
                setTimeout(() => piece.style.transition = '', 300);
                piece.isPlaced = true;
                piece.drawerWrapper.classList.add('placed');
                const dp = drawerPieces.find(d => d.piece === piece);
                if (dp) dp.isPlaced = true;
                playSnapSound();
                if (navigator.vibrate) navigator.vibrate(20);
                updateDrawerCount();
                checkWin();
            } else {
                // æ‹–æ›³å¤±æ•— - æª¢æŸ¥æ˜¯å¦åœ¨ drawer å€å…§ï¼ˆæ•£äº‚æ¨¡å¼ä¸‹å¯é‡æ–°å®šä½ï¼‰
                const drawer = document.getElementById('puzzleDrawer');
                const drawerRect = drawer.getBoundingClientRect();
                const touchX = touchStartInfo.lastX;
                const touchY = touchStartInfo.lastY;
                
                // å¾ container ç§»é™¤ piece
                document.getElementById('puzzleContainer').removeChild(piece);
                // é‡ç½® piece çš„æ—‹è½‰ï¼ˆä¿æŒ drawer ä¸­çš„æ—‹è½‰ç‹€æ…‹ï¼‰
                const baseTransform = piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                piece.style.transform = baseTransform;
                
                // æ•£äº‚æ¨¡å¼ä¸”åœ¨ drawer å€å…§ - ç§»å‹•åˆ°æ–°ä½ç½®
                if (scatterMode && 
                    touchX >= drawerRect.left && touchX <= drawerRect.right &&
                    touchY >= drawerRect.top && touchY <= drawerRect.bottom) {
                    
                    // ä½¿ç”¨ wrapper åç§»ï¼ˆä¸å« tab è£œå„Ÿï¼‰ï¼Œè®“æ”¾ä¸‹ä½ç½®èˆ‡æ‹–æ›³æ™‚ä¸€è‡´
                    const offsetX = touchStartInfo.wrapperOffsetX || piece.drawerWrapper.offsetWidth / 2;
                    const offsetY = touchStartInfo.wrapperOffsetY || piece.drawerWrapper.offsetHeight / 2;
                    const newX = touchX - drawerRect.left - offsetX;
                    const newY = touchY - drawerRect.top - offsetY;
                    piece.drawerWrapper.style.left = Math.max(0, newX) + 'px';
                    piece.drawerWrapper.style.top = Math.max(0, newY) + 'px';
                    piece.drawerWrapper.style.zIndex = drawerPieceZIndex++;
                }
                
                // é¡¯ç¤º drawer ä¸­çš„é è¦½åœ–å’Œé‚Šæ¡†
                if (piece.drawerWrapper.pieceDiv) {
                    piece.drawerWrapper.pieceDiv.style.visibility = 'visible';
                }
                if (piece.drawerWrapper.pieceSvg) {
                    piece.drawerWrapper.pieceSvg.style.visibility = 'visible';
                }
                piece.drawerWrapper.classList.remove('dragging');
            }
            
            currentPiece = null;
            touchStartInfo = null;
            isDraggingFromDrawer = false;
        }

        function checkWin() {
            if (drawerPieces.every(d => d.isPlaced)) {
                isPlaying = false;
                stopAutoSave();
                clearSave();
                playWinSound();
                if (navigator.vibrate) navigator.vibrate([100,50,100]);
                // å±•é–‹æ§åˆ¶é¢æ¿
                showControlsDrawer();
                setTimeout(() => showCompletionMessage(), 300);
            } else {
                // æ¯æ”¾ç½®ä¸€ç‰‡å°±å­˜æª”
                saveGame();
            }
        }
        
        // é¡¯ç¤ºç¾åŒ–çš„å®Œæˆè¨Šæ¯
        function showCompletionMessage() {
            const msg = document.createElement('div');
            msg.className = 'completion-message';
            msg.innerHTML = 'ğŸ‰ æ­å–œå®Œæˆæ‹¼åœ–ï¼';
            document.body.appendChild(msg);
            setTimeout(() => msg.classList.add('show'), 10);
            setTimeout(() => {
                msg.classList.remove('show');
                setTimeout(() => msg.remove(), 500);
            }, 3000);
        }
        
        // å±•é–‹æ§åˆ¶é¢æ¿
        function showControlsDrawer() {
            controlsCollapsed = false;
            document.getElementById('controlsDrawer').classList.remove('collapsed');
            document.getElementById('controlsToggle').textContent = 'â—€';
        }

        function autoComplete() {
            if (!isPlaying) return;
            const container = document.getElementById('puzzleContainer');
            drawerPieces.forEach((dp, i) => {
                if (!dp.isPlaced) {
                    setTimeout(() => {
                        dp.piece.style.transition = 'all 0.4s';
                        dp.piece.style.left = dp.piece.correctX + 'px';
                        dp.piece.style.top = dp.piece.correctY + 'px';
                        // é‡ç½®æ—‹è½‰è§’åº¦
                        dp.piece.style.transform = dp.piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                        dp.piece.currentRotation = 0;
                        dp.piece.isPlaced = true; dp.isPlaced = true;
                        if (!dp.piece.parentElement) container.appendChild(dp.piece);
                        dp.drawerItem.classList.add('placed');
                        updateDrawerCount();
                    }, i * 80);
                }
            });
            setTimeout(() => { 
                isPlaying = false;
                stopAutoSave();
                clearSave();
                playWinSound(); 
                showControlsDrawer();
                showCompletionMessage();
            }, drawerPieces.length * 80 + 500);
        }

        // æç¤ºé–‹é—œ
        document.getElementById('toggleHint').addEventListener('change', function() {
            showHint = this.checked;
            // æ›´æ–°æ‹¼åœ–å€ç·¨è™Ÿ
            document.querySelectorAll('.piece-outline').forEach((o, idx) => {
                const n = o.querySelector('.piece-number');
                if (n) o.removeChild(n);
                if (showHint) {
                    const num = document.createElement('div');
                    num.className = 'piece-number';
                    num.textContent = Math.floor(idx/cols)*cols + (idx%cols) + 1;
                    o.appendChild(num);
                }
            });
        });
        
        // æ—‹è½‰é–‹é—œ
        document.getElementById('toggleRotation').addEventListener('change', function() {
            enableRotation = this.checked;
            // æ›´æ–°æœªæ”¾ç½®æ‹¼åœ–çš„æ—‹è½‰
            drawerPieces.forEach(dp => {
                if (!dp.isPlaced) {
                    const randomRotation = enableRotation ? Math.floor(Math.random() * 360) : 0;
                    dp.drawerItem.currentRotation = randomRotation;
                    dp.piece.currentRotation = randomRotation;
                    const div = dp.drawerItem.pieceDiv;
                    const svg = dp.drawerItem.pieceSvg;
                    const tab = dp.drawerItem.tab;
                    if (div) {
                        div.style.transform = randomRotation !== 0 
                            ? `translate(-${tab}px,-${tab}px) rotate(${randomRotation}deg)` 
                            : `translate(-${tab}px,-${tab}px)`;
                    }
                    if (svg) {
                        svg.style.transform = randomRotation !== 0 
                            ? `rotate(${randomRotation}deg)` 
                            : '';
                        svg.style.transformOrigin = 'center center';
                    }
                }
            });
        });
        
        // ç‰‡æ•¸æ”¹è®Šæ™‚é‡æ–°é–‹å§‹éŠæˆ²
        document.getElementById('pieceCount').addEventListener('change', function() {
            if (originalImage) {
                startGame();
            }
        });
        
        // ========== å­˜æª”åŠŸèƒ½ ==========
        
        // å„²å­˜éŠæˆ²ç‹€æ…‹
        function saveGame() {
            if (!isPlaying || !originalImage) return;
            
            try {
                const container = document.getElementById('puzzleContainer');
                
                const saveData = {
                    version: 2,
                    timestamp: Date.now(),
                    // åœ–ç‰‡è³‡æ–™
                    imageData: originalImage.src,
                    // éŠæˆ²è¨­å®š
                    pieceCount: parseInt(document.getElementById('pieceCount').value),
                    rows: rows,
                    cols: cols,
                    enableRotation: enableRotation,
                    scatterMode: scatterMode,
                    showHint: showHint,
                    // UI ç‹€æ…‹
                    drawerPosition: drawerPosition,
                    drawerSize: drawerSize,
                    controlsCollapsed: controlsCollapsed,
                    // æ ¼ç·šå€ç‹€æ…‹
                    containerScale: containerScale,
                    containerLeft: container.style.left,
                    containerTop: container.style.top,
                    // æ•£äº‚æ¨¡å¼ z-index è¨ˆæ•¸å™¨
                    drawerPieceZIndex: drawerPieceZIndex,
                    // æ‹¼åœ–ç‹€æ…‹
                    pieces: drawerPieces.map(dp => ({
                        index: dp.piece.pieceNumber - 1,
                        isPlaced: dp.isPlaced,
                        rotation: dp.piece.currentRotation || 0,
                        // drawer ä¸­çš„ä½ç½®ï¼ˆæ•£äº‚æ¨¡å¼ï¼‰
                        drawerLeft: dp.drawerItem.style.left,
                        drawerTop: dp.drawerItem.style.top,
                        drawerZIndex: dp.drawerItem.style.zIndex
                    }))
                };
                
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                console.log('éŠæˆ²å·²å„²å­˜');
            } catch (e) {
                console.error('å„²å­˜å¤±æ•—:', e);
            }
        }
        
        // è¼‰å…¥éŠæˆ²ç‹€æ…‹
        function loadGame() {
            try {
                const saved = localStorage.getItem(SAVE_KEY);
                if (!saved) return null;
                return JSON.parse(saved);
            } catch (e) {
                console.error('è¼‰å…¥å¤±æ•—:', e);
                return null;
            }
        }
        
        // æ¸…é™¤å­˜æª”
        function clearSave() {
            localStorage.removeItem(SAVE_KEY);
            console.log('å­˜æª”å·²æ¸…é™¤');
        }
        
        // å•Ÿå‹•è‡ªå‹•å­˜æª”
        function startAutoSave() {
            stopAutoSave();
            autoSaveTimer = setInterval(saveGame, 30000); // æ¯ 30 ç§’å­˜æª”
        }
        
        // åœæ­¢è‡ªå‹•å­˜æª”
        function stopAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        }
        
        // å¾å­˜æª”æ¢å¾©éŠæˆ²
        function restoreGame(saveData) {
            return new Promise((resolve, reject) => {
                try {
                    // è¨­å®šé¸é …
                    document.getElementById('pieceCount').value = saveData.pieceCount;
                    document.getElementById('toggleRotation').checked = saveData.enableRotation;
                    document.getElementById('toggleScatter').checked = saveData.scatterMode;
                    document.getElementById('toggleHint').checked = saveData.showHint;
                    enableRotation = saveData.enableRotation;
                    scatterMode = saveData.scatterMode;
                    showHint = saveData.showHint;
                    drawerSize = saveData.drawerSize || 180;
                    
                    // æ¢å¾© drawer æ–¹å‘
                    if (saveData.drawerPosition) {
                        drawerPosition = saveData.drawerPosition;
                    }
                    
                    // æ¢å¾©æ§åˆ¶é¢æ¿ç‹€æ…‹
                    if (saveData.controlsCollapsed !== undefined) {
                        controlsCollapsed = saveData.controlsCollapsed;
                    }
                    
                    // æ¢å¾© z-index è¨ˆæ•¸å™¨
                    if (saveData.drawerPieceZIndex) {
                        drawerPieceZIndex = saveData.drawerPieceZIndex;
                    }
                    
                    // è¼‰å…¥åœ–ç‰‡
                    originalImage = new Image();
                    originalImage.onload = function() {
                        // é–‹å§‹éŠæˆ²ï¼ˆæœƒå»ºç«‹æ‹¼åœ–ï¼‰
                        startGameWithRestore(saveData);
                        resolve();
                    };
                    originalImage.onerror = function() {
                        reject(new Error('åœ–ç‰‡è¼‰å…¥å¤±æ•—'));
                    };
                    originalImage.src = saveData.imageData;
                } catch (e) {
                    reject(e);
                }
            });
        }
        
        // å¸¶æ¢å¾©çš„é–‹å§‹éŠæˆ²
        function startGameWithRestore(saveData) {
            // è‡¨æ™‚ä¿®æ”¹ï¼Œè®“ startGame å®Œæˆå¾Œæ¢å¾©ç‹€æ…‹
            const checkAndRestore = setInterval(() => {
                if (isPlaying && drawerPieces.length > 0) {
                    clearInterval(checkAndRestore);
                    
                    const container = document.getElementById('puzzleContainer');
                    const drawer = document.getElementById('puzzleDrawer');
                    
                    // æ¢å¾©æ ¼ç·šå€ç¸®æ”¾
                    if (saveData.containerScale !== undefined) {
                        containerScale = saveData.containerScale;
                        container.style.transform = `scale(${containerScale})`;
                    }
                    
                    // æ¢å¾©æ ¼ç·šå€ä½ç½®
                    if (saveData.containerLeft && saveData.containerTop) {
                        container.style.left = saveData.containerLeft;
                        container.style.top = saveData.containerTop;
                        // æ›´æ–°åŸå§‹ä½ç½®è¨˜éŒ„ï¼ˆç”¨æ–¼æ‹–æ›³è¨ˆç®—ï¼‰
                        containerOriginalPos = {
                            left: parseFloat(saveData.containerLeft),
                            top: parseFloat(saveData.containerTop)
                        };
                    }
                    
                    // æ¢å¾©æ§åˆ¶é¢æ¿æ”¶åˆç‹€æ…‹
                    if (saveData.controlsCollapsed) {
                        controlsCollapsed = true;
                        document.getElementById('controlsDrawer').classList.add('collapsed');
                        document.getElementById('controlsToggle').textContent = 'â–¶';
                    }
                    
                    // æ¢å¾©æ¯å€‹æ‹¼åœ–çš„ç‹€æ…‹
                    saveData.pieces.forEach(savedPiece => {
                        const dp = drawerPieces.find(d => d.piece.pieceNumber - 1 === savedPiece.index);
                        if (!dp) return;
                        
                        // æ¢å¾©æ—‹è½‰ï¼ˆç„¡è«–æ˜¯å¦å·²æ”¾ç½®ï¼‰
                        if (savedPiece.rotation !== 0 && !savedPiece.isPlaced) {
                            dp.piece.currentRotation = savedPiece.rotation;
                            dp.drawerItem.currentRotation = savedPiece.rotation;
                            const div = dp.drawerItem.pieceDiv;
                            const tab = dp.drawerItem.tab;
                            if (div) {
                                div.style.transform = `translate(-${tab}px,-${tab}px) rotate(${savedPiece.rotation}deg)`;
                            }
                        }
                        
                        // æ¢å¾©ä½ç½®
                        if (savedPiece.isPlaced) {
                            // å·²æ”¾ç½®çš„æ‹¼åœ–
                            dp.piece.style.left = dp.piece.correctX + 'px';
                            dp.piece.style.top = dp.piece.correctY + 'px';
                            dp.piece.style.transform = dp.piece.style.transform.replace(/rotate\([^)]+\)/g, '').trim();
                            dp.piece.currentRotation = 0;
                            dp.piece.isPlaced = true;
                            dp.isPlaced = true;
                            container.appendChild(dp.piece);
                            dp.drawerItem.classList.add('placed');
                        } else if (scatterMode && savedPiece.drawerLeft) {
                            // æ•£äº‚æ¨¡å¼ä¸­çš„ä½ç½®
                            dp.drawerItem.style.left = savedPiece.drawerLeft;
                            dp.drawerItem.style.top = savedPiece.drawerTop;
                            if (savedPiece.drawerZIndex) {
                                dp.drawerItem.style.zIndex = savedPiece.drawerZIndex;
                            }
                        }
                    });
                    
                    updateDrawerCount();
                    startAutoSave();
                    console.log('éŠæˆ²å·²æ¢å¾©');
                }
            }, 100);
            
            startGame(true);  // skipConfirm = trueï¼Œè·³éç¢ºèª
        }
        
        // é¡¯ç¤ºç¢ºèªæ–°éŠæˆ²å°è©±æ¡†
        function showConfirmNewGameDialog() {
            const placedCount = drawerPieces.filter(dp => dp.isPlaced).length;
            const totalCount = drawerPieces.length;
            
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.8); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #2a2a2a; border-radius: 12px; padding: 24px;
                max-width: 320px; text-align: center; color: white;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                <h3 style="margin: 0 0 12px; font-size: 18px;">ç¢ºå®šè¦é–‹å§‹æ–°éŠæˆ²ï¼Ÿ</h3>
                <p style="margin: 0 0 20px; color: #aaa; font-size: 14px;">
                    ç•¶å‰é€²åº¦ (${placedCount}/${totalCount} ç‰‡) å°‡æœƒéºå¤±
                </p>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="confirmYes" style="
                        padding: 12px 24px; border: none; border-radius: 8px;
                        background: #d9534f; color: white; font-size: 16px;
                        cursor: pointer;
                    ">é–‹å§‹æ–°éŠæˆ²</button>
                    <button id="confirmNo" style="
                        padding: 12px 24px; border: none; border-radius: 8px;
                        background: #555; color: white; font-size: 16px;
                        cursor: pointer;
                    ">å–æ¶ˆ</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            document.getElementById('confirmYes').onclick = () => {
                overlay.remove();
                startGame(true);  // skipConfirm = true
            };
            
            document.getElementById('confirmNo').onclick = () => {
                overlay.remove();
            };
        }
        
        // é¡¯ç¤ºæ¢å¾©å°è©±æ¡†
        function showRestoreDialog(saveData) {
            const date = new Date(saveData.timestamp);
            const timeStr = date.toLocaleString('zh-TW');
            const placedCount = saveData.pieces.filter(p => p.isPlaced).length;
            const totalCount = saveData.pieces.length;
            
            // å»ºç«‹å°è©±æ¡†
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.8); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #2a2a2a; border-radius: 12px; padding: 24px;
                max-width: 320px; text-align: center; color: white;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 16px;">ğŸ§©</div>
                <h3 style="margin: 0 0 12px; font-size: 18px;">ç™¼ç¾æœªå®Œæˆçš„æ‹¼åœ–</h3>
                <p style="margin: 0 0 8px; color: #aaa; font-size: 14px;">
                    ${saveData.cols}x${saveData.rows} (${totalCount}ç‰‡)
                </p>
                <p style="margin: 0 0 8px; color: #aaa; font-size: 14px;">
                    é€²åº¦ï¼š${placedCount}/${totalCount} ç‰‡
                </p>
                <p style="margin: 0 0 20px; color: #888; font-size: 12px;">
                    ${timeStr}
                </p>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="restoreYes" style="
                        padding: 12px 24px; border: none; border-radius: 8px;
                        background: #4a90d9; color: white; font-size: 16px;
                        cursor: pointer;
                    ">ç¹¼çºŒéŠæˆ²</button>
                    <button id="restoreNo" style="
                        padding: 12px 24px; border: none; border-radius: 8px;
                        background: #555; color: white; font-size: 16px;
                        cursor: pointer;
                    ">é‡æ–°é–‹å§‹</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // äº‹ä»¶è™•ç†
            document.getElementById('restoreYes').onclick = async () => {
                overlay.remove();
                try {
                    await restoreGame(saveData);
                } catch (e) {
                    console.error('æ¢å¾©å¤±æ•—:', e);
                    clearSave();
                    alert('æ¢å¾©å¤±æ•—ï¼Œè«‹é‡æ–°é–‹å§‹éŠæˆ²');
                }
            };
            
            document.getElementById('restoreNo').onclick = () => {
                overlay.remove();
                clearSave();
            };
        }
        
        // é é¢è¼‰å…¥æ™‚æª¢æŸ¥å­˜æª”
        window.addEventListener('load', () => {
            const saveData = loadGame();
            if (saveData && saveData.pieces && saveData.pieces.length > 0) {
                // æª¢æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„é€²åº¦
                const hasProgress = saveData.pieces.some(p => p.isPlaced);
                const allComplete = saveData.pieces.every(p => p.isPlaced);
                
                if (hasProgress && !allComplete) {
                    showRestoreDialog(saveData);
                } else {
                    // å…¨éƒ¨å®Œæˆæˆ–æ²’æœ‰é€²åº¦ï¼Œæ¸…é™¤å­˜æª”
                    clearSave();
                }
            }
        });
        
        // é é¢é—œé–‰å‰å„²å­˜
        window.addEventListener('beforeunload', () => {
            if (isPlaying) {
                saveGame();
            }
        });
        
        // é é¢éš±è—æ™‚å„²å­˜ï¼ˆæ‰‹æ©Ÿåˆ‡æ› appï¼‰
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden' && isPlaying) {
                saveGame();
            }
        });
    </script>
</body>
</html>
